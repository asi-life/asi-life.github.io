(window.webpackJsonp=window.webpackJsonp||[]).push([[43],{536:function(e,r,a){"use strict";a.r(r);var t=a(4),u=Object(t.a)({},(function(){var e=this,r=e.$createElement,a=e._self._c||r;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h2",{attrs:{id:"eureka"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#eureka"}},[e._v("#")]),e._v(" Eureka")]),e._v(" "),a("ol",[a("li",[a("p",[e._v("服务注册(register): Eureka Client会通过发送REST请求的方式向Eureka Server注册自己的服务，提供自身的元数据，比如ip地址，端口，运行状况指标的url，主页地址等信息。Eureka Server接收到注册请求后，就会把这些元数据存储在一个双层的Map中。")])]),e._v(" "),a("li",[a("p",[e._v("服务续约(renew): 在服务注册后，Eureka Client会维护一个心跳来持续通知Eureka Server，说明服务一直处于可用状态，防止被剔除。Eureka Client在默认的情况下会每隔30秒发送一次心跳来进行服务续约。")])]),e._v(" "),a("li",[a("p",[e._v("服务同步(replicate): Eureka Server 之间会互相进行注册，构建Eureka集群，不同的Eureka Server 之间会进行服务同步，保证服务信息的一致性。")])]),e._v(" "),a("li",[a("p",[e._v("获取服务(get registry): 服务消费者(Eureka Client)在启动时，会发送一个REST请求给Eureka Server，获取上面注册的服务清单，并且缓存在Eureka Client本地，默认缓存30秒。同时，为了性能考虑，Eureka Server也会维护一份只读的服务清单缓存，该缓存每隔30秒更新一次。")])]),e._v(" "),a("li",[a("p",[e._v("服务调用：服务消费者在获取到服务清单后，就可以根据清单中的服务列表信息，查找到其他服务的地址，从而进行远程调用。Eureka有Region和Zone概念。一个Region可以包含多个Zone，在进行服务调用时，优先访问处于同一个Zone中的服务提供者。")])]),e._v(" "),a("li",[a("p",[e._v("服务下线(cancel)：当Eureka Client需要关闭或重启时，就不希望再这个时间段内再有请求进来，所以，就需要提前先发送REST请求给Eureka Server，告诉Eureka Server要下线了，Eureka Server收到请求后，就会把该服务状态置为下线，并把下线事件传播出去。")])]),e._v(" "),a("li",[a("p",[e._v("服务剔除(evict): 有时候，服务实例可能会因为网络故障等原因导致不能提供服务，而此时该实例也没有发送请求给Eureka Server来进行服务下线，所以，还需要服务提出的机制。Eureka Server再启动的时候会创建一个定时任务，每隔一段时间(默认60s)，从当前服务清单中把超时没有续约(默认180秒)的服务剔除。")])]),e._v(" "),a("li",[a("p",[e._v("自我保护：短时间内，统计续约失败的比例，达到一定阈值，就会触发自我保护机制，Eureka Server 不会剔除任何的微服务，等正常后，再退出自我保护机制。")])])])])}),[],!1,null,null,null);r.default=u.exports}}]);