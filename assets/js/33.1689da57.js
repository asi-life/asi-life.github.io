(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{528:function(a,t,n){"use strict";n.r(t);var s=n(4),e=Object(s.a)({},(function(){var a=this,t=a.$createElement,n=a._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[n("h2",{attrs:{id:"八股文"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#八股文"}},[a._v("#")]),a._v(" 八股文")]),a._v(" "),n("h3",{attrs:{id:"java基础"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#java基础"}},[a._v("#")]),a._v(" Java基础")]),a._v(" "),n("ol",[n("li",[a._v("HashMap 与 ConcurrentHashMap 的实现原理是怎样的？ConcurrentHashMap 是如何保证线程安全的？")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("答：HashMap底层为一个键值对的Node表。存储数据，通过key值计算hashcode值，作为存储的key值，value为传入的value。当重复的hashcode值会通过链表保存，当链表长度为8时会转换成红黑树。1.7使用头插法，存在插入循环bug。\n\n扩容：当存入的数据达到容量的*3/4时会进行扩容处理。扩容为下一个2的次方值。并进行重新计算，分配值。\n\nConcurrentHashMap，JDK1.7中使用分段锁进行实现的。\n\nJDK1.8中保持了和HashMap一样的结构，通过synchronized和乐观锁实现的。同时线程会帮助进行扩容处理。\n\n")])])]),n("ol",{attrs:{start:"2"}},[n("li",[a._v("简述 ArrayList 与 LinkedList 的底层实现以及常见操作的时间复杂度")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("答：ArrayList 底层为数组，LinkedList底层为链表\n")])])]),n("ol",{attrs:{start:"3"}},[n("li",[a._v("实现单例设计模式（懒汉，饿汉）")])]),a._v(" "),n("div",{staticClass:"language-java extra-class"},[n("pre",{pre:!0,attrs:{class:"language-java"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("class")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Demo")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n  "),n("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("private")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Demo")]),a._v(" instance"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n\n  "),n("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("private")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Object")]),a._v(" object "),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Object")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n\n  "),n("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("private")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Demo")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n\n  "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n\n  "),n("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Demo")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[a._v("getInstantce")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("if")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("instance "),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v("==")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("null")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n      "),n("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("synchronized")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("object"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n        "),n("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("if")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("instance "),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v("==")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("null")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n          instance "),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v("==")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Demo")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n        "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n      "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n    "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" instance"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n  "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n\n")])])]),n("ol",{attrs:{start:"4"}},[n("li",[a._v("== 和 equals() 的区别？")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("答： == 为地址之间的比较，equals()重写情况下为值的比较。\n")])])]),n("ol",{attrs:{start:"5"}},[n("li",[a._v("简述 Java 的反射机制及其应用场景")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v('答：使用Reflection代理类，Class.forName("");\n')])])]),n("ol",{attrs:{start:"6"}},[n("li",[a._v("Java 中接口和抽象类的区别")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("1. 关键字不一样 接口： interface 抽象：abstract\n\n2. 实现接口都要讲所有方法实现。 继承抽象类，如果抽象类中有未实现的方法，则需要实现，否则可以根据自己的需要实现\n\n3. 接口中的变量必须用public static final 修饰，并且需要给出初始值。\n\n")])])]),n("ol",{attrs:{start:"7"}},[n("li",[a._v("String，StringBuffer，StringBuilder 之间有什么区别？")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("1. String 被赋值以后就不能被修改\n\n2. StringBuilder 可实现变长字符串，但是是线程不安全的\n\n3. StringBuffer 可实现变长字符串，是线程安全的\n")])])]),n("ol",{attrs:{start:"8"}},[n("li",[a._v("String 类能不能被继承？为什么？")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("不能，因为被final修饰符修饰\n")])])]),n("ol",{attrs:{start:"9"}},[n("li",[a._v("简述动态代理与静态代理")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("静态代理：\n1. 由程序员创建特定工具自动生成源代码，再对其编译。再程序运行前，代理类.class文件就已经存在了\n2. 竞态代理通常只代理一个类\n3. 静态代理事先知道要代理的是什么\n\n动态代理：\n1. 在程序运行时，运行反射机制动态创建而成\n2. 动态代理时代理一个接口下的多个实现类\n3. 动态代理不知道要代理什么东西，只有在运行时才知道。\n\n一种为JDK的Proxy(需要实现接口)，另一种为CGLIB\n")])])]),n("ol",{attrs:{start:"10"}},[n("li",[a._v("hashcode 和 equals 方法的联系")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("hashcode 相同，但是equals不一定相等\n\nequals 相等， hashcode一定相等\n")])])]),n("ol",{attrs:{start:"11"}},[n("li",[a._v("什么是重写和重载？")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("重写是子类重写父类的方法\n\n重载是方法名相同，但是参数个数或者参数类型不同。\n")])])]),n("ol",{attrs:{start:"12"}},[n("li",[a._v("Java 异常有哪些类型？")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("\n都是Throwable的子类\n\n包含Error 和 Exception\n\nException：运行时异常和非运行时异常\n")])])]),n("ol",{attrs:{start:"13"}},[n("li",[a._v("new Integer 和 Integer.valueOf 的区别是什么？")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("Interger引用类型变量a中储存在堆中开辟的空间的地址，地址中储存100\n\n直接调用Interger的属性valueOf,将int类型的10，隐式加包为Interger类型的10.\n再将转化后的10储存在Interger引用类型变量a中\n")])])]),n("h3",{attrs:{id:"java并发-juc"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#java并发-juc"}},[a._v("#")]),a._v(" Java并发(juc)")]),a._v(" "),n("ol",[n("li",[a._v("Synchronized 关键字底层是如何实现的？它与 Lock 相比优缺点分别是什么？")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("synchronized 锁对象底层：为monitorenter 和 monitorexit，每隔对象都有一个监视器锁(monitor)， monitor被占用就会处于锁定状态。如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1.  \n\n锁方法的底层为 ACC_SYNCHRONIZED 标示符。JVM就是根据该标示符来实现方法的同步的。通过检查方法的ACC_SYNCHRONIZED访问标识是否被设置，如果设置了，执行线程件先获取monitor，获取成功之后才能执行方法体，方法执行完后再释放monitor。在方法执行期间，其他任何线程都无法再获得同一个monitor对象。\n\n出现异常，或者结束，自动释放锁，不需要Lock手动释放锁\n\n无法判断所得状态，非公平锁，且不可中断。适用于少量同步的场景。\n\n")])])]),n("ol",{attrs:{start:"2"}},[n("li",[a._v("volatile 关键字解决了什么问题，它的实现原理是什么？")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("线程之间增加了可见性。\n\n当一个线程修改信息后，没有立刻更新主存，而是先更新线程的工作内存。而增加volatile关键字，线程在修改完后就会立即更新主存，保证数据修改后立刻对其他线程可见。同时防止了指令重排。\n\n")])])]),n("ol",{attrs:{start:"3"}},[n("li",[a._v("线程池是如何实现的？简述线程池的任务策略")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("通过初始化 ThreadPoolExecutor 实现。\n\n主要有几个参数：\n\n核心线程数 corePoolSize:\n\n最大线程数 maximumPoolSize:\n\n线程执行完后存活时间数 keepAliveTime:\n\n线程队列 workQueue: 主要有 ArrayBlockingQueue(基于数组结构的有界阻塞队列), LinkedBlockingQueue(基于链表的无界阻塞队列), SynchronousQueue(一个不存储元素的阻塞队列) ， PriorityBlockingQueue(一个具有优先级的无界阻塞队列)\n\n拒绝策略 handler：AbortPolicy: 直接抛出异常;CallerRunPolicy：只用调用者所在线程来运行任务;DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务; DiscardPolicy：不处理直接丢掉。\n\n")])])]),n("ol",{attrs:{start:"4"}},[n("li",[a._v("ThreadLocal 实现原理是什么？")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("底层是：ThreadLocalMap，map的底层为 Entry,key 为ThreadLocal，value为值\n\n弱引用\n")])])]),n("ol",{attrs:{start:"5"}},[n("li",[a._v("简述 CAS 原理，什么是 ABA 问题，怎么解决？")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("只要有三个值：一个为需要修改的字段，一个为原值，一个为需要改的值。\n\n只有为原值，才能改成期望改的值。\n")])])]),n("ol",{attrs:{start:"6"}},[n("li",[a._v("Java 常见锁有哪些？ReetrantLock 是怎么实现的？")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("1. synchronized\n\n2. ReetrantLock\n\na). 主要为实现 Sync(AbstractQueuedSynchronizer)\n\nb). 主要实现公平锁和非公平锁。\n\nc). 非公平锁尝试获取锁，没有锁时，会尝试将状态设置为1，如果设置成功，将 exclusiveOwnerThread 占有的主线程为当前线程。如果不为0，则判断是否是同一个锁，进行重入锁。\n\nd). 获取头部的队列，且头部要等于当前线程，然后尝试将状态设置为1，如果设置为1，将 exclusiveOwnerThread 占有的主线程为当前线程。如果不为0，则判断是否是同一个锁，进行重入锁。\n\n3. ReentrantReadWriteLock\n\n4. CountDownLatch \n\n5. CyclicBarrier \n\n")])])]),n("ol",{attrs:{start:"7"}},[n("li",[a._v("什么是公平锁？什么是非公平锁？")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("公平锁：先进的先获得锁\n\n非公平锁：谁都有可能获取锁\n")])])]),n("ol",{attrs:{start:"8"}},[n("li",[a._v("Java 是如何实现线程安全的，哪些数据结构是线程安全的？")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("主要通过加锁机制。\n\nConcurrentHashMap.\n\nHashTable\n\nVector\n\nCopyOnWriteArrayList\n\nCopyOnWriteArraySet\n\nHashSet\n\nConcurrentLinkedQueue\n\nStringBuffer\n")])])]),n("ol",{attrs:{start:"9"}},[n("li",[a._v("简述 Java 锁升级的机制")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("java 锁有如下几个过程：\n\n无锁，偏向锁，轻量级锁，重量级锁。\n\nMark Word头中有 1bit表示是否为偏向锁，有2bit表示锁的状态，00为轻量级锁，10为重量级锁，01为偏向锁。\n\n偏向锁：大都是情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得。该类情况为偏向锁。\n\n在多线程情况下会转为轻量级锁或者重量级锁。\n\n轻量级锁：当关闭偏向锁功能或者多个线程竞争偏向锁导致偏向锁升级为轻量级锁。\n\n重量级锁：多线程竞争下，没有获取到锁的线程会进行自旋，如果自旋还没有获取到锁，会升级为重量级锁。\n\n\n")])])]),n("ol",{attrs:{start:"10"}},[n("li",[a._v("Java 中 sleep() 与 wait() 的区别")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("sleep() 为线程的方法，会释放锁资源，不会堵塞\n\nwait() 为Object方法，不会释放资源，会堵塞，需要唤醒\n\n")])])]),n("ol",{attrs:{start:"11"}},[n("li",[a._v("Java 的线程有哪些状态，转换关系是怎么样的？")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("线程有State类进行记录：\n\n中间有 NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, TERMINATED 状态。\n\n初始化为 NEW,\n\n执行start()进入RUNNABLE, 获取到CPU资源进入运行状态\n\n未获取到锁进入阻塞状态\n\nwait()等方法进行等待状态\n\n执行完成或异常进入终止状态\n\n")])])]),n("ol",{attrs:{start:"12"}},[n("li",[a._v("简述 Java AQS 的原理以及使用场景")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("AbstractQueuedSynchronizer：AQS(抽象队列同步器)。\n\n有一个双向列表Node，以及 state\n\nstate变量表示锁的状态 0 表示未锁定 大于0表示已锁定 需要注意的是，这个值可以用来实现锁的【可重入性】，例如 state=3 就表示锁被同一个线程获取了3次，想要完全解锁，必须要对应的解锁3次 同时这个变量还是用volatile关键字修饰的，保证可见性\n\n")])])]),n("ol",{attrs:{start:"13"}},[n("li",[a._v("Java 线程和操作系统的线程是怎么对应的？Java线程是怎样进行调度的?")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("操作系统线程模型：\n\n1. 线程实现在用户空间下。需要自己实现线程的数据结构，创建销毁和调度维护。相当于需要实现一个自己的线程调度内核。线程的调度只是在用户态，减少了操作系统从内核态到用户态的切换开销。\n\n2. 线程实现在操作系统内核。直接调用操作系统中已经实现的线程。\n\n3. 使用用户线程加轻量级进程混合实现。在这种混合实现下，即存在用户线程，也存在轻量级进程。用户线程还是完全建立在用户空间中，因此用户线程的创建、切换、析构等操作依然廉价，并且可以支持大规模的用户线程并发。而操作系统提供支持的轻量级进程则作为用户线程和内核线程之间的桥梁，这样可以使用内核提供的线程调度功能及处理器映射，并且用户线程的系统调用要通过轻量级进程来完成，大大降低了整个进程被完全阻塞的风险。\n\nJAVA jdk1.2以后，线程模型替换为基于操作系统原生线程模型来实现。\n\nJava中线程的本质，其实就是操作系统中的线程.\n")])])]),n("ol",{attrs:{start:"14"}},[n("li",[a._v("Java 线程池里的 arrayblockingqueue 与 linkedblockingqueue 的使用场景和区别")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("arrayblockingqueue: 基于数组的有界队列\n\nlinkedblockingqueue： 基于链表的无界队列\n")])])]),n("ol",{attrs:{start:"15"}},[n("li",[a._v("JVM 是怎么去调优的？了解哪些参数和指令？")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("jstat -gc PID\n\njmap -head PID\n\njhat -port 7000 dump.hprof\n")])])]),n("ol",{attrs:{start:"16"}},[n("li",[a._v("JAVA 创建多线程的方法有哪些？")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("1. 使用Executors进行创建线程\n2. 使用ThreadPoolExector\n")])])]),n("ol",{attrs:{start:"17"}},[n("li",[a._v("产生死锁的必要条件有哪些？如何解决死锁？")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("1. 互斥条件\n\n2. 请求与保持条件\n\n3. 不可剥夺条件\n\n4. 循环等待条件\n\n不满足四个条件即可\n")])])]),n("ol",{attrs:{start:"18"}},[n("li",[a._v("Java 线程间有多少通信方式？")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("等待/唤醒机制，wait 和 notify/notifyAll\n\n使用Lock 和 Condition，await(), signal();\n\n使用阻塞队列控制线程通信\n\n使用管道流进行线程通信\n")])])]),n("h3",{attrs:{id:"jvm"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#jvm"}},[a._v("#")]),a._v(" JVM")]),a._v(" "),n("ol",[n("li",[a._v("Java 中垃圾回收机制中如何判断对象需要回收？常见的 GC 回收算法有哪些？")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("有两种方式：一种为使用计数，另一种为可达性分析。java中使用的垃圾回收机制为后一种。判断对象是否被GC ROOT可达，如果不可达，则可被回收。\n\n常见的垃圾回收算法有：复制算法，标记清除算法，标记整理算法。\n")])])]),n("ol",{attrs:{start:"2"}},[n("li",[a._v("JMM 中内存模型是怎样的？什么是指令序列重排序？")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("包括：共享变量存储在主存中，每个线程都有自己的工作内存，线程的工作内存中保存了主存的副本。线程不饿能直接操作主存中的数据，必须先读/写本地工作内存中。\n\n指令重排序是指jvm编译后自动对代码进行的一些优化。可能会改变你写的代码的顺序，但是对结果没有影响。\n\n")])])]),n("ol",{attrs:{start:"3"}},[n("li",[a._v("Java 类的加载流程是怎样的？什么是双亲委派机制？")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("加载，验证，准备，解析，初始化，使用，卸载。\n\n双亲委派：加载一个类会将这个类交给父类加载器进行加载。\n\n")])])]),n("ol",{attrs:{start:"4"}},[n("li",[a._v("JVM 内存是如何对应到操作系统内存的？")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("操作系统只有堆和栈，\n\n而JVM的内存在操作系统的堆\n")])])]),n("ol",{attrs:{start:"5"}},[n("li",[a._v("Java 怎么防止内存溢出")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("合理的回收掉使用的对象，及时将不需要的对象的引用给删除。\n")])])]),n("ol",{attrs:{start:"6"}},[n("li",[a._v("什么是内存泄漏，怎么确定内存泄漏？")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("内存不够，导致申请对象的时候，出现内存泄漏。\n\n会出现OOM异常\n")])])]),n("ol",{attrs:{start:"7"}},[n("li",[a._v("简述 CMS 与 G1 机制的区别")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("CMS 适用于老年代的垃圾回收器，为标记清理算法。\n\nG1 为老年代和新生代的垃圾回收器，使用Region进行管理。\n")])])]),n("ol",{attrs:{start:"8"}},[n("li",[a._v("如何优化 JVM 频繁 minor GC")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("首先要知道什么时候会执行minor GC\n\n即年轻代空间不足了才会执行minor GC。同时执行minor GC会导致stop the world。\n\n所以需要把 eden区尽量维持到比较合理的地方。\n")])])]),n("ol",{attrs:{start:"9"}},[n("li",[a._v("简述 Java 的逃逸分析机制")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("逃逸分析是指分析指针动态范围的方法，它同编译器优化原理的指针分析和外形分析相关联。当变量（或者对象）在方法中分配后，其指针有可能被返回或者被全局引用，这样就会被其他过程或者线程所引用，这种现象称作指针（或者引用）的逃逸(Escape)。\n\n逃逸分析来决定某些实例或者变量是否要在堆中进行分配，如果开启了逃逸分析，即可将这些变量直接在栈上进行分配，而非堆上进行分配。\n")])])]),n("h3",{attrs:{id:"数据库"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#数据库"}},[a._v("#")]),a._v(" 数据库")]),a._v(" "),n("h3",{attrs:{id:"网络编程"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#网络编程"}},[a._v("#")]),a._v(" 网络编程")]),a._v(" "),n("ol",[n("li",[a._v("简述 BIO, NIO, AIO 的区别")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("BIO: 堵塞同步IO，一个线程负责一个IO\n\nNIO：非堵塞同步IO，由一个Selector来负责管理IO，最终将IO分配给一个线程或多个线程进行处理。\n\nAIO：非堵塞异步IO\n")])])]),n("ol",{attrs:{start:"2"}},[n("li",[a._v("简述 Netty 线程模型，Netty 为什么如此高效？")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("reactor模型。异步，非阻塞的事件驱动模型。\n\n使用一个线程组来监听连接和处理连接请求。\n\n使用work线程来处理读写请求。\n\n")])])]),n("ol",{attrs:{start:"3"}},[n("li",[a._v("简述 TCP 三次握手以及四次挥手的流程。为什么需要三次握手以及四次挥手？")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("三次握手：\n1. 客户端发送SYN = 1, seq = u给服务端。\n\n2. 服务端收到seq后，发送seq = v, SYN = 1, ack = u + 1和 ACK=1的信息给客户端\n\n3. 客户端收到后，回复ACK = 1, seq = v + 1的数据给服务端\n\n四次挥手：\n\n1. 客户端发送FIN = 1, seq = x的断开信息给服务端\n\n2. 服务端收到以后返回 ACK = 1, ack = x + 1的信息返回给客户端\n\n3. 服务端后续再次发送 FIN = 1, seq = y的信息给客户端\n\n4. 客户端接收以后返回 ACK = 1, ack = y + 1的信息给服务端\n")])])]),n("ol",{attrs:{start:"4"}},[n("li",[a._v("HTTP 与 HTTPS 有哪些区别？")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("HTTP: 端口80\n\nHTTPS: 端口443，进行加密。使用了对称和非对称加密\n")])])]),n("ol",{attrs:{start:"5"}},[n("li",[a._v("从输入 URL 到展现页面的全过程")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("1. 构建HTTP Request请求\n\na). 应用层进行DNS解析\n\nb). 应用层生成HTTP请求报文\n\nc). 传输层建立TCP连接\n\nd). 网络层使用IP协议来选择线路\n\ne). 数据链路层实现网络相邻节点间可靠的数据通信\n\nf). 物理层传输数据\n\n2. 网络传输\n\na). 集线器\n\nb). 交换机\n\nc). 路由器\n\n3. 服务器构建HTTP Response响应\n\n从下往上解析后，再从上往下包装。\n\n4. 网络传输\n\n5. 渲染页面\n\n")])])]),n("ol",{attrs:{start:"6"}},[n("li",[a._v("TCP与UDP在网络协议中的哪一层，他们之间有什么区别")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("应用层协议：FTP、HTTP、SMTP\n\n传输层协议：TCP协议、UDP协议\n\n网络层协议：IP协议\n\nTCP，安全，保证数据完整性\n\nUDP：快\n")])])]),n("ol",{attrs:{start:"7"}},[n("li",[a._v("TCP 怎么保证可靠传输？")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("\n确认和重传\n\n数据校验\n\n数据合理分片和排序\n\n流量控制\n\n拥塞控制\n")])])]),n("ol",{attrs:{start:"8"}},[n("li",[a._v("简述 HTTP 1.0，1.1，2.0 的主要区别")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("1.0 和 1.1的主要区别：\n\na). 缓存处理\n\nb). 带宽优化及网络连接的使用\n\nc). 错误通知的管理，增加响应码\n\nd). Host头的处理，HOST域处理\n\ne). 长连接\n\nSPDY: HTTP1.X的优化。\n\na). 降低延迟\n\nb). 请求优先级\n\nc). header压缩\n\nd). HTTPS的加密传输\n\ne). 服务端推送\n\nHTTP2.0\n\na). 新的二进制格式\n\nb). 多路复用\n\nc). header压缩\n\nd). 服务端推送\n")])])]),n("ol",{attrs:{start:"9"}},[n("li",[a._v("TCP 中常见的拥塞控制算法有哪些？")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("慢开始\n\n拥塞控制\n\n快重传\n\n快恢复\n")])])]),n("ol",{attrs:{start:"10"}},[n("li",[a._v("DNS 查询服务器的基本流程是什么？DNS 劫持是什么？")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("假定域名为m.xyz.com的主机想知道另一台主机（域名为y.abc.com）的IP地址。例如，主机m.xyz.com打算发邮件给y.abc.com，此时，必须知道主机y.abc.com的IP地址：\n1.主机m.xyz.com先向其本地域名服务器进行递归查询。\n2.本地域名服务器采用迭代查询。它先向一个根域名服务器查询。\n3.根域名服务器告诉本地域名服务器下一次该查询的顶级域名服务器的IP地址。\n4.本地域名服务器向顶级域名服务器进行查询。\n5.顶级域名服务器告诉本地域名服务器下一次应查询的权限域名服务器的IP地址。\n6.本地域名服务器向权限域名服务器进行查询。\n7.权限域名服务器告诉本地域名服务器所查询的主机的IP地址。\n8.本地域名服务器最后把查询结果告诉主机m.xyz.com。\n\n\n就是通过劫持了DNS服务器，通过某些手段取得某域名的解析记录控制权，进而修改此域名的解析结果，导致对该域名的访问由原IP地址转入到修改后的指定IP，其结果就是对特定的网址不能访问或访问的是假网址，从而实现窃取资料或者破坏原有正常服务的目的。\n")])])]),n("ol",{attrs:{start:"11"}},[n("li",[a._v("TCP 挥手时出现大量 CLOSE_WAIT 或 TIME_WAIT 怎么解决？")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("统计tcp状态数量：\n\nnetstat -n | awk '/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}' \n\n出现大量TIME_WAIT的原因以及解决办法\n\n存在大量短连接，并且由该方主动关闭。需要优化内核。\n\n出现大量CLOSE_WAIT的原因以及解决办法\n\n如果一直保持在CLOSE_WAIT状态，那么只有一种情况，就是在对方关闭连接之后服务器程序自己没有进一步发出ack信号。换句话说，就是在对方连接关闭之后，程序里没有检测到，或者程序压根就忘记了这个时候需要关闭连接，于是这个资源就一直被程序占着。这种情况通过服务器内核参数也没办法解决，服务器对于程序抢占的资源没有主动回收的权利，除非终止程序运行。\n所以如果将大量CLOSE_WAIT的解决办法总结为一句话那就是：查代码。因为问题出在程序里头啊。\n\n")])])]),n("ol",{attrs:{start:"12"}},[n("li",[a._v("Netty是什么")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("基于NIO的客户端服务器框架，可以快速简单地开发网络应用程序。\n\n极大地简化并优化了TCP和UDP套接字服务器等网络编程，并且性能以及安全性等很多方面都甚至更好\n\n支持多种协议，FTP,SMTP,HTTP以及各种二进制和基于文本地传统协议\n")])])]),n("ol",{attrs:{start:"13"}},[n("li",[a._v("为什么要用Netty")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("统一的api，支持多种传输类型，阻塞和非阻塞的。\n\n简单而强大的线程模型\n\n自带编解码器解决TCP粘包/拆包问题\n\n自带各种协议栈\n\n真正的无连接数据包套接字支持\n\n比直接使用Java核心API有更高的吞吐量，更低的延迟，更低的资源消耗和更少的内存复制\n\n安全性不错\n")])])]),n("ol",{attrs:{start:"14"}},[n("li",[a._v("Netty的应用场景")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("RPC框架的网络通信工具\n\n实现一个自己的HTTP服务器\n\n实现一个即时通讯系统\n")])])]),n("ol",{attrs:{start:"15"}},[n("li",[a._v("Netty核心组件有哪些，分别有什么作用")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("EventLoopGroup：多个EventLoop\n\nEventLoop：复制监听网络事件并调用事件处理器进行相关I/O操作的处理\n\nChannel: Netty对网络操作抽象类\n\nChannelFuture：Netty是异步非阻塞的，所有的I/O操作都为异步的。\n\nChannelHandler：消息的具体处理器\n\nChannelPipeline：提供了一个容器并定义了用于沿着链传播入站和出战的事件流的API\n\n")])])]),n("ol",{attrs:{start:"16"}},[n("li",[a._v("EventloopGroup了解嘛？和EventLoop啥关系")])]),a._v(" "),n("p",[a._v("EventloopGroup包含多个EventLoop(每一个EventLoop通常内部包含一个线程)。")]),a._v(" "),n("p",[a._v("EventLoop处理的I/O事件都将在它专有的Thread上被处理，即Thread和EventLoop属于1:1关系，从而保证线程安全。")]),a._v(" "),n("ol",{attrs:{start:"17"}},[n("li",[a._v("Bootstrap 和 ServerBootstrap了解嘛")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("Bootstrap是客户端的启动引导类/辅助类.\n通常使用connect方法连接到远程的主机和端口。作为一个Netty TCO协议通信中的客户端。另外也可以通过bind()方法绑定本地一个端口，作为UDP协议通信中的一端。\n只需要配置一个线程组。\n\n\nServerBootstrap服务端的启动引导类/辅助类\n通常使用bind()方法绑定本地的端口上，然后等待客户端的连接。\n需要配置两个线程组：一个用于接收连接，一个用于具体的处理。\n\n")])])]),n("ol",{attrs:{start:"18"}},[n("li",[a._v("NioEventLoopGroup默认的构造函数会起多少线程")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("默认为CPU核心数*2\n\n每个NioEventLoopGroup对象内部都会分配一组NoiEventLoop，其大小是nThreads。构造一个线程池。对应一个线程组。\n")])])]),n("ol",{attrs:{start:"19"}},[n("li",[a._v("Netty线程模型了解么")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("大部分网络框架都是基于Reactor模式开发的。\n\nReactor模式基于事件驱动，采用多路复用将事件分发给相应的Hadnler处理，非常适合处理海量IO的场景\n\nNetty主要靠NioEventLoopGroup线程池来实现具体的线程模型的。\n\n我们实现服务端的时候一般会初始化两个线程组：\n1. BossGroup：接收连接\n2. WorkerGroup：负责具体的处理，交由对应的Handler处理。\n\n主要线程模型有：\n1. 单线程模型，一个线程需要执行处理所有的accept，read，docode，process，encode，send事件。\n\n2. 多线程模型：一个Acceptor线程负责监控客户端连接，一个NIO线程池负责具体处理accept，read，decode，process，encode，send事件。满足绝大部分应用场景，并发连接量不大的时候没啥问题。\n\n3. 主从多线程模型：主线程NIO线程池中选择一个线程作为Acceptor线程，绑定监听端口，接收客户端连接的连接，其他线程负责后续的接入认证等工作。连接建立完成后，Sub NIO线程池负责具体处理I/I读写。\n")])])]),n("ol",{attrs:{start:"20"}},[n("li",[a._v("Netty服务器和客户端的启动过程")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("服务端：\n1. 首先创建两个NioEventLoopGroup对象实例：bossGroup和workerGroup。\n\n2. 创建服务器引导类/辅助类：ServerBootstrap，这个类将引导我们进行服务端的启动工作\n\n3. 通过 .group() 方法给引导类ServerBootstrap配置两道线程组，确认线程模型。\n\n4. 通过channel()方法给引导类ServerBootstrap指定了IO模型为NIO\n\n5. 通过.childHandler()给引导类创建一个ChannelInitializer, 然后指定了服务端消息的业务逻辑 HelloServerHandler对象\n\n6. 调用ServerBootstrap类的bind()方法绑定端口。\n\n\n客户端：\n1. 创建一个NioEventLoopGroup对象实例\n\n2. 创建客户端启动的引导类是Bootstrap\n\n3. 通过.group()方法给引导类Bootstrap配置一个线程组\n\n4. 通过channel()方法给引导类Bootstrap指定了IO模型为NIO\n\n5. 通过 .childHandler()给引导类创建一个ChannelInitializer，然后指定了客户端消息的业务处理逻辑HelloClientHandler对象\n\n6. 调用Bootstrap类的connect()方法进行连接。\n")])])]),n("ol",{attrs:{start:"21"}},[n("li",[a._v("什么是TCP粘包/粘包? 有什么解决办法嘛")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v('1. TCP粘包/拆包 基于TCP发送数据的时候，出现了多个字符串"粘"再了一起或者一个字符串被"拆"开的问题。\n\n2. 解决办法：\n\nNetty自带的解码器：\n\na). LineBasedFrameDecoder: 发送端发送数据包时，每隔数据包之间以换行符作为分隔，LineBaseFrameDecoder的工作原理是它依次遍历ByteBuf中的可读字节，判断是否有换行符，然后进行相应的截取。\n\nb). DelimiterBasedFrameDecoder: 可以自定义分隔符解码器\n\nc). FixedLengthFrameDecoder: 固定长度解码器，能够按照指定的长度对消息进行相应的拆包\n\nd). LengthFieldBaseFrameDecoder: 长度字段解码器。有五个参数: maxFrameLength: 数据最大长度(包括附加信息，长度标识等内容)。lengthFildOffset(数据长度标识的起始偏移量)用于指明数据第几个字节开始用于标识有用字节长度。lengthFieldLength数据长度标识所占字节数(用于指明有用数据的长度)。lengthAdjustment长度表示与有用数据的偏移量，用于指明数据长度标识和有用数据之间的距离。\ninitialBytesToStrip数据读取起点。读取起点\n\ne). 自定义解码器\n')])])]),n("ol",{attrs:{start:"22"}},[n("li",[a._v("Netty长连接，心跳机制了解嘛")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("长连接：连接完后，完成读写后不进行关闭。\n\nTCP保持长连接的过程中，可能会出现断网等网络异常问题。client和server之间没有交互的话，无法发现对象已经掉线的。\n\n再client和server之间在一定时间内没有数据交互时，即处于idle状态时，客户端或服务器就会发送一个特殊的数据包给对方，当接收方收到这个数据报文后，也立即发送一个特殊的数据报文，回应发送方，即一个PING-PONG交互。\n")])])]),n("ol",{attrs:{start:"23"}},[n("li",[a._v("Netty的零拷贝")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("CPU不需要先将数据从某处内存复制到另一个特定区域，这种技术通常用于通过网络传输文件时节省CPU周期和内存宽带。\n\n主要体现在：\n\na). 使用Netty提供的CompositeByteBuf类，可以将多个ByteBuf合并为一个逻辑上的ByteBuf，避免了各个ByteBuf之间的拷贝\n\nb). ByteBuf支持slice操作，可以将ByteBuf分解为多个共享同一个存储区域的ByteBuf，避免内存的拷贝。\n\nc). 通过FileRegion包装的FileChannel.tranferTo实现文件传输，可以直接将文件缓冲区的数据发送到目标Channel，避免了传统通过循环write方式导致的内存拷贝问题。\n\n")])])]),n("h3",{attrs:{id:"操作系统"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#操作系统"}},[a._v("#")]),a._v(" 操作系统")]),a._v(" "),n("h3",{attrs:{id:"消息队列"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#消息队列"}},[a._v("#")]),a._v(" 消息队列")]),a._v(" "),n("h3",{attrs:{id:"redis"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#redis"}},[a._v("#")]),a._v(" redis")]),a._v(" "),n("h3",{attrs:{id:"spring"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#spring"}},[a._v("#")]),a._v(" Spring")]),a._v(" "),n("ol",[n("li",[a._v("简述 Spring AOP 的原理")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("1. Spring 使用 @EnableAspectJAutoProxy开启aop。会通过@import导入 AspectJAutoProxyRegistrar。又导入了AnnotationAwareAspectJAutoProxyCreator 即为一个 PostProcess类.\n\n同时使用 @Aspect 实现相关aop类。\n\n根据bean初始化流程，在初始化bean后，会执行postProcess，则会判断当前Bean是否满足相关Aop的设置，如果满足会给当前Bean加入一个调用链。\n\n")])])]),n("ol",{attrs:{start:"2"}},[n("li",[a._v("简述 Spring bean 的生命周期")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("1. 实例化BeanFactoryPostProcessor实现类\n\n2. 创建BeanFactory的后置处理器\n\n3. 注册Bean的后置处理器\n\n4. 实例化 InstantiationAwareBeanPostProcessorAdapter实现类\n\n5. 执行InstantiationAwareBeanPostProcessor的前置方法\n\n6. 执行构造方法\n\n7. 执行InstantiationAwareBeanPostProcessor的postProcessAfterInstantiation方法\n\n8. 执行 InstantiationAwareBeanPostProcessor 的 postProcessPropertyValues 方法\n\n9. 为属性设置值\n\n10. 使用BeanNameAware的设置name\n\n11. 调用BeanFactoryAware设置BeanFactory\n\n12. 执行PostProcess的前置方法。\n\n13. 调用InitializingBean的afterPropertiesSet方法，进行初始化，调用初始化方法\n\n14. 执行PostProcess的后置方法\n\n15. 初始化成功\n\n16. 调用销毁方法。\n\n\n")])])]),n("ol",{attrs:{start:"3"}},[n("li",[a._v("Spring MVC 的原理和流程")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("1. 请求打到后台\n\n2. 经过DispatchServlet进行处理\n\n3. 找到对应Handler\n\n4. DispatchServlet通过适配器执行相关Handler\n\n5. 返回相关的ModelAndView\n\n6. 使用视图器解析View\n\n7. 将model设置到view\n\n8. 返回给前端\n\n")])])]),n("ol",{attrs:{start:"4"}},[n("li",[a._v("简述 Spring 注解的实现原理")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("Spring对注解的支持主要都是通过反射来获取相应的注解，来做相应的处理\n")])])]),n("ol",{attrs:{start:"5"}},[n("li",[a._v("如何解决 Spring 的循环依赖问题？")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("使用三级缓存。\n\n一级为已经生成的bean\n\n二级为正在生成的bean(提前曝光的单例bean)\n\n三级为对象工厂的bean\n\n")])])]),n("ol",{attrs:{start:"6"}},[n("li",[a._v("简述 Spring 的 IOC 机制")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("IOC为 控制反转。将有程序员创建实例的过程交给了 Spring。\n")])])]),n("ol",{attrs:{start:"7"}},[n("li",[a._v("SpringBoot 是如何进行自动配置的？")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("@EnableAutoConfiguration\n\n使用 @Import(EnableAutoConfigurationImportSelector.class)\n\n借助 EnableAutoConfigurationImportSelector。@EnableAutoConfiguration可以帮助SpringBoot应用将所有符合条件的@Configuration配置都加载到当前SpringBoot创建并使用的IoC容器。\n\nSpringFactoriesLoader 类，会读取 META-INF 目录下的 spring.factories 文件，获得每个框架定义的需要自动配置的配置类。\n")])])]),n("h3",{attrs:{id:"分布式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#分布式"}},[a._v("#")]),a._v(" 分布式")]),a._v(" "),n("h2",{attrs:{id:"其他问题"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#其他问题"}},[a._v("#")]),a._v(" 其他问题")]),a._v(" "),n("h3",{attrs:{id:"项目中最难的地方是什么"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#项目中最难的地方是什么"}},[a._v("#")]),a._v(" 项目中最难的地方是什么")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("1. 后台服务早上出现OOM，导致服务不可用。\n\n\n2. 刚入职时的时候。\n\n")])])]),n("h2",{attrs:{id:"项目"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#项目"}},[a._v("#")]),a._v(" 项目")]),a._v(" "),n("ol",[n("li",[a._v("售卖机项目")])]),a._v(" "),n("p",[a._v("一个基于售卖机的科技零售。主要使用SpringCloud和Netty。主要有充值，下单，调货等流程，同时有后台对售卖机，货道，商品，订单等进行管理。")]),a._v(" "),n("p",[a._v("充值流程：用户输入手机号，选择需要充值的金额。调用后台进行判断是否被风控。然后塞入金额，调用接口进行充值流程。涉及到钱，需要保证流程完整。")]),a._v(" "),n("p",[a._v("(主要措施有：设备会上传塞币请求，直到调用成功，同时会有日志记录。后续调用充值接口，如果充值失败，会记录在数据库中，然后每隔五分钟进行重试。同时提供后台手动充值的按钮)")]),a._v(" "),n("p",[a._v("下单流程：输入手机号，选择商品，生成二维码，用户通过手机进行扫描二维码进行支付。调用后台进行支付回调，处理数据后。调用netty远程调用设备下发调货命令。")]),a._v(" "),n("p",[a._v("数据量：每日10W日订单量。")]),a._v(" "),n("ol",{attrs:{start:"2"}},[n("li",[n("p",[a._v("云曜项目")])]),a._v(" "),n("li",[n("p",[a._v("测温云平台项目")])])]),a._v(" "),n("h2",{attrs:{id:"自我介绍"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#自我介绍"}},[a._v("#")]),a._v(" 自我介绍")]),a._v(" "),n("p",[a._v("你好。我叫王嗣政，19年长沙理工大学毕业。")]),a._v(" "),n("p",[a._v("毕业后入职杭州海康威视公司，工作了一年半左右的时间，主要参与了测温云平台项目，结合设备，使用微服务化架构，采用kafka处理大规模的设备事件数据，能快速定位发烧人员，为疫情出一份力，同时也为公司销售了大量测温设备。\n后续参与了云曜云平台项目，想要打造海康自己的阿里云平台，管理各种客户订单和信息的使用情况。")]),a._v(" "),n("p",[a._v("后续从杭州来到深圳，入职了蓝贝科技有限公司，是一家东南亚的科技零售创业公司，通过较好的学习和接受能力，快速熟悉公司的业务和代码，主要负责售卖机的充值流程开发和优化，以及使用Netty控制订单流程中售卖机掉货和 智能化的通过销量对售卖机的商品进行调换货的工作。")]),a._v(" "),n("p",[a._v("由于疫情的反复，导致经营不是很好，往新的方向尝试失败后导致解散。")]),a._v(" "),n("p",[a._v("目前在积极求职中。")]),a._v(" "),n("p",[a._v("同时喜欢空余时间看一些相关的技术书籍，MySQL是如何运行的，redis的设计与实现。")]),a._v(" "),n("h2",{attrs:{id:"面经"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#面经"}},[a._v("#")]),a._v(" 面经")])])}),[],!1,null,null,null);t.default=e.exports}}]);