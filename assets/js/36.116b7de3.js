(window.webpackJsonp=window.webpackJsonp||[]).push([[36],{529:function(v,_,a){"use strict";a.r(_);var t=a(4),r=Object(t.a)({},(function(){var v=this,_=v.$createElement,a=v._self._c||_;return a("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[a("h2",{attrs:{id:"jvm整体运行原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#jvm整体运行原理"}},[v._v("#")]),v._v(" JVM整体运行原理")]),v._v(" "),a("p",[v._v('首先将.java文件通过编译成.class文件，打成jar包。然后类加载器把".class"字节码文件中的类加载到JVM中。Jvm开始运行类中的代码。')]),v._v(" "),a("h2",{attrs:{id:"一个类从加载到使用的整体流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一个类从加载到使用的整体流程"}},[v._v("#")]),v._v(" 一个类从加载到使用的整体流程")]),v._v(" "),a("p",[v._v("主要经过以下流程：")]),v._v(" "),a("p",[v._v("加载 -> 验证 -> 准备 -> 解析 -> 初始化 -> 使用 -> 卸载")]),v._v(" "),a("ol",[a("li",[v._v("加载：")])]),v._v(" "),a("p",[v._v("当代码用到这个类的时候，才会把相关类加载到内存中。")]),v._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[v._v("验证：")])]),v._v(" "),a("p",[v._v("加载到内存之后，验证.class文件是否合法，以及是否被篡改。")]),v._v(" "),a("ol",{attrs:{start:"3"}},[a("li",[v._v("准备阶段：")])]),v._v(" "),a("p",[v._v("主要是分配内存空间。然后给里面的类变量(static 修饰的变量)分配内存空间，并设置一个初始值。")]),v._v(" "),a("ol",{attrs:{start:"4"}},[a("li",[v._v("解析阶段：")])]),v._v(" "),a("p",[v._v("把符号引用替换为直接引用。")]),v._v(" "),a("ol",{attrs:{start:"5"}},[a("li",[v._v("初始化：")])]),v._v(" "),a("p",[v._v("给变量根据代码对类变量进行赋值。且会优先初始化父类。")]),v._v(" "),a("ol",{attrs:{start:"6"}},[a("li",[v._v("类初始化后就可正常使用了。")])]),v._v(" "),a("h2",{attrs:{id:"类加载器和双亲委派机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#类加载器和双亲委派机制"}},[v._v("#")]),v._v(" 类加载器和双亲委派机制")]),v._v(" "),a("ol",[a("li",[v._v("类加载器")])]),v._v(" "),a("p",[v._v("a). Bootstrap ClassLoader, 启动类加载器，主要负责加载我们在机器上安装的Java目录下的核心类。lib文件下核心jar包")]),v._v(" "),a("p",[v._v("b). Extension ClassLoader, 扩展类加载器，主要加载lib\\ext目录下的类")]),v._v(" "),a("p",[v._v("c). Application ClassLoader，应用程序类加载器，主要负责去加载ClassPath环境变量所指定的路径中的类，即加载自己的代码。")]),v._v(" "),a("p",[v._v("d) 自定义类加载器。")]),v._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[v._v("双亲委派机制")])]),v._v(" "),a("p",[v._v("启动类加载器 -> 扩展类加载器 -> 应用程序类加载器 -> 自定义类加载器")]),v._v(" "),a("p",[v._v("应用程序类加载器需要加载一个类，首先委派给自己的父类去加载，最终传递到顶层的类加载器去加载。如果在父类的范围内没有找到这个类，才会让子类加载器去加载。")]),v._v(" "),a("h2",{attrs:{id:"什么是jvm的内存区域划分"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是jvm的内存区域划分"}},[v._v("#")]),v._v(" 什么是JVM的内存区域划分")]),v._v(" "),a("p",[v._v("JVM在运行代码时，必须使用多块内存空间，不同的内存空间存放不同的数据，来配合我们写的代码，让系统正常运行。")]),v._v(" "),a("p",[v._v("内存划分：")]),v._v(" "),a("ol",[a("li",[v._v("存放类的方法区")])]),v._v(" "),a("p",[v._v('1.8 以前：方法区：主要存放".class"文件里面加载进来的类，还会有一些类似常量池的东西放在这个区域里。')]),v._v(" "),a("p",[v._v('1.8 及之后：这块区域名字改了，叫做"Metaspace", 可以认为是"元数据空间"。存放我们自己写的各种类相关的信息。')]),v._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[v._v("执行代码指令用的程序计数器")])]),v._v(" "),a("p",[v._v("线程私有，用来记录当前执行的字节码指令的为止，记录目前执行到哪一行了。")]),v._v(" "),a("ol",{attrs:{start:"3"}},[a("li",[v._v("Java虚拟机栈")])]),v._v(" "),a("p",[v._v("线程私有，存放每个方法的局部变量等数据。执行一个方法后，就会对这个方法调用创建对应的一个栈帧。栈帧就有这个方法的局部变量表，操作数栈，动态链接，方法出口等东西。")]),v._v(" "),a("ol",{attrs:{start:"4"}},[a("li",[v._v("java堆内存")])]),v._v(" "),a("p",[v._v("存放代码中创建的各种对象的实例。")]),v._v(" "),a("ol",{attrs:{start:"5"}},[a("li",[v._v("其他内存区域")])]),v._v(" "),a("p",[v._v("本地方法栈，线程私有。")]),v._v(" "),a("h2",{attrs:{id:"一个方法执行完毕后会怎么样"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一个方法执行完毕后会怎么样"}},[v._v("#")]),v._v(" 一个方法执行完毕后会怎么样")]),v._v(" "),a("p",[v._v("会把相应方法从Java虚拟机栈中出栈。同时java堆内存的一些对象的引用也会减少。")]),v._v(" "),a("h2",{attrs:{id:"不再需要的那些对象应该怎么处理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#不再需要的那些对象应该怎么处理"}},[v._v("#")]),v._v(" 不再需要的那些对象应该怎么处理")]),v._v(" "),a("p",[v._v("Jvm的垃圾回收机制。")]),v._v(" "),a("p",[v._v("如果一个对象是不可达的，则java会在下一次垃圾回收时将其清除掉。")]),v._v(" "),a("h2",{attrs:{id:"对象会在java堆内存占用多少"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对象会在java堆内存占用多少"}},[v._v("#")]),v._v(" 对象会在Java堆内存占用多少")]),v._v(" "),a("p",[v._v("主要分为两块：")]),v._v(" "),a("ol",[a("li",[a("p",[v._v("一个是对象自己本身的一些信息。")])]),v._v(" "),a("li",[a("p",[v._v("一个是对象的实例变量作为数据占用的空间。")])])]),v._v(" "),a("p",[v._v("对象头，如果在64位的linux操作系统上，会占用16字节。其内部数据会根据数据类型进行占用。")]),v._v(" "),a("h2",{attrs:{id:"大部分对象都是存活周期极短的-少部分对象是长期存活的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#大部分对象都是存活周期极短的-少部分对象是长期存活的"}},[v._v("#")]),v._v(" 大部分对象都是存活周期极短的，少部分对象是长期存活的")]),v._v(" "),a("p",[v._v("java虚拟栈中的对象都是很快就完完的。所以其实例对象的引用也会很快消失。")]),v._v(" "),a("p",[v._v("少数对象运行时间长的对象才会长久存在。")]),v._v(" "),a("h2",{attrs:{id:"jvm分代模型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#jvm分代模型"}},[v._v("#")]),v._v(" JVM分代模型")]),v._v(" "),a("p",[v._v("年轻代和老年代。")]),v._v(" "),a("p",[v._v("Jvm将Java内存划分了两个区域，一个年轻代，一个老年代。")]),v._v(" "),a("p",[v._v("年轻代，创建和使用完立马就要回收的对象。")]),v._v(" "),a("p",[v._v("老年代。创建对象后需要长期存在的对象。")]),v._v(" "),a("h2",{attrs:{id:"为什么要分为年轻代和老年代"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么要分为年轻代和老年代"}},[v._v("#")]),v._v(" 为什么要分为年轻代和老年代")]),v._v(" "),a("p",[v._v("对于年轻代的对象，特点是创建之后很快就会被回收，所以需要用一种垃圾回收算法。")]),v._v(" "),a("p",[v._v("对于老年代的对象，需要长期存在，需要另一种垃圾回收算法，所以需要分为两个区域来放不同的对象。")]),v._v(" "),a("h2",{attrs:{id:"什么是永久待"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是永久待"}},[v._v("#")]),v._v(" 什么是永久待")]),v._v(" "),a("p",[v._v("方法区，存放一些类信息。不会进行垃圾回收。")]),v._v(" "),a("p",[v._v("在以下几种情况下，方法区的类会被回收：")]),v._v(" "),a("p",[v._v("a). 首先该类的所有实例对象都已经从Java堆内存里面被回收")]),v._v(" "),a("p",[v._v("b). 其次加载这个类的ClassLoader已经被回收")]),v._v(" "),a("p",[v._v("c). 最后，对该类的Class对象没有任何引用。")]),v._v(" "),a("h2",{attrs:{id:"一个新建对象的分配情况"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一个新建对象的分配情况"}},[v._v("#")]),v._v(" 一个新建对象的分配情况")]),v._v(" "),a("p",[v._v("大部分的正常对象，都是优先在新生代分配内存的。")]),v._v(" "),a("h2",{attrs:{id:"什么情况下会触发新生代的垃圾回收"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么情况下会触发新生代的垃圾回收"}},[v._v("#")]),v._v(" 什么情况下会触发新生代的垃圾回收")]),v._v(" "),a("p",[v._v("一般是在发现新生代内存空间不足，就会触发一次垃圾回收，然后把所有垃圾对象干掉，腾出大量的内存空间。而不是在一个方法执行完毕后，立刻将其中的局部变量释放掉。")]),v._v(" "),a("h2",{attrs:{id:"长期存活的对象会躲过多次垃圾回收"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#长期存活的对象会躲过多次垃圾回收"}},[v._v("#")]),v._v(" 长期存活的对象会躲过多次垃圾回收")]),v._v(" "),a("p",[v._v("如果一个实例对象在新生代，成功的在15次垃圾回收之后们还没有被回收掉，就说明15岁了。躲过10多次垃圾回收，就会认为是成年人，会被认定是长期存活在内存中的对象。会被转移到Java堆内存中去。同时还会有动态年龄判断。")]),v._v(" "),a("p",[v._v("且大对象直接进入老年代。")]),v._v(" "),a("h2",{attrs:{id:"老年代会垃圾回收嘛"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#老年代会垃圾回收嘛"}},[v._v("#")]),v._v(" 老年代会垃圾回收嘛")]),v._v(" "),a("p",[v._v("肯定会。")]),v._v(" "),a("h2",{attrs:{id:"如何设置jvm参数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何设置jvm参数"}},[v._v("#")]),v._v(" 如何设置jvm参数")]),v._v(" "),a("p",[v._v("-Xms: Java堆内存的大小")]),v._v(" "),a("p",[v._v("-Xmx: Java堆内存的最大大小")]),v._v(" "),a("p",[v._v("-Xmn: Java堆内存中的新生代大小，扣除新生代剩下的就是老年代的内存大小")]),v._v(" "),a("p",[v._v("-XX:PermSize: 永久代大小")]),v._v(" "),a("p",[v._v("-XX:MaxPermSize: 永久代最大大小")]),v._v(" "),a("p",[v._v("-XX:MetaspaceSize: 元空间的大小(1.8)")]),v._v(" "),a("p",[v._v("-XX:MaxMetaspaceSize: 元空间的最大大小(1.8)")]),v._v(" "),a("p",[v._v("-Xss: 每个线程的栈内存大小")]),v._v(" "),a("p",[v._v("-XX:PretenureSizeThreshold: 只要创建的一个对象大于这个值，就会把它直接放入老年代。")]),v._v(" "),a("p",[v._v("-XX:-HandlerPromotionFailure: GC时，老年代大小不满足新生代所有对象和时的参数")]),v._v(" "),a("p",[v._v("上面的参数=xxx 即可设置为在启动后的参数")]),v._v(" "),a("p",[v._v("每秒钟会对JVM占据多大内存空间，根据这个横向扩展预估整个整个系统每秒需要占据多大内存空间，接着根据这个数据模型推算出，在不同的机器配置之下，你的新生代大致会有多大的内存空间，然后在不同的新生代大小下，多久触发一次Minor GC.")]),v._v(" "),a("h2",{attrs:{id:"什么时候会触发垃圾回收"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么时候会触发垃圾回收"}},[v._v("#")]),v._v(" 什么时候会触发垃圾回收")]),v._v(" "),a("p",[v._v("如果新生代里(老年代)的对象越来越多，都快满了，就会触发垃圾回收，把新生代没人引用的对象回收掉，释放内存空间。")]),v._v(" "),a("h2",{attrs:{id:"那些变量引用的对象是不能回收的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#那些变量引用的对象是不能回收的"}},[v._v("#")]),v._v(" 那些变量引用的对象是不能回收的")]),v._v(" "),a("p",[v._v("如果堆内存中的实例有被GC Roots引用，则不会被回收。")]),v._v(" "),a("p",[v._v("只要这个对象被局部变量，类的静态变量给引用了，就不会回收。")]),v._v(" "),a("h2",{attrs:{id:"java中对象不同的引用类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#java中对象不同的引用类型"}},[v._v("#")]),v._v(" Java中对象不同的引用类型")]),v._v(" "),a("p",[v._v("强引用，软引用，弱引用和虚引用。")]),v._v(" "),a("p",[v._v("强引用： 常用new")]),v._v(" "),a("p",[v._v("软引用： 继承了 SoftReference的对象")]),v._v(" "),a("p",[v._v("弱引用：继承了 WeakReference的对象")]),v._v(" "),a("p",[v._v("虚引用：很少使用")]),v._v(" "),a("h2",{attrs:{id:"finalize-方法的作用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#finalize-方法的作用"}},[v._v("#")]),v._v(" finalize() 方法的作用")]),v._v(" "),a("p",[v._v("使用finaliza() 方法拯救自己，回收前会调用。")]),v._v(" "),a("h2",{attrs:{id:"回收算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#回收算法"}},[v._v("#")]),v._v(" 回收算法")]),v._v(" "),a("ol",[a("li",[v._v("复制算法")])]),v._v(" "),a("p",[v._v("把新生代的内分成两块。")]),v._v(" "),a("p",[v._v("将一块中的进行回收，然后将剩余的整理完成后放到另一块中。")]),v._v(" "),a("p",[v._v("优点：能快速除掉垃圾对象，并对存活的对象进行整理。")]),v._v(" "),a("p",[v._v("缺点：内存利用率不高。")]),v._v(" "),a("p",[v._v("优化：Eden区和Survivor区。 将新生代拆成一个Eden区和两个Survivor区，其中Eden区占80%的内存空间，每一块Survivor区各占10%内存空间。平常使用一块Survivor区和Eden区。存活对象存在Survivor区，Eden区主要来存放新来的对象。且根据动态对象年龄判断，如果年龄1 + 年龄2 + ... 年龄n对象存活下来，且占Survivor的1/2，则会将年龄大于等于n的全部放进老年区。如果一次GC完后在一个Survivor区存不下，也会直接放入老年代。")]),v._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[v._v("标记清除")])]),v._v(" "),a("p",[v._v("直接将垃圾对象给删除，但是会导致出现大量的内存碎片。")]),v._v(" "),a("ol",{attrs:{start:"3"}},[a("li",[v._v("标记清除整理。")])]),v._v(" "),a("p",[v._v("将垃圾对象删除，然后进行排序整理。")]),v._v(" "),a("h2",{attrs:{id:"老年代空间分配担保规则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#老年代空间分配担保规则"}},[v._v("#")]),v._v(" 老年代空间分配担保规则")]),v._v(" "),a("p",[v._v("在执行一个Minor GC之前，JVM会先检查以下老年代可用的内存空间。是否大于新生代所有对象的总大小。")]),v._v(" "),a("p",[v._v("如果老年代的内存大于新生代所有对象之和，那就可以直接GC。")]),v._v(" "),a("p",[v._v("如果小于，会判断 -XX:-HandlerPromotionFailure的参数是否设置，如果设置了，就会判断老年代的大小，是否大于之前每一次GC后进入老年代的对象的平均大小。如果判断失败，或者没有设置相关参数，直接执行Full GC。然后再Minor GC")]),v._v(" "),a("p",[v._v("如果后续仍不满足内存大小，则会OOM。")]),v._v(" "),a("h2",{attrs:{id:"老年代垃圾回收算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#老年代垃圾回收算法"}},[v._v("#")]),v._v(" 老年代垃圾回收算法")]),v._v(" "),a("p",[v._v("老年代的垃圾回收一般两种情况：")]),v._v(" "),a("ol",[a("li",[a("p",[v._v("Minor GC之前，发现可能Minor GC之后要进入老年代的对象太多，老年代放不下，要提前触发Full GC然后在带着进行Minor GC")])]),v._v(" "),a("li",[a("p",[v._v("Minor GC之后，剩余对象太多，老年代放不下。")])])]),v._v(" "),a("p",[v._v("老年代采用标记清理算法。")]),v._v(" "),a("p",[v._v("老年代垃圾回收算法的速度至少比新生代的垃圾回收算法的速度慢10倍。")]),v._v(" "),a("p",[v._v("如果系统频繁出现老年代的 Full GC垃圾回收，会导致系统性能被严重影响，出现频繁卡顿的情况。")]),v._v(" "),a("h2",{attrs:{id:"垃圾回收器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收器"}},[v._v("#")]),v._v(" 垃圾回收器")]),v._v(" "),a("ol",[a("li",[v._v("Serial 和 Serial Old 垃圾回收器")])]),v._v(" "),a("p",[v._v("分别用来回收新生代和老年代的垃圾对象。")]),v._v(" "),a("p",[v._v("工作原理：单线程运行，垃圾回收时会停止我们写的系统的其他工作线程，让哦我们系统直接卡死不动，然后进行垃圾回收。")]),v._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[v._v("ParNew 和 CMS垃圾回收器")])]),v._v(" "),a("p",[v._v("ParNew现在一般都会用在新生代的垃圾回收器，CMS是老年代的垃圾回收器。")]),v._v(" "),a("p",[v._v("工作原理：都是多线程并发的回收机制。")]),v._v(" "),a("ol",{attrs:{start:"3"}},[a("li",[v._v("G1垃圾回收器")])]),v._v(" "),a("p",[v._v("统一收集新生代和老年代，采用更加优秀的算法和设置机制。")]),v._v(" "),a("h2",{attrs:{id:"stop-the-world"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#stop-the-world"}},[v._v("#")]),v._v(" Stop the World")]),v._v(" "),a("p",[v._v("进行垃圾回收时，垃圾回收线程会使用时垃圾回收器执行垃圾回收算法进行回收。")]),v._v(" "),a("p",[v._v("而在垃圾回收过程中，系统程序如果还在不停的创建对象。就可能导致出现大量问题。")]),v._v(" "),a("p",[v._v("所以出现了Stop the World。尽可能让垃圾回收器专心工作，而不能随便让我们的Java系统继续进行新建对象了。")]),v._v(" "),a("p",[v._v("而此现象会导致系统停顿。所以无论是新生代GC 还是 老年代GC，尽量不要让频率过高，也避免持续时间过长，避免影响系统的正常运行。")]),v._v(" "),a("p",[v._v("不同的垃圾回收器的不同影响：")]),v._v(" "),a("p",[v._v("Serial垃圾回收器是一个线程，进行，速度慢。")]),v._v(" "),a("p",[v._v("ParNew是多线程的新生代垃圾回收器。支持多线程，提高回收效率。")]),v._v(" "),a("p",[v._v("CMS用在老年代的垃圾回收器，也是多线程并发的控制，性能更好，和ParNew是线上生产系统的标配组合。")]),v._v(" "),a("p",[v._v("G1垃圾回收器：统一收集新生代和老年代，采用了更加优秀的算法和设计机制。")]),v._v(" "),a("h2",{attrs:{id:"最常用的新生代垃圾回收器-parnew"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#最常用的新生代垃圾回收器-parnew"}},[v._v("#")]),v._v(" 最常用的新生代垃圾回收器————ParNew")]),v._v(" "),a("p",[v._v("ParNew垃圾回收器如果一旦在核实的时机执行Monior GC的时候，就会把系统程序的工作线程给停掉，禁止程序继续运行创建的对象，然后自己就用多个垃圾回收线程去进行垃圾回收。")]),v._v(" "),a("h2",{attrs:{id:"如何为线程的系统执行使用parnew垃圾回收器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何为线程的系统执行使用parnew垃圾回收器"}},[v._v("#")]),v._v(" 如何为线程的系统执行使用ParNew垃圾回收器")]),v._v(" "),a("p",[v._v("启动时加上参数 -XX:UseParNewGC选项。")]),v._v(" "),a("h2",{attrs:{id:"parnew垃圾回收器默认情况下的线程数量"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#parnew垃圾回收器默认情况下的线程数量"}},[v._v("#")]),v._v(" ParNew垃圾回收器默认情况下的线程数量")]),v._v(" "),a("p",[v._v("默认给自己设置的垃圾回收线程的数量就是跟CPU的核数是一样的。")]),v._v(" "),a("p",[v._v('可以使用 "-XX:ParallelGCThreads"参数进行线程数量的设置。')]),v._v(" "),a("h2",{attrs:{id:"cms垃圾回收的基本原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cms垃圾回收的基本原理"}},[v._v("#")]),v._v(" CMS垃圾回收的基本原理")]),v._v(" "),a("p",[v._v("一般老年代我们选择的垃圾回收器是CMS，采用的是标记清理算法。")]),v._v(" "),a("p",[v._v("CMS垃圾回收器采取的是垃圾回收线程和系统工作线程尽量同时执行的模式来处理的。")]),v._v(" "),a("h2",{attrs:{id:"cms如何实现系统一般工作的同时进行垃圾回收"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cms如何实现系统一般工作的同时进行垃圾回收"}},[v._v("#")]),v._v(" CMS如何实现系统一般工作的同时进行垃圾回收")]),v._v(" "),a("p",[v._v("CMS在执行一次垃圾回收器一共分为四个阶段")]),v._v(" "),a("ol",[a("li",[v._v("初始标记")])]),v._v(" "),a("p",[v._v("这个阶段会让系统的工作线程全部停止，进入Stop the World状态。标记出来所有GC Roots直接引用的对象。")]),v._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[v._v("并发标记")])]),v._v(" "),a("p",[v._v("这个阶段会让系统线程可以随意创建各种新的对象，继续运行，在运行期间可能会创建新的存活对象，也可能会让部分存活对象失去引用，变成垃圾对象。在这个过程中，垃圾回收线程，会尽可能的对已有的对象进行GC roots追踪。")]),v._v(" "),a("p",[v._v("耗时较长。")]),v._v(" "),a("p",[v._v("需要追踪所有对象是否从根源上被GC roots引用了，但是这个最耗时的阶段，是跟系统程序并发运行的，所以不会对系统曹诚影响。")]),v._v(" "),a("ol",{attrs:{start:"3"}},[a("li",[v._v("重新标记")])]),v._v(" "),a("p",[v._v("继续让程序停下来，再次进入 Stop the World阶段，重新标记下在第二阶段里面创建的一些对象，还有一些已有对象可能失去引用变成垃圾的对象。速度较快")]),v._v(" "),a("ol",{attrs:{start:"4"}},[a("li",[v._v("并发清理")])]),v._v(" "),a("p",[v._v("这个阶段让系统程序随意运行，然后来清理之前标记为垃圾的对象。")]),v._v(" "),a("p",[v._v("相对耗时较长。")]),v._v(" "),a("h2",{attrs:{id:"对cms的垃圾回收机制进行性能分析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对cms的垃圾回收机制进行性能分析"}},[v._v("#")]),v._v(" 对CMS的垃圾回收机制进行性能分析")]),v._v(" "),a("p",[v._v("最耗时的为 老年代全部对相关进行GC Roots追踪，标记出来到底哪些可以回收，然后就是对各种垃圾对象从内存清理掉。即为并发标记和并发清理两个部分。")]),v._v(" "),a("p",[v._v("但是这两个阶段，都是和系统程序并发执行的。")]),v._v(" "),a("p",[v._v('而第一阶段和第三阶段是需要"Stop the World"的，只是进行简单标记，速度非常快。')]),v._v(" "),a("h2",{attrs:{id:"并发回收垃圾导致cpu资源紧张"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#并发回收垃圾导致cpu资源紧张"}},[v._v("#")]),v._v(" 并发回收垃圾导致CPU资源紧张")]),v._v(" "),a("p",[v._v("CMS垃圾回收器有一个最大的问题，虽然能在垃圾回收的同时让系统同时工作，但是并发标记和并发清理两个最耗时的阶段，垃圾回收线程和系统工作线程同时工作，会导致有限的CPU资源被垃圾回收线程占用一部分。")]),v._v(" "),a("p",[v._v("所以在这两个阶段，CMS的垃圾回收线程是比较耗费CPU资源的。CMS默认启动的垃圾回收线程的数量是(CPU核数 + 3)/4.")]),v._v(" "),a("p",[v._v("CMS这个并发垃圾回收的机制，第一个问题就会使消耗CPU资源。")]),v._v(" "),a("h2",{attrs:{id:"concurrent-mode-failure问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#concurrent-mode-failure问题"}},[v._v("#")]),v._v(" Concurrent Mode Failure问题")]),v._v(" "),a("p",[v._v("在并发清理阶段，CMS只会回收之前标记好的垃圾对象。")]),v._v(" "),a("p",[v._v('这个阶段系统一直运行，随着系统让一些对象进入老年代，同时还变成垃圾对象，这种垃圾对象是"浮动垃圾"。')]),v._v(" "),a("p",[v._v("CMS来及回收的触发时机，其中有一个就是当老年代内存占用达到一定比例是，就会自动执行GC.")]),v._v(" "),a("p",[v._v('"-XX:CMSInitiatingOccupancyFaction"参数可以用来设置老年代占用多少比例的时候触发CMS垃圾回收，JDK1.6默认为92%')]),v._v(" "),a("p",[v._v("如果CMS垃圾回收期间，系统程序要放入老年代的对象大于了可用内存空间，此时会如何。")]),v._v(" "),a("p",[v._v("这个时候就会发生Concurrent Mode Failure. 就是说并发垃圾回收失败了，我一边回收，一边把对象放入老年代，内存不够用了。")]),v._v(" "),a("p",[v._v('此时系统会自动用"Serial Old"垃圾回收器代替CMS，直接强行把系统程序"Stop the World", 重新进行长时间的GC Roots追踪，标记出来全部垃圾对象，不允许新的对象产生。')]),v._v(" "),a("h2",{attrs:{id:"内存碎片问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#内存碎片问题"}},[v._v("#")]),v._v(" 内存碎片问题")]),v._v(" "),a("p",[v._v("CMS使用的是标记清理算法，会导致出现大量的内存碎片。内存碎片太多，会导致后续对象进入老年代找不到可用的连续内存空间了，然后触发Full GC。")]),v._v(" "),a("p",[v._v("所以CMS不是完全就仅仅用标记清理算法的，因为太多的内存碎片实际上会导致更加频繁的Full GC。")]),v._v(" "),a("p",[v._v('CMS有一个参数是"-XX:+UseCMSCompactAtFullCollection", 默认为打开的。他的意思是在Full GC之后再次进行"Stop ther World",停止工作线程，然后进行碎片整理，把存活的对象挪到一起，空出来大片连续内存空间，避免内存碎片。')]),v._v(" "),a("p",[v._v('还有一个参数"-XX:CMSFullGCsBeforeCompaction", 执行多少次Full GC之后再执行一次碎片整理工作，默认是0.')]),v._v(" "),a("h2",{attrs:{id:"新生代垃圾回收优化之一-survivor空间够不够"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#新生代垃圾回收优化之一-survivor空间够不够"}},[v._v("#")]),v._v(" 新生代垃圾回收优化之一：Survivor空间够不够")]),v._v(" "),a("p",[v._v("Survivor空间不够会导致，GC完后对象直接进入老年代。")]),v._v(" "),a("p",[v._v("要调整新生代和老年代的大小。")]),v._v(" "),a("h2",{attrs:{id:"parnew-cms的组合让我们有哪些痛点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#parnew-cms的组合让我们有哪些痛点"}},[v._v("#")]),v._v(" ParNew + CMS的组合让我们有哪些痛点")]),v._v(" "),a("ol",[a("li",[a("p",[v._v("Stop the World")])]),v._v(" "),a("li",[a("p",[v._v("Concurrent Mode Failure")])])]),v._v(" "),a("h2",{attrs:{id:"g1-垃圾回收器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#g1-垃圾回收器"}},[v._v("#")]),v._v(" G1 垃圾回收器")]),v._v(" "),a("p",[v._v("G1垃圾回收器是可以同时回收新生代和老年代的对象的，不需要两个垃圾回收器配合起来运作。")]),v._v(" "),a("p",[v._v("特点：将Java堆内存拆分为多个大小相等的Region。可以让我们设置一个垃圾回收的预期停顿时间。")]),v._v(" "),a("ol",[a("li",[a("p",[v._v("新生代包含了某些Region， 老年代包含了某些Region。")])]),v._v(" "),a("li",[a("p",[v._v("可以设置G1垃圾回收导致的Stop the World时间，不超过多少秒。")])])]),v._v(" "),a("h2",{attrs:{id:"g1是如何做到堆垃圾回收导致的系统停顿是可控的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#g1是如何做到堆垃圾回收导致的系统停顿是可控的"}},[v._v("#")]),v._v(" G1是如何做到堆垃圾回收导致的系统停顿是可控的")]),v._v(" "),a("p",[v._v("G1垃圾回收器追踪了每个Region里的回收价值。即需要清楚每个Region里的对象有多少是垃圾，如果对这个Region进行垃圾回收，需要耗费多长时间，可以回收掉多少垃圾。")]),v._v(" "),a("p",[v._v("G1通过把内存拆分为大量小Region，以及追踪每个Region中可以回收的对象大小的预估时间，最后在垃圾回收的时候，尽量把垃圾回收对系统造成的影响控制在指定的时间范围内，同时在有限的时间内尽量回收尽可能多的垃圾对象。")]),v._v(" "),a("h2",{attrs:{id:"如何设定g1对应的内存大小"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何设定g1对应的内存大小"}},[v._v("#")]),v._v(" 如何设定G1对应的内存大小")]),v._v(" "),a("p",[v._v('有多少个Region和每个Region的大小多大是通过自动计算和设置的。我们可以给整个堆内存设置一个大小，比如说用"-Xms"和"-Xmx"来设置堆内存的大小。')]),v._v(" "),a("p",[v._v('然后JVM启动的时候一旦发现你使用的G1垃圾回收器，可以使用"-XX:UseG1GC"来指定G1垃圾回收器，此时会自动用堆大小除以2048. JVM最多可以有2048个Region，然后Region的大小必须是2的倍数。比如说1MB，2MB，4MB之类的。')]),v._v(" "),a("p",[v._v("比如堆大小为4G，4096MB, /2048, 每个Region的大小就是2MB。大概就是这样子来决定Region的数量和大小的。")]),v._v(" "),a("p",[v._v('同时可以使用"-XX:G1HeapRegionSize"来指定每个Region的大小。')]),v._v(" "),a("p",[v._v('刚开始的时候，默认新生代对堆内存的占比是5%,也就是占据200MB左右的内存，对应大概100个Region。同时可以通过"-XX:G1NewSizePercent"来设置新生代初始占比的。')]),v._v(" "),a("p",[v._v('Jvm会不停的给新生代增加更多的Region，但是最多新生代的占比不会超过60%, 可以通过"-XX:G1MaxNewSizePercent".')]),v._v(" "),a("p",[v._v("一旦Region进行垃圾回收，新生代的Region数量还会减少。")]),v._v(" "),a("h2",{attrs:{id:"g1中的新生代还有eden和survivor的概念嘛"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#g1中的新生代还有eden和survivor的概念嘛"}},[v._v("#")]),v._v(" G1中的新生代还有Eden和Survivor的概念嘛")]),v._v(" "),a("p",[v._v('有。 "-XX:SurvivorRatio=8",可以区分出来新生代的Region有哪些属于Eden，哪些属于Survivor。')]),v._v(" "),a("h2",{attrs:{id:"g1新生代垃圾回收"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#g1新生代垃圾回收"}},[v._v("#")]),v._v(" G1新生代垃圾回收")]),v._v(" "),a("p",[v._v("随着不停的在新生代的Eden对应的Region中放对象，JVM就会不停的给新生代加入更多的Region，知道新生代占据堆大小的最大比例60%. 一旦新生代达到了设定的占据堆内存的最大大小60%， 就会触发新生代的GC。")]),v._v(" "),a("h2",{attrs:{id:"g1垃圾回收机制-对象什么时候进入老年代"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#g1垃圾回收机制-对象什么时候进入老年代"}},[v._v("#")]),v._v(" G1垃圾回收机制，对象什么时候进入老年代")]),v._v(" "),a("p",[v._v("在G1的内存模型下，新生代和老年代各自会占据一定的Region，老年代会有自己的Region。")]),v._v(" "),a("p",[v._v("按照默认新生代最多只能占据内存60%的Region来推算，老年代最多可以占据40%的Region，大概800个左右的Region。")]),v._v(" "),a("ol",[a("li",[a("p",[v._v('对象在是新生代躲过很多次的垃圾回收，达到了一定的年龄，就会进入老年代。可通过"-XX:MaxTenuringThreshold"参数设置这个年龄。')])]),v._v(" "),a("li",[a("p",[v._v("动态年龄判断规则，如果一旦发现某次存活对象超过了Survivor的50%。")])])]),v._v(" "),a("h2",{attrs:{id:"g1中大对象region"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#g1中大对象region"}},[v._v("#")]),v._v(" G1中大对象Region")]),v._v(" "),a("p",[v._v("G1提供了专门的Region来存放大对象，而不是让大对象进入老年代的Region中。")]),v._v(" "),a("p",[v._v("如果一个大对象超过了一个Region大小的50%,就会放入大对象Region中。")]),v._v(" "),a("p",[v._v("进行垃圾回收时，会带着大对象的Region一起进行回收。")]),v._v(" "),a("h2",{attrs:{id:"g1什么时候触发新生代-老年代的混合垃圾回收"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#g1什么时候触发新生代-老年代的混合垃圾回收"}},[v._v("#")]),v._v(" G1什么时候触发新生代+老年代的混合垃圾回收")]),v._v(" "),a("p",[v._v('G1有一个参数，是"-XX:InititingHeapOccupancyPercent", 默认是45%')]),v._v(" "),a("p",[v._v("如果老年代占据了堆内存的45%的Region的时候，会尝试触发一个新生代+老年代一起回收的混合回收阶段。")]),v._v(" "),a("h2",{attrs:{id:"g1垃圾回收的过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#g1垃圾回收的过程"}},[v._v("#")]),v._v(" G1垃圾回收的过程")]),v._v(" "),a("p",[v._v('首先会触发一个初始标记，这个过程是需要进入"Stop the world"的，仅仅标记GC Roots直接能引用的对象，这个过程速度是很快的。')]),v._v(" "),a("p",[v._v("接着进入并发标记，这个阶段允许系统程序的运行，同时进行GC Roots追踪，从GC Roots开始追踪所有的存活对象。耗时时间较长。")]),v._v(" "),a("p",[v._v('接着进入最终标记阶段，这个阶段会进入"Stop the World"，系统程序是禁止运行的，但是会根据并发标记阶段记录那些对象修改，最终标记一下哪些存活对象，有哪些是垃圾对象。')]),v._v(" "),a("p",[v._v("最后一个阶段是混合回收阶段，这个阶段会计算老年代每个Region中存活对象数量，存活对象的占比，还有执行垃圾回收的预期性和效率。")]),v._v(" "),a("p",[v._v("接着会停止系统程序，然后全力以赴进行垃圾回收，此时会选择部分Region进行回收，因为必须让垃圾回收的停顿时间控制在指定范围内。")]),v._v(" "),a("h2",{attrs:{id:"g1的部分参数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#g1的部分参数"}},[v._v("#")]),v._v(" G1的部分参数")]),v._v(" "),a("p",[v._v('"-XX:G1MixedGCCountTarget"参数，就是在一次混合回收的过程中，最后一个阶段执行几次混合回收。默认8次。')]),v._v(" "),a("p",[v._v('"-XX:G1HeapWastePercent",默认值是5%, 在混合回收的时候，对Region回收都是基于复制算法进行的，都是把要回收的Region里的存活对象放入其他Region，然后这个Region中的垃圾对象全部清理掉。一旦空闲出来的Region达到堆内存的5%,就会立即停止混合回收。')]),v._v(" "),a("p",[v._v('"-XX:G1MixedGCLiveThresholdPercent"，默认值为85%,意思就是确认要回收的Region的时候，必须是存活对象低于85%的Region才可以进行回收。')]),v._v(" "),a("h2",{attrs:{id:"g1回收失败时的full-gc"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#g1回收失败时的full-gc"}},[v._v("#")]),v._v(" G1回收失败时的Full GC")]),v._v(" "),a("p",[v._v("进行Mixed回收的时候，无论是年轻代还是老年代都是基于复制算法进行回收，都要把各个Region的存活对象拷贝到别的Region里面。此时万一出现拷贝的过程中发现没有空闲Region可以承载自己的存活对象了，就会触发一次失败，一旦失败，里面就会切换为停止系统程序，然后采用单线程进行标记，清理和压缩整理。空闲出来一批Region，这个过程是极慢极慢的。")]),v._v(" "),a("h2",{attrs:{id:"minor-gc-young-gc"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#minor-gc-young-gc"}},[v._v("#")]),v._v(" Minor GC/ Young GC")]),v._v(" "),a("p",[v._v("新生代，也成为年轻代，年轻代中的Eden内存区域被占满之后，实际上就需要触发年轻代gc。")]),v._v(" "),a("h2",{attrs:{id:"full-gc-old-gc"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#full-gc-old-gc"}},[v._v("#")]),v._v(" Full GC? Old GC?")]),v._v(" "),a("p",[v._v("老年代一旦被占满之后，就会触发老年代的gc，之前称呼这种GC为Full GC. Old GC更适合成为老年代GC.")]),v._v(" "),a("p",[v._v("Full GC，指的是针对新生代，老年代，永久代的全体内存空间的垃圾回收，称之为Full GC。")]),v._v(" "),a("h2",{attrs:{id:"major-gc"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#major-gc"}},[v._v("#")]),v._v(" Major GC")]),v._v(" "),a("p",[v._v("是一个让人混淆的概念")]),v._v(" "),a("h2",{attrs:{id:"mixed-gc"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mixed-gc"}},[v._v("#")]),v._v(" Mixed GC")]),v._v(" "),a("p",[v._v("Mixed GC是G1中特有的概率，对老年代和年轻代都进行回收。")]),v._v(" "),a("h2",{attrs:{id:"永久代满了怎么办"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#永久代满了怎么办"}},[v._v("#")]),v._v(" 永久代满了怎么办")]),v._v(" "),a("p",[v._v("满了会进行回收，但是一般回收会很少，仍不够的时候会抛出内存不够的异常了。")]),v._v(" "),a("h2",{attrs:{id:"如何打印jvm-gc日志"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何打印jvm-gc日志"}},[v._v("#")]),v._v(" 如何打印JVM GC日志")]),v._v(" "),a("p",[v._v("-XX:+PrintGCDetails: 打印详细的gc日志")]),v._v(" "),a("p",[v._v("-XX:+PrintGCTimeStamps: 这个参数可以打印出来每次GC发生的时间")]),v._v(" "),a("p",[v._v("-Xloggc:gc.log: 这个参数可以设置将gc日志写入一个磁盘文件")]),v._v(" "),a("h2",{attrs:{id:"程序运行采用的默认jvm参数如何查看"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#程序运行采用的默认jvm参数如何查看"}},[v._v("#")]),v._v(" 程序运行采用的默认JVM参数如何查看")]),v._v(" "),a("p",[v._v("在GC日志中，可以看到如下内容：")]),v._v(" "),a("p",[v._v("CommandLine flags: -XX:InitialHeapSize=10485760 -XX:MaxHeapSize=10485760 -XX:MaxNewSize=5242880")]),v._v(" "),a("p",[v._v("这说明这次运行程序采用的JVM参数是什么，基本都是我们设置的，同时还有一些参数默认就给设置了。")]),v._v(" "),a("p",[v._v("接着我们看到GC日志如下信息：")]),v._v(" "),a("p",[v._v("0.268: [GC (Allocation Failure) 0.269: [ParNew: 4030K -> 512K(4608K), 0.0015734 secs]] 4030K -> 574K(9728K), 0.0017518 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]")]),v._v(" "),a("p",[v._v("GC (Allocation Failure),为啥发生GC, 表示Eden区内存不够了，即对象分配失败。")]),v._v(" "),a("p",[v._v("0.268 你的系统运行了多少秒后发生了本次GC,这即为200ms")]),v._v(" "),a("p",[v._v("ParNew: 4030K -> 512K(4608K), 0.0015734 secs。 这个ParNew的意思，就是使用的垃圾回收器。\n4030K -> 512K(4608K)，代表年轻代可用空间是4608KB，也就是4.5MB，然后执行了一次GC后，只有512KB的对象存活了下来。0.0015734 secs，这个就是本次gc耗费的时间，大概是1.5ms，仅仅回收了3MB对象。")]),v._v(" "),a("p",[v._v("4030K -> 574K(9728K), 0.0017518 secs指整个java堆内存的情况。")]),v._v(" "),a("p",[v._v("Heap")]),v._v(" "),a("p",[v._v("....")]),v._v(" "),a("p",[v._v("相关信息是JVM退出的时候打印出来的当前堆内存的使用情况。")]),v._v(" "),a("h2",{attrs:{id:"jstat功能"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#jstat功能"}},[v._v("#")]),v._v(" jstat功能")]),v._v(" "),a("p",[v._v("可以轻易让我们看到当前运行中的系统，他的JVM内的Eden，Survivor，老年代的内存使用情况，还有Young GC和FULL GC的执行次数以及耗时。")]),v._v(" "),a("ol",[a("li",[v._v("jstat -gc PID")])]),v._v(" "),a("p",[v._v("jps可以看到运行的java进程的PID")]),v._v(" "),a("p",[v._v("可以看到java 进程的内存和GC情况。")]),v._v(" "),a("p",[v._v("S0C: 这是From Survivor区的大小")]),v._v(" "),a("p",[v._v("S1C: 这是To Survivor区的大小")]),v._v(" "),a("p",[v._v("S0U: 这是From Survivor区当前使用的内存大小")]),v._v(" "),a("p",[v._v("S1U: 这是To Survivor区当前使用的内存大小")]),v._v(" "),a("p",[v._v("EC: 这是Eden区的大小")]),v._v(" "),a("p",[v._v("EU: 这是Eden区当前使用的内存大小")]),v._v(" "),a("p",[v._v("OC: 这是老年代的大小")]),v._v(" "),a("p",[v._v("OU: 这是老年代当前使用的内存大小")]),v._v(" "),a("p",[v._v("MC: 这是方法区(永久代，元数据库区)的大小")]),v._v(" "),a("p",[v._v("MU: 这是方法区(永久代，元数据库区)的当前使用的内存大小")]),v._v(" "),a("p",[v._v("YGC: 这是系统运行迄今为止的Young GC次数")]),v._v(" "),a("p",[v._v("YGCT: 这是Young GC的耗时")]),v._v(" "),a("p",[v._v("FGC: 这是系统运行迄今为止的Full GC次数")]),v._v(" "),a("p",[v._v("FGCT: 这是Full GC的耗时")]),v._v(" "),a("p",[v._v("GCT: 这是所有GC的总耗时")]),v._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[a("p",[v._v("jstat -gccapacity PID : 堆内存分析")])]),v._v(" "),a("li",[a("p",[v._v("jstat -gcnew PID: 年轻代GC分析，这里的TT和MTT可以看到对象在年轻代存活的年龄和存活的最大年龄")])]),v._v(" "),a("li",[a("p",[v._v("jstat -gcnewcapacity PID ： 年轻代内存分析")])]),v._v(" "),a("li",[a("p",[v._v("jstat -gcold PID ：老年代GC分析")])]),v._v(" "),a("li",[a("p",[v._v("jstat -gcoldcapacity PID : 老年代内存分析")])]),v._v(" "),a("li",[a("p",[v._v("jstat -gcmetacapacity PID: 元数据区内存分析")])])]),v._v(" "),a("p",[v._v("主要用于看 新生代对象增长的速率，Young GC的触发频率， Young GC的耗时， 每次Young GC后有多少对象是存活下来的，每次Young GC过后有多少对象进入了老年代，老年代对象增加的速率，Full GC的触发频率，Full GC的耗时。")]),v._v(" "),a("h2",{attrs:{id:"jmap了解系统运行时的内存区域"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#jmap了解系统运行时的内存区域"}},[v._v("#")]),v._v(" jmap了解系统运行时的内存区域")]),v._v(" "),a("p",[v._v("想要查看到底什么对象占据了那么多的内存。")]),v._v(" "),a("p",[v._v("如果发现有对象在代码中可以优化创建的时机，避免那种对象对内存占用过大，甚至可以返回来优化一下代码。")]),v._v(" "),a("ol",[a("li",[v._v("jmap -head PID")])]),v._v(" "),a("p",[v._v("可以查看Eden区总容量，剩余的空间容量，两个Survivor区的总容量，已经使用的容量和剩余的空间容量，老年代的总容量，和剩余的容量。")]),v._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[v._v("jmap -histo PID")])]),v._v(" "),a("p",[v._v("可以按照各种对象占用内存空间的大小降序排列，把占用内存最多的对象放在最上面。")]),v._v(" "),a("ol",{attrs:{start:"3"}},[a("li",[v._v("jmap -dump:live,format=b,file=dump.hprof PID")])]),v._v(" "),a("p",[v._v("在当前目录下生一个dump.hrpof二进制文件，记录某一时刻JVM堆内存里面所有对象的快照放到文件里面。")]),v._v(" "),a("h2",{attrs:{id:"使用jhat在浏览器中分析堆转出快照"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用jhat在浏览器中分析堆转出快照"}},[v._v("#")]),v._v(" 使用jhat在浏览器中分析堆转出快照")]),v._v(" "),a("p",[v._v("jhat -port 7000 dump.hprof. 可以通过图形化的方式区分析堆内存里的对象分配情况。")]),v._v(" "),a("h2",{attrs:{id:"oom时自动生成快照"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#oom时自动生成快照"}},[v._v("#")]),v._v(" OOM时自动生成快照")]),v._v(" "),a("p",[v._v("-XX:+HeapDumpOnOutOfMemoryError")]),v._v(" "),a("p",[v._v("-XX:HeapDumpPath=/usr/local/app/oom")])])}),[],!1,null,null,null);_.default=r.exports}}]);