(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{532:function(t,e,v){"use strict";v.r(e);var a=v(4),_=Object(a.a)({},(function(){var t=this,e=t.$createElement,v=t._self._c||e;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h2",{attrs:{id:"介绍"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#介绍"}},[t._v("#")]),t._v(" 介绍")]),t._v(" "),v("p",[t._v("Netty是Java的卓越框架，驾驭了Java高级API的能力，并将其隐藏在一个易于使用的API之后。Netty使你可以专注于自己真正感兴趣的————你的应用程序的独一无二的价值。")]),t._v(" "),v("h3",{attrs:{id:"netty特性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#netty特性"}},[t._v("#")]),t._v(" netty特性")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",{staticStyle:{"text-align":"center"}},[t._v("分类")]),t._v(" "),v("th",{staticStyle:{"text-align":"center"}},[t._v("Netty的特性")])])]),t._v(" "),v("tbody",[v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("设计")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("统一的API,支持多种传输类型，阻塞和非阻塞的。简单而强大的线程模型。真正的无连接数据包套接字支持。链接逻辑组件一支持复用")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("易于使用")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("详实的javadoc和大量的示例集")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("性能")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("拥有比java的核心api更高的吞吐量以及更低的延迟。得益于池化和复用，拥有更低的资源消耗；最少的内存复制")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("健壮性")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("不会因为慢速，快速或者超载而连接导致OOM。消除在高速网络中NIO应用程序常见的不公平读/写比率")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("安全性")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("完整的SSL/TLS以及startTLS支持。可用于受限环境下，如Applet和OSGI")])])])]),t._v(" "),v("h3",{attrs:{id:"核心组件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#核心组件"}},[t._v("#")]),t._v(" 核心组件")]),t._v(" "),v("ol",[v("li",[t._v("Channel")])]),t._v(" "),v("p",[t._v("channel使java NIO的一个基本构造。")]),t._v(" "),v("p",[t._v("代表一个实体(如一个硬件设备，一个文件，一个网络套接字或者一个能够执行一个或者多个不同的I/O操作的程序组件)的开放连接，如读操作和写操作。")]),t._v(" "),v("p",[t._v("可以把Channel看作是传入(入站)或者传出(出战)数据的载体。因此，它可以被打开或者被关闭，连接或者断开连接。")]),t._v(" "),v("ol",{attrs:{start:"2"}},[v("li",[t._v("回调")])]),t._v(" "),v("p",[t._v("一个回调其实就是一个方法，一个指向已经被提供给另一个方法的方法的引用。这使得后者可以在适当的时候调用前者。")]),t._v(" "),v("p",[t._v("Netty在内部使用了回调来处理；当一个回调被触发时，相关的事件可以被一个interface-ChannelHandler的实现处理。")]),t._v(" "),v("ol",{attrs:{start:"3"}},[v("li",[t._v("Future")])]),t._v(" "),v("p",[t._v("Future提供了另一种在操作完成时通知应用程序的方式。这个对象可以看作是一个异步操作的结果的占位符：它将在未来的某个时刻完成，并提供对其结果的访问。")]),t._v(" "),v("p",[t._v("Netty提供了ChannelFuture，用于在执行异步操作的时候使用。")]),t._v(" "),v("p",[t._v("ChannelFuture提供了几种额外的方法，使得我们能够注册一个或者多个ChannelFutrueListener实例。监听器的回调方法operationComplete(), 将会在对应的操作完成时被调用，然后监听器可以判断该操作是成功完成了还是出错了。如果是后者，我们可以检索产生的Throwable。由ChannelFutureListener提供的通知机制消除了手动检查对应的操作是否完成的必要。")]),t._v(" "),v("p",[t._v("每个Netty的出战I/O操作都将返回一个ChannelFuture。即它们都不会被阻塞。netty完全是异步和事件驱动的。")]),t._v(" "),v("ol",{attrs:{start:"4"}},[v("li",[t._v("事件和ChannelHandler")])]),t._v(" "),v("p",[t._v("Netty使用不同的事件来通知我们状态的改变或者是操作的状态。这使得我们能够基于已经发生的事情来出发适当的动作。这些动作可能是：")]),t._v(" "),v("p",[t._v("a). 记录日志")]),t._v(" "),v("p",[t._v("b). 数据转换")]),t._v(" "),v("p",[t._v("c). 流控制")]),t._v(" "),v("p",[t._v("d). 应用程序逻辑")]),t._v(" "),v("p",[t._v("Netty是一个网络编程框架，所以事件是按照它们与入站或出战数据流的相关性进行分类的。可能由入站数据或者相关的状态更改而触发的事件包括：")]),t._v(" "),v("p",[t._v("a). 连接已被激活或者连接失活。")]),t._v(" "),v("p",[t._v("b). 数据读取")]),t._v(" "),v("p",[t._v("c). 用户事件")]),t._v(" "),v("p",[t._v("d). 错误事件。")]),t._v(" "),v("p",[t._v("出战事件是未来将会触发的某个动作的操作结果，这些动作包括：")]),t._v(" "),v("p",[t._v("a). 打开或者关闭到远程节点的连接")]),t._v(" "),v("p",[t._v("b). 将数据写入到或者冲刷到套接字。")]),t._v(" "),v("p",[t._v("ChannelHandler为处理器提供了基本的抽象。会在适当的时候对ChannelHandler进行更多的说明，目前你可以认为每个ChannelHandler的实例都类似一种为了响应特定事件而被执行的回调。")]),t._v(" "),v("h3",{attrs:{id:"把它们放在一起"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#把它们放在一起"}},[t._v("#")]),t._v(" 把它们放在一起")]),t._v(" "),v("ol",[v("li",[t._v("Future，回调和ChannelHandler")])]),t._v(" "),v("p",[t._v("Netty的异步编程模型是建立在Future和回调的基础上，而将事件派发到ChannelHandler的方法则发生在更深的层次上。结合在一起，提供了一个处理环境，使你的应用程序逻辑可以独立于任何网络操作相关的顾虑而独立的演变。")]),t._v(" "),v("ol",{attrs:{start:"2"}},[v("li",[t._v("选择器，事件和EventLoop")])]),t._v(" "),v("p",[t._v("Netty通过触发事件将Selector从应用程序抽象出来，消除了所有本将需要手动编写的派发代码。在内部将为每个Channel分配一个EventLoop，用以处理所有事件，包括：")]),t._v(" "),v("p",[t._v("a). 注册感兴趣的事件")]),t._v(" "),v("p",[t._v("b). 将事件派发给ChannelHandler")]),t._v(" "),v("p",[t._v("c). 安排进一步的动作")]),t._v(" "),v("p",[t._v("EventLoop本身只由一个线程驱动，其处理了一个Channel的所有I/O事件，并且在该EventLoop的整个生命周期内不会发生改变。")])])}),[],!1,null,null,null);e.default=_.exports}}]);