(window.webpackJsonp=window.webpackJsonp||[]).push([[42],{534:function(e,a,n){"use strict";n.r(a);var t=n(4),s=Object(t.a)({},(function(){var e=this,a=e.$createElement,n=e._self._c||a;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h2",{attrs:{id:"spring-创建对象流程"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#spring-创建对象流程"}},[e._v("#")]),e._v(" spring 创建对象流程")]),e._v(" "),n("p",[e._v("主要方法 AbstractApplicationContext#refresh()")]),e._v(" "),n("h3",{attrs:{id:"主要步骤"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#主要步骤"}},[e._v("#")]),e._v(" 主要步骤")]),e._v(" "),n("ol",[n("li",[e._v("prepareRefresh()")])]),e._v(" "),n("p",[e._v("主要作用：Prepare this context for refreshing. 为刷新准备上下文内容，预处理。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("a). initPropertySources() 实现内容为空，用户可根据需要自动实现初始化一些属性设置;子类自定义个性化的属性设置方法；\n\nb). getEnvironment().validateRequiredProperties(); 检验属性的合法等\n\nc). earlyApplicationEvents= new LinkedHashSet<ApplicationEvent>();保存容器中的一些早期的事件；\n")])])]),n("ol",{attrs:{start:"2"}},[n("li",[e._v("obtainFreshBeanFactory()")])]),e._v(" "),n("p",[e._v("主要作用：Tell the subclass to refresh the internal bean factory. 告诉子类刷新内部bean工厂。 获取BeanFactory；")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("a). DefaultListableBeanFactory beanFactory = createBeanFactory(); 创建一个默认工厂。并设置id。\n\nb). 并将这个beanFactory进行返回。\n")])])]),n("ol",{attrs:{start:"3"}},[n("li",[e._v("prepareBeanFactory(beanFactory)")])]),e._v(" "),n("p",[e._v("主要作用： Prepare the bean factory for use in this context. 准备bean工厂，以便在此上下文中使用。BeanFactory的预准备工作（BeanFactory进行一些设置）")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("a). 设置类的一些基础属性：类加载器，表达式解析器，属性编辑器等。\n\nb). 添加部分BeanPostProcessor【ApplicationContextAwareProcessor】 后置处理器\n\nc). 设置忽略的自动装配的接口EnvironmentAware、EmbeddedValueResolverAware、xxx；\n\nd). 满足条件下会增加 LoadTimeWeaverAwareProcessor 的后置处理器\n\ne). 给BeanFactory中注册一些能用的组件；environment【ConfigurableEnvironment】、systemProperties【Map<String, Object>】、systemEnvironment【Map<String, Object>】\n")])])]),n("ol",{attrs:{start:"4"}},[n("li",[e._v("postProcessBeanFactory(beanFactory)")])]),e._v(" "),n("p",[e._v("主要作用：Allows post-processing of the bean factory in context subclasses.允许在上下文子类中对bean工厂进行后处理。子类通过重写这个方法来在BeanFactory创建并预准备完成以后做进一步的设置。")]),e._v(" "),n("p",[e._v("以上1-4步骤为 BeanFactory的创建及预准备工作")]),e._v(" "),n("ol",{attrs:{start:"5"}},[n("li",[e._v("invokeBeanFactoryPostProcessors(beanFactory)")])]),e._v(" "),n("p",[e._v("主要作用：Invoke factory processors registered as beans in the context. 调用在上下文中注册为bean的工厂处理器。执行BeanFactoryPostProcessor的方法；")]),e._v(" "),n("p",[e._v("两个接口：BeanFactoryPostProcessor、BeanDefinitionRegistryPostProcessor(对于BeanFactoryPostProcessor的扩展类，BeanDefinitionRegistryPostProcessor可以注册更多的bean定义，这些定义反过来定义BeanFactoryPostProcessor实例。)")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("a). 获取工厂下当前所有的后置处理方法\n\nb). 先处理实现了 BeanDefinitionRegistryPostProcessor 接口的后置处理类。有限处理实现了 PriorityOrdered 的 BeanDefinitionRegistryPostProcessor。 再处理实现了 Ordered 的 BeanDefinitionRegistryPostProcessor。最后再处理没有实现 Ordered接口的 BeanDefinitionRegistryPostProcessor。 主要执行 postProcessBeanDefinitionRegistry() 方法。\n\nc). 用同样的逻辑处理 BeanFactoryPostProcessor 接口的后置处理类，主要执行 postProcessBeanFactory() 方法。\n")])])]),n("ol",{attrs:{start:"6"}},[n("li",[e._v("registerBeanPostProcessors(beanFactory)")])]),e._v(" "),n("p",[e._v("主要作用：Register bean processors that intercept bean creation. 注册拦截bean创建的bean处理器。注册BeanPostProcessor（Bean的后置处理器）")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("a). 获取所有的 BeanPostProcessor;后置处理器都默认可以通过PriorityOrdered、Ordered接口来执行优先级。\n\n对于PriorityOrdered 使用getBean()注册对应的处理器，然后添加到BeanFacotry中beanFactory.addBeanPostProcessor(postProcessor);\n\n再注册Ordered接口的。\n\n最后注册没有实现任何优先级接口的。\n\nb). 最终注册所有 MergedBeanDefinitionPostProcessor；\n\nc). 注册一个ApplicationListenerDetector；来在Bean创建完成后检查是否是ApplicationListener，如果是 则 applicationContext.addApplicationListener((ApplicationListener<?>) bean);\n")])])]),n("ol",{attrs:{start:"7"}},[n("li",[e._v("initMessageSource()")])]),e._v(" "),n("p",[e._v("主要作用：Initialize message source for this context. 为此上下文初始化消息源。初始化MessageSource组件（做国际化功能；消息绑定，消息解析）；")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("a). 获取BeanFactory\nb). 看容器中是否有id为messageSource的，类型是MessageSource的组件\n    如果有赋值给messageSource，如果没有自己创建一个DelegatingMessageSource；\n        MessageSource：取出国际化配置文件中的某个key的值；能按照区域信息获取；\nc). 把创建好的MessageSource注册在容器中，以后获取国际化配置文件的值的时候，可以自动注入MessageSource；beanFactory.registerSingleton(MESSAGE_SOURCE_BEAN_NAME, this.messageSource);\t\n")])])]),n("ol",{attrs:{start:"8"}},[n("li",[e._v("initApplicationEventMulticaster()")])]),e._v(" "),n("p",[e._v("主要作用：Initialize event multicaster for this context. 为此上下文初始化事件多播。初始化事件派发器；")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("a). 获取BeanFactory\nb). 从BeanFactory中获取applicationEventMulticaster的ApplicationEventMulticaster；\nc). 如果上一步没有配置；创建一个SimpleApplicationEventMulticaster\nd). 将创建的ApplicationEventMulticaster添加到BeanFactory中，以后其他组件直接自动注入\n")])])]),n("ol",{attrs:{start:"9"}},[n("li",[e._v("onRefresh()")])]),e._v(" "),n("p",[e._v("主要作用：Initialize other special beans in specific context subclasses. 初始化特定上下文子类中的其他特殊bean。")]),e._v(" "),n("p",[e._v("具体实现为空。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("a). 子类重写这个方法，在容器刷新的时候可以自定义逻辑；\n")])])]),n("ol",{attrs:{start:"10"}},[n("li",[e._v("registerListeners()")])]),e._v(" "),n("p",[e._v("主要作用：Check for listener beans and register them. 检查侦听器bean并注册它们。给容器中将所有项目里面的ApplicationListener注册进来；")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("a). 从容器中拿到所有的ApplicationListener\n\nb). 将每个监听器添加到事件派发器中；\n    getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);\n\nc). 派发之前步骤产生的事件；\n")])])]),n("ol",{attrs:{start:"11"}},[n("li",[e._v("finishBeanFactoryInitialization(beanFactory)")])]),e._v(" "),n("p",[e._v("主要功能：Instantiate all remaining (non-lazy-init) singletons.实例化所有剩余的（非惰性初始化）单例。初始化所有剩下的单实例bean；")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("a). beanFactory.preInstantiateSingletons();初始化后剩下的单实例bean\n\nb). 获取剩余的bean实例，非抽象的，是单例的，非懒加载的。\n\nc). 如果是工厂类，则 前缀+& 获取工厂类，根据条件调用getBean获取实例对象。\n\nd). 非工厂类，直接调用getBean获取实例对象。\n\ne) 最终会走到 AbstractAutowireCapableBeanFactory#createBean() 和 doCreateBean() 方法。\n")])])]),n("p",[e._v("createBean 逻辑：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("\n1）、createBean(beanName, mbd, args);\n2）、Object bean = resolveBeforeInstantiation(beanName, mbdToUse);让BeanPostProcessor先拦截返回代理对象；\n    【InstantiationAwareBeanPostProcessor】：提前执行；\n    先触发：postProcessBeforeInstantiation()；\n    如果有返回值：触发postProcessAfterInitialization()；\n3）、如果前面的InstantiationAwareBeanPostProcessor没有返回代理对象；调用4）\n4）、Object beanInstance = doCreateBean(beanName, mbdToUse, args);创建Bean\n        1）、【创建Bean实例】；createBeanInstance(beanName, mbd, args);\n        利用工厂方法或者对象的构造器创建出Bean实例；\n        2）、applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);\n        调用MergedBeanDefinitionPostProcessor的postProcessMergedBeanDefinition(mbd, beanType, beanName);\n        3）、【Bean属性赋值】populateBean(beanName, mbd, instanceWrapper);\n        赋值之前：\n            1）、拿到InstantiationAwareBeanPostProcessor后置处理器；\n                postProcessAfterInstantiation()；\n            2）、拿到InstantiationAwareBeanPostProcessor后置处理器；\n                postProcessPropertyValues()；\n            =====赋值之前：===\n            3）、应用Bean属性的值；为属性利用setter方法等进行赋值；\n                applyPropertyValues(beanName, mbd, bw, pvs);\n        4）、【Bean初始化】initializeBean(beanName, exposedObject, mbd);\n            1）、【执行Aware接口方法】invokeAwareMethods(beanName, bean);执行xxxAware接口的方法\n                BeanNameAware\\BeanClassLoaderAware\\BeanFactoryAware\n            2）、【执行后置处理器初始化之前】applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);\n                BeanPostProcessor.postProcessBeforeInitialization（）;\n            3）、【执行初始化方法】invokeInitMethods(beanName, wrappedBean, mbd);\n                1）、是否是InitializingBean接口的实现；执行接口规定的初始化；\n                2）、是否自定义初始化方法；\n            4）、【执行后置处理器初始化之后】applyBeanPostProcessorsAfterInitialization\n                BeanPostProcessor.postProcessAfterInitialization()；\n        5）、注册Bean的销毁方法；\n5）、将创建的Bean添加到缓存中singletonObjects；\n\n")])])]),n("p",[e._v("此处使用了三级缓存来解决循环依赖。")]),e._v(" "),n("ol",{attrs:{start:"12"}},[n("li",[e._v("finishRefresh()")])]),e._v(" "),n("p",[e._v("a). clearResourceCaches")]),e._v(" "),n("p",[e._v("清除上下文级别的资源缓存（例如来自扫描的ASM元数据）。")]),e._v(" "),n("p",[e._v("b). initLifecycleProcessor")]),e._v(" "),n("p",[e._v("初始化和生命周期有关的后置处理器；LifecycleProcessor\n默认从容器中找是否有lifecycleProcessor的组件【LifecycleProcessor】；如果没有new DefaultLifecycleProcessor();\n加入到容器；")]),e._v(" "),n("p",[e._v("写一个LifecycleProcessor的实现类，可以在BeanFactory\nvoid onRefresh();\nvoid onClose();")]),e._v(" "),n("p",[e._v("c). getLifecycleProcessor().onRefresh();\n拿到前面定义的生命周期处理器（BeanFactory）；回调onRefresh()；")]),e._v(" "),n("p",[e._v("d). publishEvent(new ContextRefreshedEvent(this));发布容器刷新完成事件；")]),e._v(" "),n("p",[e._v("e). liveBeansView.registerApplicationContext(this);")]),e._v(" "),n("h3",{attrs:{id:"总结"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[e._v("#")]),e._v(" 总结")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("1）、Spring容器在启动的时候，先会保存所有注册进来的Bean的定义信息；\n    1）、xml注册bean；<bean>\n    2）、注解注册Bean；@Service、@Component、@Bean、xxx\n2）、Spring容器会合适的时机创建这些Bean\n    1）、用到这个bean的时候；利用getBean创建bean；创建好以后保存在容器中；\n    2）、统一创建剩下所有的bean的时候；finishBeanFactoryInitialization()；\n3）、后置处理器；BeanPostProcessor\n    1）、每一个bean创建完成，都会使用各种后置处理器进行处理；来增强bean的功能；\n        AutowiredAnnotationBeanPostProcessor:处理自动注入\n        AnnotationAwareAspectJAutoProxyCreator:来做AOP功能；\n        xxx....\n        增强的功能注解：\n        AsyncAnnotationBeanPostProcessor\n        ....\n4）、事件驱动模型；\n    ApplicationListener；事件监听；\n    ApplicationEventMulticaster；事件派发：\n")])])]),n("h2",{attrs:{id:"spring-生命周期"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#spring-生命周期"}},[e._v("#")]),e._v(" spring 生命周期")]),e._v(" "),n("ol",[n("li",[n("p",[e._v("实例化BeanFactoryPostProcessor实现类  对应上面的第5步")])]),e._v(" "),n("li",[n("p",[e._v("执行BeanFactoryPostProcessor的postProcessBeanFactory方法  对应上面的第5步")])]),e._v(" "),n("li",[n("p",[e._v("实例化 BeanPostProcesspr实现类    对应上面的第6步")])]),e._v(" "),n("li",[n("p",[e._v("实例化 InstantiationAwareBeanPostProcessorAdapter实现类   对应上面的第6步")])]),e._v(" "),n("li",[n("p",[e._v("执行 InstantiationAwareBeanPostProcessor 的 postProcessorBeforeInstantiation 方法   对应上面的第11步")])]),e._v(" "),n("li",[n("p",[e._v("执行bean的构造器     对应上面的第11步")])]),e._v(" "),n("li",[n("p",[e._v("执行 InstantiationAwareBeanPostProcessor 的 postProcessAfterInstantiation 方法   对应上面的第11步")])]),e._v(" "),n("li",[n("p",[e._v("执行 InstantiationAwareBeanPostProcessor 的 postProcessPropertyValues 方法     对应上面的第11步")])]),e._v(" "),n("li",[n("p",[e._v("为Bean注入属性     对应上面的第11步")])]),e._v(" "),n("li",[n("p",[e._v("调用 BeanNameAware的setBeanName方法     对应上面的第11步  初始化之前 initializeBean 组开始阶段")])]),e._v(" "),n("li",[n("p",[e._v("调用 BeanFactoryAware 的setBeanFactory方法     对应上面的第11步")])]),e._v(" "),n("li",[n("p",[e._v("执行 BeanPostProcessor 的 postProcessorBeforeInstantiation 方法   对应上面的第11步")])]),e._v(" "),n("li",[n("p",[e._v("调用InitializingBean的afterPropertiesSet方法，进行初始化，调用初始化方法   对应上面的第11步")])]),e._v(" "),n("li",[n("p",[e._v("执行 BeanPostProcessor 的 postProcessorAfterInstantiation 方法    对应上面的第11步")])]),e._v(" "),n("li",[n("p",[e._v("初始化成功   对应上面的第11步")])]),e._v(" "),n("li",[n("p",[e._v("调用 DiposibleBean 的 destroy方法。调用销毁方法。")])])]),e._v(" "),n("h3",{attrs:{id:"如何解决循环依赖"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#如何解决循环依赖"}},[e._v("#")]),e._v(" 如何解决循环依赖")]),e._v(" "),n("p",[e._v("无法解决构造器的循环依赖问题。")]),e._v(" "),n("p",[e._v("private final Map<String, Object> singletonObjects = new ConcurrentHashMap<>(256); //一级缓存  用于存放完全初始化好的 bean，从该缓存中取出的 bean 可以直接使用")]),e._v(" "),n("p",[e._v("private final Map<String, Object> earlySingletonObjects = new HashMap<>(16); // 二级缓存    提前曝光的单例对象的cache，存放原始的 bean 对象（尚未填充属性），用于解决循环依赖      从三级缓存获取，并从三级缓存剪切到二级缓存")]),e._v(" "),n("p",[e._v("private final Map<String, ObjectFactory<?>> singletonFactories = new HashMap<>(16); // 三级缓存    单例对象工厂的cache，存放 bean 工厂对象，用于解决循环依赖    创建构造函数完成后就会加入")]),e._v(" "),n("p",[e._v("// 这个缓存也十分重要：它表示bean创建过程中都会在里面呆着~\n// 它在Bean开始创建时放值，创建完成时会将其移出~\nprivate final Set"),n("String",[e._v(" singletonsCurrentlyInCreation = Collections.newSetFromMap(new ConcurrentHashMap<>(16));   调用创建方法之前就会加入")])],1),e._v(" "),n("p",[e._v("// 至少被创建了一次的 都会放进这里~~~~\nprivate final Set"),n("String",[e._v(" alreadyCreated = Collections.newSetFromMap(new ConcurrentHashMap<>(256));")])],1),e._v(" "),n("p",[e._v("先从一级缓存singletonObjects中去获取。（如果获取到就直接return）")]),e._v(" "),n("p",[e._v("如果获取不到或者对象正在创建中（isSingletonCurrentlyInCreation()），那就再从二级缓存earlySingletonObjects中获取。（如果获取到就直接return）")]),e._v(" "),n("p",[e._v("如果还是获取不到，且允许singletonFactories（allowEarlyReference=true）通过getObject()获取。就从三级缓存singletonFactory.getObject()获取。（如果获取到了就从singletonFactories中移除，并且放进earlySingletonObjects。其实也就是从三级缓存移动（是剪切、不是复制哦~）到了二级缓存）")]),e._v(" "),n("p",[e._v("A依赖于B，B依赖于A，整体流程如下：")]),e._v(" "),n("p",[e._v("创建A实例，先将 A 加入singletonsCurrentlyInCreation，然后创建构造方法，然后将其加入 singletonFactories，后续对 A进行值设置。")]),e._v(" "),n("p",[e._v("A设置B的过程中，发现B不存在，从三个缓存中都获取不到。所以需要创建B的实例")]),e._v(" "),n("p",[e._v("开始创建B的实例，将B加入 singletonsCurrentlyInCreation，然后创建构造方法，然后将其加入 singletonFactories，后续对 B进行设置值设置。")]),e._v(" "),n("p",[e._v("从一级缓存，获取不到，从二级缓存也获取不到，但是从三级缓存中获取到了，将A移除于 singletonFactories ， 加入到 earlySingletonObjects。所以能获取到A，并给B设置值。B最后创建完成，所以最后B 加入到 singletonObjects， 移除 singletonFactories 。")]),e._v(" "),n("p",[e._v("将创建的B返回到 A设置值时的情况。则此时A设置值成功。因此A 也成功创建了。最后A加入到singletonObjects，移除 earlySingletonObjects。")]),e._v(" "),n("h2",{attrs:{id:"相关定义"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#相关定义"}},[e._v("#")]),e._v(" 相关定义")]),e._v(" "),n("h3",{attrs:{id:"beandefinition"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#beandefinition"}},[e._v("#")]),e._v(" BeanDefinition")]),e._v(" "),n("p",[e._v("BeanDefinition表示Bean定义，Spring根据BeanDefinition来创建Bean对象，BeanDefinition有很多的属性用来          描述Bean，BeanDefinition是Spring中非常核心的概念。")]),e._v(" "),n("p",[e._v("重要属性：beanClass，scope，isLazy，dependsOn，primary，initMethodName。")]),e._v(" "),n("p",[e._v("beanClass表示bean的类型，Spring在创建Bean的过程中会根据此属性来实例化得到对象。")]),e._v(" "),n("p",[e._v("scope 表示bean的作用域，singleton表示单例bean，prototype表示一个原型bean。")]),e._v(" "),n("p",[e._v("isLazy 表示一个类是否需要懒加载，原型bean的isLazy属性不起作用，懒加载的单例bean，会在第一次getBean的时候生成该bean，非懒加载的单例bean，则会在Spring启动过程中直接生成好。")]),e._v(" "),n("p",[e._v("dependsOn 表示一个bean在创建之前所依赖的其他bean，在一个bean创建之前，它所依赖的这些bean得先全部创建好。")]),e._v(" "),n("p",[e._v("primary 表示一个bean是主bean，防止一个bean存在多个实例，导致spring不知道该如何选择。")]),e._v(" "),n("p",[e._v("initMethodName 表示一个bean的初始化方法。生命周期过程中有一个步骤叫做初始化，会在这个步骤中去调用bean的初始化方法。")]),e._v(" "),n("h3",{attrs:{id:"beanfactory"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#beanfactory"}},[e._v("#")]),e._v(" BeanFactory")]),e._v(" "),n("p",[e._v('BeanFactory是一种"Spring容器"，就是Bean工厂，可以用来创建Bean，获取Bean。')]),e._v(" "),n("p",[e._v("BeanFactory将利用BeanDefinition来生成Bean对象，BeanDefinition相当于BeanFactory的原材料，Bean对象就相当于BeanFactory所生产出来的产品。")]),e._v(" "),n("p",[e._v("BeanFactory的实现中，DefaultListableBeanFactory的功能：支持单例Bean，支持Bean别名，支持父子BeanFactory，支持Bean类型转化，支持Bean后置处理，支持FactoryBean，支持自动装配，等等。")]),e._v(" "),n("h3",{attrs:{id:"factorybean"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#factorybean"}},[e._v("#")]),e._v(" FactoryBean")]),e._v(" "),n("p",[e._v("FactoryBean是Spring所提供的一种较灵活的创建Bean的方式，可以通过实现FactoryBean接口中的getObject()方法来返回一个对象，这个对象就是最终的Bean对象。")]),e._v(" "),n("p",[e._v("FactoryBean对象本身也是一个Bean，同时相当于一个小型工厂，可以生产出另外的Bean")]),e._v(" "),n("h3",{attrs:{id:"applicationcontext"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#applicationcontext"}},[e._v("#")]),e._v(" ApplicationContext")]),e._v(" "),n("p",[e._v("ApplicationContext是比BeanFactory更加强大的Spring容器，它既可以创建bean，获取bean，还支持国际化，事件广播，获取资源等BeanFactory不具备的功能。")]),e._v(" "),n("p",[e._v("继承了 EnvironmentCapable 这个接口，拥有了获取环境变量的功能，可以通过ApplicationContext获取操作系统环境变量和JVM环境变量。")]),e._v(" "),n("p",[e._v("继承了 ListableBeanFactory 这个接口，拥有了获取所有beanNames，判断某个beanName是否存在 beanDefinition对象，统计 BeanDefinition个数，获取某个类型对应的所有 beanNames等功能。")]),e._v(" "),n("p",[e._v("继承了 HierarchicalBeanFactory 接口，拥有了获取父 BeanFactory，判断某个name是否存在bean对象的功能。")]),e._v(" "),n("p",[e._v("继承了 MessageSource 接口，拥有了国际化功能，可以直接利用 MessageSource对象获取某个国际化资源。")]),e._v(" "),n("p",[e._v("继承了 ApplicationEventPublisher 接口，拥有了事件发布功能，可以发布事件。")]),e._v(" "),n("p",[e._v("继承了 ApplicationContext 接口，拥有了加载并获取资源的功能。")]),e._v(" "),n("h3",{attrs:{id:"beanpostprocessor"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#beanpostprocessor"}},[e._v("#")]),e._v(" BeanPostProcessor")]),e._v(" "),n("p",[e._v("BeanPostProcessor 是Spring提供的一种扩展机制，可以利用该机制对Bean进行定制化加工，在Spring底层源码实现中，也广泛的用到了该机制，通常也叫做Bean后置处理器。")]),e._v(" "),n("p",[e._v("postProcessBeforeInitialization(): 初始化前方法，表示可以利用这个方法来对Bean在初始化前进行自定义加工。")]),e._v(" "),n("p",[e._v("postProcessAfterInitialization(): 初始化后方法，表示可以利用这个方法来对Bean在初始化后进行自定义加工。")]),e._v(" "),n("h2",{attrs:{id:"springmvc-运行原理"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#springmvc-运行原理"}},[e._v("#")]),e._v(" SpringMVC 运行原理")]),e._v(" "),n("p",[e._v("a). 发送请求")]),e._v(" "),n("p",[e._v("b). DispatcherServlet找到匹配的HandlerMapping，解析请求对应的Handler")]),e._v(" "),n("p",[e._v("c). 调用适配器进行处理")]),e._v(" "),n("p",[e._v("d). 适配器根据Handler调用真正的处理器开始处理请求，并处理相应的业务逻辑")]),e._v(" "),n("p",[e._v("e). 处理器处理完业务后，会返回一个ModelAndView对象")]),e._v(" "),n("p",[e._v("f). ViewResolver根据View查找实际的View")]),e._v(" "),n("p",[e._v("g). DispatcherServlet把返回的Model传递给View")]),e._v(" "),n("p",[e._v("h). 返回请求。")])])}),[],!1,null,null,null);a.default=s.exports}}]);