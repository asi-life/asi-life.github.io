(window.webpackJsonp=window.webpackJsonp||[]).push([[37],{530:function(e,t,a){"use strict";a.r(t);var r=a(4),v=Object(r.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h2",{attrs:{id:"常用的消息中间件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#常用的消息中间件"}},[e._v("#")]),e._v(" 常用的消息中间件")]),e._v(" "),a("ol",[a("li",[e._v("Kafka")])]),e._v(" "),a("p",[e._v("kafka的吞吐量几乎是行业里最优秀的。")]),e._v(" "),a("p",[e._v("性能高，发消息给kakfa是毫秒级的。可用性也很高，支持集群部署。")]),e._v(" "),a("p",[e._v("存在丢数据的情况：kafka收到消息后会写入一个磁盘缓冲区，并没有直接落地到物理磁盘上，机器本身故障，可能会导致磁盘缓冲区里的数据丢失。")]),e._v(" "),a("p",[e._v("功能单一。主要用于收数据，发数据。把Kafka用在用户行为日志的采集和传输上，用于大数据。")]),e._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[e._v("RabbitMQ")])]),e._v(" "),a("p",[e._v("rabbitMQ优势在于保证数据不丢失，保证高可用性，集群部署的时候部分机器宕机可以继续运行，支持部分高级功能，如死信队列，消息重试等。")]),e._v(" "),a("p",[e._v("吞吐量比较低，一般就是每秒几万的级别，遇到特别特别高并发的情况下，支撑起来很困难。")]),e._v(" "),a("p",[e._v("对其进行集群扩展，比较麻烦。")]),e._v(" "),a("p",[e._v("且开发语言是erlang.")]),e._v(" "),a("ol",{attrs:{start:"3"}},[a("li",[e._v("RocketMq")])]),e._v(" "),a("p",[e._v("RocketMQ的吞吐量同样很高，单机可以达到10万QPS，保证高可用，而且支持通过配置保证数据不丢失，可以部署大规模集群，还支持各种高级的功能。比如延迟消息，事务消息，消息回溯，死信队列，消息积压等等。")]),e._v(" "),a("p",[e._v("基于java开发。")]),e._v(" "),a("h3",{attrs:{id:"rocketmq"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rocketmq"}},[e._v("#")]),e._v(" RocketMQ")]),e._v(" "),a("p",[e._v("RocketMQ主要包含四个核心部分：")]),e._v(" "),a("p",[e._v("a). 第一块是 NameServer. 负责管理集群中所有Broker信息。让使用MQ的系统可以通过他感知到集群里面有哪些Broker")]),e._v(" "),a("p",[e._v("b). 第二块就是 Broker 集群本身")]),e._v(" "),a("p",[e._v("c). 第三块就是 MQ发送消息的那些系统了，一般称为生产者。")]),e._v(" "),a("p",[e._v("d). 第四块就是 MQ处理消息的那些系统了，一般称为消费组。")]),e._v(" "),a("ol",[a("li",[e._v("NameServer")])]),e._v(" "),a("p",[e._v("NameServer可以部署多台机器，集群部署，保证高可用。")]),e._v(" "),a("p",[e._v("每个Broker启动都得向所有的NameServer进行注册。同时每隔30秒向NameServer发送心跳信息，如果没有发送了，NameServer能感知到相关Broker已经挂掉。")]),e._v(" "),a("p",[e._v("每个系统每隔一段时间，定时发送请求到NameServer取拉取最新的集群Broker信息。")]),e._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[e._v("Broker")])]),e._v(" "),a("p",[e._v("对于主从的Broker，两个Broker都会启动时向NameServer进行注册，同时每30秒发送心跳，采用TCP长连接。")]),e._v(" "),a("p",[e._v("而从Broker会不停的向主Broker去拉取消息。Master-Slave模式采取的是Pull模式拉取消息。")]),e._v(" "),a("p",[e._v("消费者的系统在获取消息是，可能会从Mater Broker获取消息，也有可能从Slave Broker获取消息。")]),e._v(" "),a("p",[e._v("4.5版本之前，如果运行过程中Master Broker挂了，Slave没法自动切换成Master的。没法自动进行切换。")]),e._v(" "),a("p",[e._v("所以在4.5之后，出现了叫Dledger的机制实现RocketMQ的高可用自动切换。通过Dledge技术和Raft协议算法进行leader选举，直接将一个Slave Broker选举为新的Master Broker。")]),e._v(" "),a("ol",{attrs:{start:"3"}},[a("li",[e._v("MQ的核心数据模型")])]),e._v(" "),a("p",[e._v("TOPIC：主要表达意思为数据集合的意思")]),e._v(" "),a("ol",{attrs:{start:"4"}},[a("li",[e._v("RocketMQ：可视化管理界面")])]),e._v(" "),a("p",[e._v("对RocketMQ的rocketmq-console进行打包部署即可。")]),e._v(" "),a("ol",{attrs:{start:"5"}},[a("li",[e._v("RocketMQ集群进行OS内核参数的调整")])]),e._v(" "),a("p",[e._v("a). vm.overcommit_memory")]),e._v(" "),a("p",[e._v("有三个值可选：")]),e._v(" "),a("p",[e._v("0: 中间件系统申请内存的时候，os内核会检查内存是否够用。判断为不够，就会导致中间件系统异常出错。")]),e._v(" "),a("p",[e._v("1：把所有可用的物理内存都分配给你，只要有内存就给你来用，避免申请内存失败问题。")]),e._v(" "),a("div",{staticClass:"language-sh extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sh"}},[a("code",[a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[e._v("echo")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v("'vm.overcommit_memory=1'")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">>")]),e._v(" /etc/sysctl.conf\n")])])]),a("p",[e._v("b). vm.max_map_count")]),e._v(" "),a("p",[e._v("影响中间件系统可以开启的线程数量。")]),e._v(" "),a("p",[e._v("c). vm.swappiness")]),e._v(" "),a("p",[e._v("控制进程的swap行为，就是os会把一部分磁盘空间作为swap区域。")]),e._v(" "),a("p",[e._v("d). ulimit")]),e._v(" "),a("p",[e._v("空间linux上的最大文件链接数的。")]),e._v(" "),a("ol",{attrs:{start:"6"}},[a("li",[e._v("同步发送消息到RocketMQ")])]),e._v(" "),a("p",[e._v("即将消息发送给RocketMQ然后等待返回。")]),e._v(" "),a("ol",{attrs:{start:"7"}},[a("li",[e._v("异步发送消息到RocketMQ")])]),e._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// 设置异步发送失败的时候重试次数为0,将消息发送到topic时，增加")]),e._v("\n\nproducer"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("setRetryTimesWhenSendAsyncFailed")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("\n\nproducer"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("send")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("message"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("new")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("SendCallBack")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    "),a("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[e._v("@Override")]),e._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("public")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("void")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("onSuccess")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("SendResult")]),e._v(" sendResult"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n    "),a("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[e._v("@Override")]),e._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("public")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("void")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("OnException")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Throwable")]),e._v(" e"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\n")])])]),a("p",[e._v("将消息发送给RocketMQ时，直接将消息发送过去，不需要等待结果返回，就会继续往下走。同时后续会回调SendCallback里面的函数。")]),e._v(" "),a("ol",{attrs:{start:"8"}},[a("li",[e._v("发送单向消息")])]),e._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[e._v("producer"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("sendOneway")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("msg"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n")])])]),a("p",[e._v("消息发送，不关注是否发送成功。")]),e._v(" "),a("ol",{attrs:{start:"9"}},[a("li",[e._v("push消费模式")])]),e._v(" "),a("p",[e._v("Broker会主动把消息发送给你的消费者。")]),e._v(" "),a("ol",{attrs:{start:"10"}},[a("li",[e._v("pull消费模式")])]),e._v(" "),a("p",[e._v("Broker不会主动推送消息给Consumer，消费者主动发送请求到Broker去拉取消息。")]),e._v(" "),a("ol",{attrs:{start:"11"}},[a("li",[e._v("RocketMQ生产者工作原理")])]),e._v(" "),a("p",[e._v("a). 创建Topic的时候指定MessageQueue数量")]),e._v(" "),a("p",[e._v("即这个Topic对应了多少个队列。")]),e._v(" "),a("ol",{attrs:{start:"12"}},[a("li",[e._v("Topic，MessageQueue以及Broker之间的关系")])]),e._v(" "),a("p",[e._v("每个Topic的数据都是分布式存储在多个Broker中，而Topic有几个MessageQueue, MessageQueue存在于Topic中。")]),e._v(" "),a("ol",{attrs:{start:"13"}},[a("li",[e._v("生产者发送消息的时候写入哪个MessageQueue")])]),e._v(" "),a("p",[e._v("生产者会根据NameServer进行通信获取Topic的路由数据。所以生产者从NameServer中就会知道，一个Topic有几个MessageQueue，那些MessageQueue在哪台Broker汲取上，哪些MessageQueue在另外一台Broker机器上。根据策略进行发送message。")]),e._v(" "),a("ol",{attrs:{start:"14"}},[a("li",[e._v("如果某个Broker出现故障怎么办")])]),e._v(" "),a("p",[e._v("produce中增加 sendLatencyFaultEnable开关，开启以后会有一个容错机制，某次访问发现存在网络延迟，就会自动回避访问这个Broker一段时间。")]),e._v(" "),a("ol",{attrs:{start:"15"}},[a("li",[e._v("CommitLog消息顺序的写入机制")])]),e._v(" "),a("p",[e._v("通过CommitLog进行消息的存储，每隔文件限定1GB，Broker收到消息之后就直接追加写入这个文件的末尾。如果超过1GB就会创建一个新的CommitLog文件。")]),e._v(" "),a("ol",{attrs:{start:"16"}},[a("li",[e._v("MessageQueue在数据存储中体现在哪里")])]),e._v(" "),a("p",[e._v("对Topic下的每个MessageQueue都会有一系列的ConsumeQueue文件。")]),e._v(" "),a("p",[e._v("$HOME/store/consumequeue/{topic}/{queueId}/{fileName}")]),e._v(" "),a("p",[e._v("其中{topic}代指某个topic，{queueId}代指某个MessageQueue。")]),e._v(" "),a("p",[e._v("同时对存储这台Broker机器上的Topic下的一个MessageQueue，他有很多的ConsumeQueue文件，这个ConsumeQueue文件里存储的是一条消息对应在CommitLog文件中的offset偏移量。")]),e._v(" "),a("ol",{attrs:{start:"17"}},[a("li",[e._v("如何让消息写入CommitLog文件近乎内存写性能的")])]),e._v(" "),a("p",[e._v("Broker是基于OS操作系统的PageCache和顺序写的两个机制，来提升写入CommitLog文件的性能的。")]),e._v(" "),a("p",[e._v("顺序写就是不停的在文件末尾进行消息的追加。")]),e._v(" "),a("p",[e._v("数据写入CommitLog文件的时候，不是直接写入底层的物理文件的，而是先进入OS的PageCache内存缓存中，然后后续由OS的后台线程选一个时间，异步化的将OS PageCache内存缓冲中的数据刷入底层的磁盘文件。")]),e._v(" "),a("ol",{attrs:{start:"18"}},[a("li",[e._v("同步刷盘和异步刷盘")])]),e._v(" "),a("p",[e._v("生产者把消息发送给Broker，Broker将消息写入OS PageCache中，就直接返回ACK给生产者了。这就是异步刷盘，可能会导致刷入内存的部分信息丢失。")]),e._v(" "),a("p",[e._v("生产者发送一条消息出去，broker收到了消息，必须直接强制把这个消息刷入底层的物理磁盘文件中，然后才会返回ack给producer。这叫同步刷盘。会导致消息写入吞吐量急剧下降，但可以保证数据不丢失。")]),e._v(" "),a("ol",{attrs:{start:"19"}},[a("li",[e._v("DLedger是如何基于Raft协议选举LeaderBroker的")])]),e._v(" "),a("p",[e._v("首先多台机器通过投票选择一个leader，但是第一次都会投自己，所以无法选举。后续对每个Broker进行随机沉睡，谁先醒来，就会选举自己，将信息发给其他broker，其他boker正好的醒来时收到了信息，则也会选择该Broker。如此重复多次后，当一个broker的选取数超过了n/2+1则被选择为master。")]),e._v(" "),a("ol",{attrs:{start:"20"}},[a("li",[e._v("DLedger是如何基于Raft协议进行多副本同步的")])]),e._v(" "),a("p",[e._v("主要分为两个阶段：一个为uncommitted，一个是committed阶段。")]),e._v(" "),a("p",[e._v("Leader Broker上的DLedger收到一条数据之后，会标记为uncommitted状态，然后会通过自己的DLedgerServer组件把这个uncommitted数据发送给Follower Broker的DLedgerServer。")]),e._v(" "),a("p",[e._v("接着Follower Broker的DLegerServer收到uncommitted消息之后，必须返回一个ack给Leader Broker的DLedgerServer，然后如果Leader Broker收到超过半数的Follower Broker返回ack之后，就会将消息标记为committed状态。")]),e._v(" "),a("p",[e._v("然后Leader Broker上的DLedgerServer就会发送commited消息给Follower Broker机器的DLedgerServer，让他们也把消息标记为comitted状态。")]),e._v(" "),a("ol",{attrs:{start:"21"}},[a("li",[e._v("如果Leader Broker崩溃了怎么办")])]),e._v(" "),a("p",[e._v("如果Leader Broker挂了，剩下的两个Follow Broker就会重新发起选举，就会基于DLedger还是采用Raft协议算法，去选举出一个新的Leader Broker继续对外提供服务，而且会对没有完成的数据同步进行一些恢复性的操作，保证数据不会丢失。")]),e._v(" "),a("ol",{attrs:{start:"22"}},[a("li",[e._v("消费组到底是什么")])]),e._v(" "),a("p",[e._v("即给消费者取一个名字，如果消息被发送到MQ，那么每个组都会拉去到这条消息，且同一个消费组有多台机器的话，只有一台机器会获取到这条消息。")]),e._v(" "),a("ol",{attrs:{start:"23"}},[a("li",[e._v("集群模式消费和广播模式消费。")])]),e._v(" "),a("p",[e._v("默认情况下是集群模式。")]),e._v(" "),a("p",[e._v("即：一个消费组获取到一条消息，只会交给组内的一台机器去处理，不是每条机器都获取到这条消息。")]),e._v(" "),a("p",[e._v("广播模式是对于一个消费组获取到的一条消息，组内每台机器都可以获取到这条消息。")]),e._v(" "),a("ol",{attrs:{start:"24"}},[a("li",[e._v("MessageQueue与消费者的关系")])]),e._v(" "),a("p",[e._v("一个消费者中的多台机器是如何消费MessageQueue的。会均匀的将MessageQueue分配给消费组的多台机器来消费。")]),e._v(" "),a("ol",{attrs:{start:"25"}},[a("li",[e._v("Push模式 和 Pull模式")])]),e._v(" "),a("p",[e._v("两个消费模式的本质是一样的，都是消费者机器主动发送请求到Broker机器去拉取一批消息下来。")]),e._v(" "),a("p",[e._v("Pull模式的代码相对复杂繁琐。而Pshu模式底层本身就是基于消息拉取的方式做的，且消息时效性更好。")]),e._v(" "),a("p",[e._v("Push模式下：当请求发送到Broker，没有新的消息需要处理的时候，会让请求线程挂起，默认挂起15秒，这个期间会有后台线程每隔一会儿去检查是否有新的消息给你。")]),e._v(" "),a("ol",{attrs:{start:"26"}},[a("li",[e._v("Broker是如何将消息读取出来返回给消费者的。")])]),e._v(" "),a("p",[e._v("主要是通过ConsumerQueue和CommitLog")]),e._v(" "),a("p",[e._v("一个消费者机器发送了拉取请求到Broker，要拉取MessageQueue0中的消息。Broker就会找到MessageQueue0对应的ConsumQueue0，从里面找到第一条消息的offset。")]),e._v(" "),a("p",[e._v("接着Broker就需要根据ConsumeQueue0中找到第一条消息的地址，去CommitLog中根据这个offset地址去读取出来这条消息的数据，然后把这条消息的数据给消费者。")]),e._v(" "),a("ol",{attrs:{start:"27"}},[a("li",[e._v("消费者机器如何处理消息，进行ack以及提交消息进度")])]),e._v(" "),a("p",[e._v("当处理完一批消息后，消费者机器就会提交我们目前的一个消费进度到Broker上去，然后Broker就会存储我们的消费进度。")]),e._v(" "),a("ol",{attrs:{start:"28"}},[a("li",[e._v("如果消费者中出现宕机或者扩容机器，会怎么处理")])]),e._v(" "),a("p",[e._v("会进入一个rabalance的环境，重新给各个消费机器分配他们要处理的MessageQueue。")]),e._v(" "),a("ol",{attrs:{start:"29"}},[a("li",[e._v("ConsumeQueue文件也是基于os cache的")])]),e._v(" "),a("p",[e._v("ConsumQueue会被大量的消费者发送的请求给高并发的读取，所以ConsumeQueue文件的读操作是非常频繁的，而且会极大的影响到消费者进行消息拉取的性能和消费吞吐量。")]),e._v(" "),a("p",[e._v("所以Broker对ConsumeQueue文件同样是基于Os cache来进行优化的。")]),e._v(" "),a("p",[e._v("同时操作系统存在优化机制，读取一个磁盘文件的时候，会自动把磁盘文件的一些数据缓存到os cache中。")]),e._v(" "),a("ol",{attrs:{start:"30"}},[a("li",[e._v("CommitLog是基于os cache + 磁盘一起读取的")])]),e._v(" "),a("p",[e._v("如果读取的是刚刚写入CommitLog的数据，大概率还停留在os cache中，可以顺利的从Os cache里读取CommitLog中的数据。")]),e._v(" "),a("p",[e._v("如果读取的是比较早之前写入CommitLog的数据，早被刷入磁盘了，已经不再Os cache里，那么只能从磁盘的文件里读取了。")]),e._v(" "),a("ol",{attrs:{start:"31"}},[a("li",[e._v("什么时候会从os cache读，什么时候会从磁盘读")])]),e._v(" "),a("p",[e._v("消费者机器一直快读的在拉取和消费处理，紧紧的跟上了生产者写入broker的消费速率。那么几乎是在os cache中读取。")]),e._v(" "),a("p",[e._v("如果broker的负载很高，拉取消息的速度很慢，或者你自己的消费者拉取到一批消息之后处理的时候性能很低，处理的速度很慢，很导致消费速率跟不上生产速率。")]),e._v(" "),a("ol",{attrs:{start:"32"}},[a("li",[e._v("Master Broker什么时候会让你从Slave Broker拉取数据")])]),e._v(" "),a("p",[e._v("主要是根据当前没拉取消息的数量和大小，以及最多可以存放在os cache内存里的消息的大小，如果没拉取的消息超过了最大能使用的内存的两，说明会频繁从磁盘加载数据，就让你从Slave broker去加载数据了。")]),e._v(" "),a("ol",{attrs:{start:"33"}},[a("li",[e._v("RocketMQ如何基于Netty扩展出高性能网络通信架构的")])]),e._v(" "),a("p",[e._v("a). Reactor主线程与长短连接")]),e._v(" "),a("p",[e._v("作为Broker而言，会有一个Reactor主线程，负责监听一个网络端口。")]),e._v(" "),a("p",[e._v("一个Producer想要跟Broker建立一个TCP长连接，保证建立一次连接后能长时间通信。")]),e._v(" "),a("p",[e._v("b). Producer和Broker建立一个长连接")]),e._v(" "),a("p",[e._v("建立一个长连接主要使用SocketChannel,通过Producer和Broker中的SocketChannel，这两个SocketChannel代表了两者间建立好了长连接。")]),e._v(" "),a("p",[e._v("c). 基于Reactor线程池监听连接中的请求")]),e._v(" "),a("p",[e._v("Reactor中有Reactor线程池，这个线程池里默认3个线程。Reactor主线程建立好的每个连接SocketChannel都会交给这个Reactor线程池里的其中一个线程去监听请求。")]),e._v(" "),a("p",[e._v("d). 基于Worker线程池完成一系列准备工作")]),e._v(" "),a("p",[e._v("Reactor线程从SocketChannel中读取出一个请求，这个请求在正式进行处理之前，必须要要先进行一些准备工作和预处理，比如SSL机密验证，编码解码，连接空闲检查，网络连接管理。")]),e._v(" "),a("p",[e._v("这些工作由Worker线程池来完成。Reactor线程收到的这个请求会交给Worker线程池中的一个线程进行处理。")]),e._v(" "),a("p",[e._v("e). 基于业务线程池完成请求的处理")]),e._v(" "),a("p",[e._v("接下来要处理收到的消息，会把请求转交给SendMessage线程池。且这个SendMessage线程配置的越多，处理消息的吞吐量越高。")]),e._v(" "),a("ol",{attrs:{start:"34"}},[a("li",[e._v("基于mmap内存映射实现磁盘文件的高性能读写")])]),e._v(" "),a("p",[e._v("a). mmap: Broker读写磁盘文件的核心技术")]),e._v(" "),a("p",[e._v("b). 传统文件IO操作的多次数据拷贝问题。")]),e._v(" "),a("p",[e._v("传统文件IO情况下，首先会把磁盘数据读取到内核IO缓冲区中，然后再从内核IO缓冲区里面读取到用户进程私有空间里去。")]),e._v(" "),a("p",[e._v("c). RocketMQ是如何基于mmap技术+page cache技术优化的")]),e._v(" "),a("p",[e._v("RocketMQ底层对CommitLog，ConsumeQueue之类的磁盘的读写操作，基本上都会采用mmap技术来实现。")]),e._v(" "),a("p",[e._v("具体是基于JDK NIO包下的MappedByteBuffer的map()函数。先将一个磁盘文件映射到内存中。(将物理上的磁盘文件的一些地址和用户进程私有空间的一些虚拟内存地址进行了一个映射)")]),e._v(" "),a("p",[e._v("mmap技术在进行文件映射的时候，一般有大小限制，在1.5GB~2GB之间。")]),e._v(" "),a("p",[e._v("d). 基于mmap技术+pagecache技术实现高性能的文件读写")]),e._v(" "),a("p",[e._v("拿到虚拟内存地址，接着对MappedByteBuffer执行写入操作，写入的时候会直接进入PageCache中，然后过一段时间之后，由os的线程异步刷新到磁盘。")]),e._v(" "),a("p",[e._v("而此过程只有一次的从PageCache里拷贝到磁盘文件里。")]),e._v(" "),a("p",[e._v("e). 预映射机制 + 文件预热机制")]),e._v(" "),a("p",[e._v("Broker针对磁盘文件高性能读写机制做了一些优化")]),e._v(" "),a("p",[e._v("内存预映射机制：Broker会针对磁盘上的各种CommitLog，ConsumeQueue文件预先分配好MappedFile，也就是提前对一些可能接下来要写的磁盘文件提前使用MappedByteBuffer执行map()函数完成映射。")]),e._v(" "),a("p",[e._v("文件预热：在提前对一些文件完成映射之后，因为映射不会直接将数据加载到内存里来，那么后续在读取CommitLog, ConsumeQueue的时候，可能频繁的从磁盘中加载数据到内存中去。所以其实在执行完map()函数之后，会进行madvise系统调用，尽可能多的把磁盘文件加载到内存中去。")]),e._v(" "),a("p",[e._v("写磁盘文件的时候都是进入PageCache的，保证写入高性能；同时尽可能多的通过map + madvise的映射后预热机制，把磁盘文件里的数据尽可能多的加载到PageCache里来。")]),e._v(" "),a("ol",{attrs:{start:"35"}},[a("li",[e._v("事务消息机制")])]),e._v(" "),a("p",[e._v("a). 生产者在接收到请求后，先发送一条half消息")]),e._v(" "),a("p",[e._v("b). RocketMQ返回half消息相应")]),e._v(" "),a("p",[e._v("c). 更新事务的相关数据")]),e._v(" "),a("p",[e._v("d). 给RocketMQ发送提交事务消息或者回滚信息")]),e._v(" "),a("p",[e._v("e). Rocket回调接口判断消息的状态。")]),e._v(" "),a("ol",{attrs:{start:"36"}},[a("li",[e._v("Broker消息零丢失方案：同步刷盘+Raft协议主从同步")])]),e._v(" "),a("p",[e._v("a). 用了事务消息机制，消息就一定不会丢了嘛")]),e._v(" "),a("p",[e._v("事务消息机制，保证了两个业务系统的数据一致性。")]),e._v(" "),a("p",[e._v("但不保证数据不会丢失。异步同步盈眶下，很容易就丢失了。")]),e._v(" "),a("p",[e._v("同时为了防止磁盘损坏，Broker使用主从同步机制。")]),e._v(" "),a("ol",{attrs:{start:"37"}},[a("li",[e._v("Consumer消息零丢失方案：手动提交offset + 自动故障转移")])]),e._v(" "),a("p",[e._v("获取消息后，不立刻进行提交，而是等待所有事件处理完后再提交offset, 返回ConsumeConcurrentlyStatus.CONSUME_SUCCESS。")]),e._v(" "),a("ol",{attrs:{start:"38"}},[a("li",[e._v("对订单系统核心流程引入幂等性机制，保证数据不会重复")])]),e._v(" "),a("p",[e._v("生产方：")]),e._v(" "),a("p",[e._v("a). 业务判断法")]),e._v(" "),a("p",[e._v("业务代码确保之前是否发送过。")]),e._v(" "),a("p",[e._v("b). 状态判断法")]),e._v(" "),a("p",[e._v("基于redis，如果发送成功，将信息保存在redis中。")]),e._v(" "),a("p",[e._v("消费方：")]),e._v(" "),a("p",[e._v("通过业务判断，是否已经处理过。或者生成一个唯一键。")]),e._v(" "),a("ol",{attrs:{start:"39"}},[a("li",[e._v("死信队列")])]),e._v(" "),a("p",[e._v("即死掉的消息的队列")]),e._v(" "),a("p",[e._v("订阅死信队列处理过期或者没有完成的队列。")]),e._v(" "),a("ol",{attrs:{start:"40"}},[a("li",[e._v("如何保证消息的顺序")])]),e._v(" "),a("p",[e._v("为了保证有序，需要让数据进入同一个MessageQueue")]),e._v(" "),a("ol",{attrs:{start:"41"}},[a("li",[e._v("延迟队列实现红包退款等功能")])]),e._v(" "),a("p",[e._v("RocketMQ默认支持的延迟级别：1s, 5s, 10s, 30s, 1m, 2m, 3m, 4m, 5m, 6m, 7m, 8m, 9m, 10m, 20m, 30m, 1h, 2h")]),e._v(" "),a("ol",{attrs:{start:"42"}},[a("li",[e._v("消息堆积该如何处理")])]),e._v(" "),a("p",[e._v("增加机器，或者将mq消息先写入到另一个topic中。")])])}),[],!1,null,null,null);t.default=v.exports}}]);