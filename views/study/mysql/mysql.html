<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>【MySql】 MySql知识点介绍总结 | 差不多的贝壳</title>
    <meta name="generator" content="VuePress 1.7.1">
    <link rel="icon" href="/logo.ico">
    <script language="javascript" type="text/javascript" src="https://cdn.bootcdn.net/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
    <script language="javascript" type="text/javascript" src="/js/MouseClickEffect.js"></script>
    <script language="javascript" type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>
    <meta name="description" content="【MySql】 MySql知识点介绍总结">
    <meta name="MySql知识点介绍总结" content="MySql知识点介绍总结">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    
    <link rel="preload" href="/assets/css/0.styles.98698290.css" as="style"><link rel="preload" href="/assets/js/app.e5db9849.js" as="script"><link rel="preload" href="/assets/js/3.ed8c06e7.js" as="script"><link rel="preload" href="/assets/js/1.9e75a2be.js" as="script"><link rel="preload" href="/assets/js/38.64581f9c.js" as="script"><link rel="prefetch" href="/assets/js/10.dcd742d7.js"><link rel="prefetch" href="/assets/js/11.9e8caa91.js"><link rel="prefetch" href="/assets/js/12.5acc7bfe.js"><link rel="prefetch" href="/assets/js/13.64c27640.js"><link rel="prefetch" href="/assets/js/14.d7c2c7ad.js"><link rel="prefetch" href="/assets/js/15.57c5ac2c.js"><link rel="prefetch" href="/assets/js/16.378ffe0f.js"><link rel="prefetch" href="/assets/js/17.89b3d75d.js"><link rel="prefetch" href="/assets/js/18.08a58208.js"><link rel="prefetch" href="/assets/js/19.0b8c12f8.js"><link rel="prefetch" href="/assets/js/20.438d1ec1.js"><link rel="prefetch" href="/assets/js/21.360c7dad.js"><link rel="prefetch" href="/assets/js/22.886d59ab.js"><link rel="prefetch" href="/assets/js/23.36693c07.js"><link rel="prefetch" href="/assets/js/24.c203effa.js"><link rel="prefetch" href="/assets/js/25.d0b49f35.js"><link rel="prefetch" href="/assets/js/26.0bd0b751.js"><link rel="prefetch" href="/assets/js/27.1ead41b5.js"><link rel="prefetch" href="/assets/js/28.8c71231e.js"><link rel="prefetch" href="/assets/js/29.0e91ba17.js"><link rel="prefetch" href="/assets/js/30.ba3f7ee4.js"><link rel="prefetch" href="/assets/js/31.a5aa6b4a.js"><link rel="prefetch" href="/assets/js/32.0180d8a3.js"><link rel="prefetch" href="/assets/js/33.1689da57.js"><link rel="prefetch" href="/assets/js/34.40068ec9.js"><link rel="prefetch" href="/assets/js/35.d45fa313.js"><link rel="prefetch" href="/assets/js/36.116b7de3.js"><link rel="prefetch" href="/assets/js/37.9156b580.js"><link rel="prefetch" href="/assets/js/39.e9338707.js"><link rel="prefetch" href="/assets/js/4.c3d42842.js"><link rel="prefetch" href="/assets/js/40.73109616.js"><link rel="prefetch" href="/assets/js/41.1b147abb.js"><link rel="prefetch" href="/assets/js/42.05bdc65e.js"><link rel="prefetch" href="/assets/js/43.8854147b.js"><link rel="prefetch" href="/assets/js/44.170947a8.js"><link rel="prefetch" href="/assets/js/45.47f74164.js"><link rel="prefetch" href="/assets/js/5.d57156ee.js"><link rel="prefetch" href="/assets/js/6.bd4ca3cb.js"><link rel="prefetch" href="/assets/js/7.fadd64b2.js"><link rel="prefetch" href="/assets/js/8.edf6ba42.js"><link rel="prefetch" href="/assets/js/9.9cbd478f.js">
    <link rel="stylesheet" href="/assets/css/0.styles.98698290.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar" data-v-2d5f533b><div data-v-2d5f533b><div id="loader-wrapper" class="loading-wrapper" data-v-d48f4d20 data-v-2d5f533b data-v-2d5f533b><div class="loader-main" data-v-d48f4d20><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div></div> <!----> <!----></div> <div class="password-shadow password-wrapper-out" style="display:none;" data-v-64685f0e data-v-2d5f533b data-v-2d5f533b><h3 class="title" style="display:none;" data-v-64685f0e data-v-64685f0e>差不多的贝壳</h3> <!----> <label id="box" class="inputBox" style="display:none;" data-v-64685f0e data-v-64685f0e><input type="password" value="" data-v-64685f0e> <span data-v-64685f0e>Konck! Knock!</span> <button data-v-64685f0e>OK</button></label> <div class="footer" style="display:none;" data-v-64685f0e data-v-64685f0e><span data-v-64685f0e><i class="iconfont reco-theme" data-v-64685f0e></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-64685f0e>vuePress-theme-reco</a></span> <span data-v-64685f0e><i class="iconfont reco-copyright" data-v-64685f0e></i> <a data-v-64685f0e><span data-v-64685f0e>差不多的贝壳</span>
            
          <span data-v-64685f0e>2021 - </span>
          2024
        </a></span></div></div> <div class="hide" data-v-2d5f533b><header class="navbar" data-v-2d5f533b><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/logo.jpg" alt="差不多的贝壳" class="logo"> <span class="site-name">差不多的贝壳</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      分类
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/人生第一次/" class="nav-link"><i class="iconfont undefined"></i>
  人生第一次
</a></li><li class="dropdown-item"><!----> <a href="/categories/书籍/" class="nav-link"><i class="iconfont undefined"></i>
  书籍
</a></li><li class="dropdown-item"><!----> <a href="/categories/生活/" class="nav-link"><i class="iconfont undefined"></i>
  生活
</a></li><li class="dropdown-item"><!----> <a href="/categories/电影/" class="nav-link"><i class="iconfont undefined"></i>
  电影
</a></li><li class="dropdown-item"><!----> <a href="/categories/宫崎骏/" class="nav-link"><i class="iconfont undefined"></i>
  宫崎骏
</a></li><li class="dropdown-item"><!----> <a href="/categories/电视剧/" class="nav-link"><i class="iconfont undefined"></i>
  电视剧
</a></li><li class="dropdown-item"><!----> <a href="/categories/日剧/" class="nav-link"><i class="iconfont undefined"></i>
  日剧
</a></li><li class="dropdown-item"><!----> <a href="/categories/生活剧/" class="nav-link"><i class="iconfont undefined"></i>
  生活剧
</a></li><li class="dropdown-item"><!----> <a href="/categories/袁隆平/" class="nav-link"><i class="iconfont undefined"></i>
  袁隆平
</a></li><li class="dropdown-item"><!----> <a href="/categories/国士无双/" class="nav-link"><i class="iconfont undefined"></i>
  国士无双
</a></li><li class="dropdown-item"><!----> <a href="/categories/学习/" class="nav-link"><i class="iconfont undefined"></i>
  学习
</a></li><li class="dropdown-item"><!----> <a href="/categories/操作系统/" class="nav-link"><i class="iconfont undefined"></i>
  操作系统
</a></li><li class="dropdown-item"><!----> <a href="/categories/动漫/" class="nav-link"><i class="iconfont undefined"></i>
  动漫
</a></li><li class="dropdown-item"><!----> <a href="/categories/故事/" class="nav-link"><i class="iconfont undefined"></i>
  故事
</a></li><li class="dropdown-item"><!----> <a href="/categories/婚姻/" class="nav-link"><i class="iconfont undefined"></i>
  婚姻
</a></li><li class="dropdown-item"><!----> <a href="/categories/java/" class="nav-link"><i class="iconfont undefined"></i>
  java
</a></li><li class="dropdown-item"><!----> <a href="/categories/面试题/" class="nav-link"><i class="iconfont undefined"></i>
  面试题
</a></li><li class="dropdown-item"><!----> <a href="/categories/Java/" class="nav-link"><i class="iconfont undefined"></i>
  Java
</a></li><li class="dropdown-item"><!----> <a href="/categories/中间件/" class="nav-link"><i class="iconfont undefined"></i>
  中间件
</a></li><li class="dropdown-item"><!----> <a href="/categories/消息队列/" class="nav-link"><i class="iconfont undefined"></i>
  消息队列
</a></li><li class="dropdown-item"><!----> <a href="/categories/Photoshop/" class="nav-link"><i class="iconfont undefined"></i>
  Photoshop
</a></li><li class="dropdown-item"><!----> <a href="/categories/网络编程/" class="nav-link"><i class="iconfont undefined"></i>
  网络编程
</a></li><li class="dropdown-item"><!----> <a href="/categories/数据库/" class="nav-link"><i class="iconfont undefined"></i>
  数据库
</a></li><li class="dropdown-item"><!----> <a href="/categories/框架/" class="nav-link"><i class="iconfont undefined"></i>
  框架
</a></li><li class="dropdown-item"><!----> <a href="/categories/redis/" class="nav-link"><i class="iconfont undefined"></i>
  redis
</a></li><li class="dropdown-item"><!----> <a href="/categories/近日总结/" class="nav-link"><i class="iconfont undefined"></i>
  近日总结
</a></li><li class="dropdown-item"><!----> <a href="/categories/Zookeeper/" class="nav-link"><i class="iconfont undefined"></i>
  Zookeeper
</a></li></ul></div></div><div class="nav-item"><a href="/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  标签
</a></div><div class="nav-item"><a href="/" class="nav-link"><i class="iconfont reco-home"></i>
  首页
</a></div><div class="nav-item"><a href="/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  时间轴
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-message"></i>
      关于
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/views/message-board.html" class="nav-link"><i class="iconfont reco-suggestion"></i>
  留言板
</a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-2d5f533b></div> <aside class="sidebar" data-v-2d5f533b><div class="personal-info-wrapper" data-v-ca798c94 data-v-2d5f533b><img src="/logo.jpg" alt="author-avatar" class="personal-img" data-v-ca798c94> <h3 class="name" data-v-ca798c94>
    差不多的贝壳
  </h3> <div class="num" data-v-ca798c94><div data-v-ca798c94><h3 data-v-ca798c94>34</h3> <h6 data-v-ca798c94>文章</h6></div> <div data-v-ca798c94><h3 data-v-ca798c94>38</h3> <h6 data-v-ca798c94>标签</h6></div></div> <hr data-v-ca798c94></div> <nav class="nav-links"><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      分类
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/人生第一次/" class="nav-link"><i class="iconfont undefined"></i>
  人生第一次
</a></li><li class="dropdown-item"><!----> <a href="/categories/书籍/" class="nav-link"><i class="iconfont undefined"></i>
  书籍
</a></li><li class="dropdown-item"><!----> <a href="/categories/生活/" class="nav-link"><i class="iconfont undefined"></i>
  生活
</a></li><li class="dropdown-item"><!----> <a href="/categories/电影/" class="nav-link"><i class="iconfont undefined"></i>
  电影
</a></li><li class="dropdown-item"><!----> <a href="/categories/宫崎骏/" class="nav-link"><i class="iconfont undefined"></i>
  宫崎骏
</a></li><li class="dropdown-item"><!----> <a href="/categories/电视剧/" class="nav-link"><i class="iconfont undefined"></i>
  电视剧
</a></li><li class="dropdown-item"><!----> <a href="/categories/日剧/" class="nav-link"><i class="iconfont undefined"></i>
  日剧
</a></li><li class="dropdown-item"><!----> <a href="/categories/生活剧/" class="nav-link"><i class="iconfont undefined"></i>
  生活剧
</a></li><li class="dropdown-item"><!----> <a href="/categories/袁隆平/" class="nav-link"><i class="iconfont undefined"></i>
  袁隆平
</a></li><li class="dropdown-item"><!----> <a href="/categories/国士无双/" class="nav-link"><i class="iconfont undefined"></i>
  国士无双
</a></li><li class="dropdown-item"><!----> <a href="/categories/学习/" class="nav-link"><i class="iconfont undefined"></i>
  学习
</a></li><li class="dropdown-item"><!----> <a href="/categories/操作系统/" class="nav-link"><i class="iconfont undefined"></i>
  操作系统
</a></li><li class="dropdown-item"><!----> <a href="/categories/动漫/" class="nav-link"><i class="iconfont undefined"></i>
  动漫
</a></li><li class="dropdown-item"><!----> <a href="/categories/故事/" class="nav-link"><i class="iconfont undefined"></i>
  故事
</a></li><li class="dropdown-item"><!----> <a href="/categories/婚姻/" class="nav-link"><i class="iconfont undefined"></i>
  婚姻
</a></li><li class="dropdown-item"><!----> <a href="/categories/java/" class="nav-link"><i class="iconfont undefined"></i>
  java
</a></li><li class="dropdown-item"><!----> <a href="/categories/面试题/" class="nav-link"><i class="iconfont undefined"></i>
  面试题
</a></li><li class="dropdown-item"><!----> <a href="/categories/Java/" class="nav-link"><i class="iconfont undefined"></i>
  Java
</a></li><li class="dropdown-item"><!----> <a href="/categories/中间件/" class="nav-link"><i class="iconfont undefined"></i>
  中间件
</a></li><li class="dropdown-item"><!----> <a href="/categories/消息队列/" class="nav-link"><i class="iconfont undefined"></i>
  消息队列
</a></li><li class="dropdown-item"><!----> <a href="/categories/Photoshop/" class="nav-link"><i class="iconfont undefined"></i>
  Photoshop
</a></li><li class="dropdown-item"><!----> <a href="/categories/网络编程/" class="nav-link"><i class="iconfont undefined"></i>
  网络编程
</a></li><li class="dropdown-item"><!----> <a href="/categories/数据库/" class="nav-link"><i class="iconfont undefined"></i>
  数据库
</a></li><li class="dropdown-item"><!----> <a href="/categories/框架/" class="nav-link"><i class="iconfont undefined"></i>
  框架
</a></li><li class="dropdown-item"><!----> <a href="/categories/redis/" class="nav-link"><i class="iconfont undefined"></i>
  redis
</a></li><li class="dropdown-item"><!----> <a href="/categories/近日总结/" class="nav-link"><i class="iconfont undefined"></i>
  近日总结
</a></li><li class="dropdown-item"><!----> <a href="/categories/Zookeeper/" class="nav-link"><i class="iconfont undefined"></i>
  Zookeeper
</a></li></ul></div></div><div class="nav-item"><a href="/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  标签
</a></div><div class="nav-item"><a href="/" class="nav-link"><i class="iconfont reco-home"></i>
  首页
</a></div><div class="nav-item"><a href="/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  时间轴
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-message"></i>
      关于
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/views/message-board.html" class="nav-link"><i class="iconfont reco-suggestion"></i>
  留言板
</a></li></ul></div></div> <!----></nav> <!----> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-64685f0e data-v-2d5f533b><h3 class="title" style="display:none;" data-v-64685f0e data-v-64685f0e>【MySql】 MySql知识点介绍总结</h3> <!----> <label id="box" class="inputBox" style="display:none;" data-v-64685f0e data-v-64685f0e><input type="password" value="" data-v-64685f0e> <span data-v-64685f0e>Konck! Knock!</span> <button data-v-64685f0e>OK</button></label> <div class="footer" style="display:none;" data-v-64685f0e data-v-64685f0e><span data-v-64685f0e><i class="iconfont reco-theme" data-v-64685f0e></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-64685f0e>vuePress-theme-reco</a></span> <span data-v-64685f0e><i class="iconfont reco-copyright" data-v-64685f0e></i> <a data-v-64685f0e><span data-v-64685f0e>差不多的贝壳</span>
            
          <span data-v-64685f0e>2021 - </span>
          2024
        </a></span></div></div> <div data-v-2d5f533b><main class="page"><div class="page-title" style="display:none;"><h1 class="title">【MySql】 MySql知识点介绍总结</h1> <div data-v-3b7f5bdf><i class="iconfont reco-account" data-v-3b7f5bdf><span data-v-3b7f5bdf>差不多的贝壳</span></i> <i class="iconfont reco-date" data-v-3b7f5bdf><span data-v-3b7f5bdf>2021-04-19</span></i> <i class="iconfont reco-eye" data-v-3b7f5bdf><span id="/views/study/mysql/mysql.html" data-flag-title="Your Article Title" class="leancloud-visitors" data-v-3b7f5bdf><a class="leancloud-visitors-count" style="font-size:.9rem;font-weight:normal;color:#999;"></a></span></i> <i class="iconfont reco-tag tags" data-v-3b7f5bdf><span class="tag-item" data-v-3b7f5bdf>MySql</span></i></div></div> <div class="theme-reco-content content__default" style="display:none;"><p><strong>目前国内流行范围最广的开源的关系型数据库</strong></p> <h2 id="mysql安装-windows"><a href="#mysql安装-windows" class="header-anchor">#</a> MySql安装(Windows)</h2> <ol><li><p><a href="https://dev.mysql.com/downloads/mysql/" target="_blank" rel="noopener noreferrer">安装包下载地址<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>,下载完后解压到本地。</p></li> <li><p>右键我的电脑属性-&gt;高级系统设置-&gt;高级-&gt;环境变量。</p></li> <li><p>选择系统变量或者用户变量，点击修改如下变量:</p></li></ol> <p>变量值为 path的属性，增加MySql解压后路径\bin的全路径。</p> <ol start="4"><li>修改MySql的默认配置</li></ol> <p>MySql解压路径下创建my.ini文件和data文件夹。在my.ini文件中输入如下信息</p> <div class="language-ini extra-class"><pre class="language-ini"><code><span class="token selector"> [mysql]</span>
<span class="token comment"> # 设置mysql客户端默认编码</span>
<span class="token constant"> default-character-set</span><span class="token attr-value"><span class="token punctuation">=</span>UTF8MB4</span>
<span class="token selector"> [mysqld]</span>
<span class="token comment"> # 设置端口号</span>
<span class="token constant"> port</span> <span class="token attr-value"><span class="token punctuation">=</span> 3306</span>
<span class="token comment"> # 设置mysql8.0的安装目录</span>
<span class="token constant"> basedir</span><span class="token attr-value"><span class="token punctuation">=</span>D:\\programFiles\\configurations\\computerLanguages\\databases\\mysql\\mysql-8.0.18</span>
<span class="token comment"> # 设置mysql数据库的数据的存放目录</span>
<span class="token constant"> datadir</span><span class="token attr-value"><span class="token punctuation">=</span>D:\\programFiles\\configurations\\computerLanguages\\databases\\mysql\\mysql-8.0.18\\data</span>
<span class="token comment"> # 允许最大连接</span>
<span class="token constant"> max_connections</span><span class="token attr-value"><span class="token punctuation">=</span>200</span>
<span class="token comment"> # 服务端默认UTF8MB4编码</span>
<span class="token constant"> character-set-server</span><span class="token attr-value"><span class="token punctuation">=</span>UTF8MB4</span>
<span class="token comment"> # 默认存储</span>
<span class="token constant"> default-storage-engine</span><span class="token attr-value"><span class="token punctuation">=</span>INNODB</span>
<span class="token comment"> # 默认使用“mysql_native_password”插件认证</span>
<span class="token constant"> default_authentication_plugin</span><span class="token attr-value"><span class="token punctuation">=</span>mysql_native_password</span>
<span class="token selector"> [client]</span>
<span class="token comment"> # 设置mysql客户端连接服务端时默认使用的端口</span>
<span class="token constant"> port</span><span class="token attr-value"><span class="token punctuation">=</span>3306</span>
<span class="token comment"> # 设置客户端编码</span>
<span class="token constant"> default-character-set</span><span class="token attr-value"><span class="token punctuation">=</span>UTF8MB4</span>
</code></pre></div><p>其中</p> <div class="language- extra-class"><pre class="language-text"><code>[mysqld] 对应 mysqld， server命令读取到的配置

[mysqld_safe] 对应 mysqld，server，mysqld_safe命令能读取到的配置

[mysql.server] 对应 mysqld，server，mysql.server命令能读取到的配置

[mysql] 对应mysql， client能读取到的配置

[mysqladmin] 对应 mysqladmin，client能读取到的配置

[mysqldump] 对应 mysqldump，client能读取到的配置

</code></pre></div><ol start="5"><li>MySql服务配置</li></ol> <ul><li><p>以管理员的身份运行cmd</p></li> <li><p>cmd通过cd进入mysql安装目录的bin目录下,输入</p></li></ul> <div class="language-shell extra-class"><pre class="language-shell"><code>mysqld --initialize --console 
</code></pre></div><p>记录cmd最后的密码</p> <p>注意：如果下面有步骤出现问题，可通过</p> <div class="language-shell extra-class"><pre class="language-shell"><code>net stop MySQSL8.0.18
sc delete MySQL8.0.18
<span class="token comment"># MySQL8.0.18 为后续步骤中自己的设置，可根据实际情况修改</span>
</code></pre></div><p>卸载服务后，删除mys.ini中datadir的数据重新执行该步骤解决</p> <ul><li>输入</li></ul> <div class="language-shell extra-class"><pre class="language-shell"><code>mysqld --install MySQL8.0.18 <span class="token comment"># (改为当前mysql的版本号)</span>
</code></pre></div><p>没有错误提示则说明服务安装成功。可在任务管理器的服务中查看到相关服务</p> <ul><li>启动服务</li></ul> <div class="language-shell extra-class"><pre class="language-shell"><code>net start MySQL8.0.18

<span class="token comment"># mysqld --remove是卸载MySQL服务，net stop mysql是停止服务</span>
</code></pre></div><ol start="6"><li>修改MySql的密码</li></ol> <ul><li>进入MySql</li></ul> <p>输入</p> <div class="language-shell extra-class"><pre class="language-shell"><code>mysql -u root -p 
</code></pre></div><p>提示输入密码，则输入第五步中的第二点的密码信息。</p> <ul><li>修改密码</li></ul> <p>输入</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">ALTER</span> <span class="token keyword">USER</span> <span class="token string">'root'</span><span class="token variable">@'localhost'</span> IDENTIFIED <span class="token keyword">WITH</span> mysql_native_password <span class="token keyword">BY</span> <span class="token string">'新密码'</span><span class="token punctuation">;</span> 

<span class="token comment">-- 或</span>

<span class="token keyword">ALTER</span> <span class="token keyword">USER</span> <span class="token string">'root'</span><span class="token variable">@'localhost'</span> IDENTIFIED <span class="token keyword">BY</span> <span class="token string">'新密码'</span><span class="token punctuation">;</span>
</code></pre></div><p>完成密码修改。</p> <h2 id="mysql基础知识点"><a href="#mysql基础知识点" class="header-anchor">#</a> MySql基础知识点</h2> <p>mysql包含相当多的基础知识点，可直接通过<a href="https://www.runoob.com/mysql/mysql-tutorial.html" target="_blank" rel="noopener noreferrer">教程<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>进行初步学习。同时可通过<a href="https://www.runoob.com/sql/sql-tutorial.html" target="_blank" rel="noopener noreferrer">SQL教程<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>来学习语法。以下是部分介绍。</p> <h3 id="操作数据库的命令"><a href="#操作数据库的命令" class="header-anchor">#</a> 操作数据库的命令</h3> <ul><li>创建数据库</li></ul> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">create</span> <span class="token keyword">database</span> 数据库名<span class="token punctuation">;</span>

<span class="token keyword">CREATE</span> <span class="token keyword">DATABASE</span> <span class="token keyword">IF</span> <span class="token operator">NOT</span> <span class="token keyword">EXISTS</span> 数据库名 <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span> utf8 <span class="token keyword">COLLATE</span> utf8_general_ci<span class="token punctuation">;</span>
<span class="token comment">-- IF NOT EXISTS 如果数据库不存在则创建，存在则不创建</span>
<span class="token comment">-- 创建后并设定其编码集为utf8</span>
</code></pre></div><ul><li>删除数据库</li></ul> <p>所有数据都会消失</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">drop</span> <span class="token keyword">database</span> 数据库名<span class="token punctuation">;</span>
</code></pre></div><ul><li>选择数据库</li></ul> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">use</span> 数据库名<span class="token punctuation">;</span>
</code></pre></div><h3 id="操作数据表的命令"><a href="#操作数据表的命令" class="header-anchor">#</a> 操作数据表的命令</h3> <ul><li>表中字段的类型</li></ul> <p>通过以下sql可查看数据库支持的数据类型</p> <div class="language-sql extra-class"><pre class="language-sql"><code>? <span class="token keyword">data</span> <span class="token keyword">types</span>
</code></pre></div><p>查询结果如下：
<img src="https://github.com/asi-life/asiLifePic/blob/master/mysql/mysql-data-types.png?raw=true" alt="mysql-data-type"></p> <p>MySQL支持多种类型，大致可以分为三类：数值，时间，字符串类型。</p> <p>数值主要有：</p> <table><thead><tr><th style="text-align:center;">类型</th> <th style="text-align:center;">大小</th></tr></thead> <tbody><tr><td style="text-align:center;">TINYINT</td> <td style="text-align:center;">1 byte</td></tr> <tr><td style="text-align:center;">SMALLINT</td> <td style="text-align:center;">2 byte</td></tr> <tr><td style="text-align:center;">MEDIUMINT</td> <td style="text-align:center;">3 byte</td></tr> <tr><td style="text-align:center;">INT 或 INTEGER</td> <td style="text-align:center;">4 byte</td></tr> <tr><td style="text-align:center;">BIGINT</td> <td style="text-align:center;">8 byte</td></tr> <tr><td style="text-align:center;">FLOAT</td> <td style="text-align:center;">4 byte</td></tr> <tr><td style="text-align:center;">DOUBLE</td> <td style="text-align:center;">8 byte</td></tr> <tr><td style="text-align:center;">DECIMAL</td> <td style="text-align:center;">DECIMAL(M,D),如果M&gt;D,为M+2否则为D+2</td></tr></tbody></table> <p>日期时间类型主要有:</p> <table><thead><tr><th style="text-align:center;">类型</th> <th style="text-align:center;">大小</th> <th style="text-align:center;">用途</th></tr></thead> <tbody><tr><td style="text-align:center;">DATE</td> <td style="text-align:center;">3 byte</td> <td style="text-align:center;">日期值</td></tr> <tr><td style="text-align:center;">TIME</td> <td style="text-align:center;">3 byte</td> <td style="text-align:center;">时间值或持续时间</td></tr> <tr><td style="text-align:center;">TEAR</td> <td style="text-align:center;">1 byte</td> <td style="text-align:center;">年份值</td></tr> <tr><td style="text-align:center;">DATETIME</td> <td style="text-align:center;">8 byte</td> <td style="text-align:center;">混合日期和时间值</td></tr> <tr><td style="text-align:center;">TIMESTAMP</td> <td style="text-align:center;">4 byte</td> <td style="text-align:center;">混合日期和时间值，时间戳</td></tr></tbody></table> <p>字符串类型主要有：</p> <table><thead><tr><th style="text-align:center;">类型</th> <th style="text-align:center;">大小</th> <th style="text-align:center;">用途</th></tr></thead> <tbody><tr><td style="text-align:center;">CHAR</td> <td style="text-align:center;">0-255 byte</td> <td style="text-align:center;">定长字符串</td></tr> <tr><td style="text-align:center;">VARCHAR</td> <td style="text-align:center;">0-65535 byte</td> <td style="text-align:center;">不超过255个字符的二进制字符串</td></tr> <tr><td style="text-align:center;">TINYBLOB</td> <td style="text-align:center;">0-255 byte</td> <td style="text-align:center;">不超过255个字符的二进制字符串</td></tr> <tr><td style="text-align:center;">TINYTEXT</td> <td style="text-align:center;">0-255 byte</td> <td style="text-align:center;">短文本字符串</td></tr> <tr><td style="text-align:center;">BLOG</td> <td style="text-align:center;">0-65535 byte</td> <td style="text-align:center;">二进制形式的长文本数据</td></tr> <tr><td style="text-align:center;">TEXT</td> <td style="text-align:center;">0-65535 byte</td> <td style="text-align:center;">长文本数据</td></tr> <tr><td style="text-align:center;">MEDIUMBLOB</td> <td style="text-align:center;">0-16777215 byte</td> <td style="text-align:center;">二进制形式的中等长度文本数据</td></tr> <tr><td style="text-align:center;">MEDIUMTEXT</td> <td style="text-align:center;">0-16777215 byte</td> <td style="text-align:center;">中等长度文本数据</td></tr> <tr><td style="text-align:center;">LONGBLOB</td> <td style="text-align:center;">0-4294967295 byte</td> <td style="text-align:center;">二进制形式的极大文本数据</td></tr> <tr><td style="text-align:center;">LONGTEXT</td> <td style="text-align:center;">0-4294967295 byte</td> <td style="text-align:center;">极大文本数据</td></tr></tbody></table> <p>上述为主要类型，还有些字段类型未进行列举。可自行学习。</p> <ul><li>创建数据库表</li></ul> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">create</span> <span class="token keyword">table</span> <span class="token keyword">if</span> <span class="token operator">not</span> <span class="token keyword">exists</span> <span class="token punctuation">`</span>table_name<span class="token punctuation">`</span> <span class="token punctuation">(</span>
  <span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">bigint</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span> <span class="token comment">-- 自增id</span>
  <span class="token punctuation">`</span>name<span class="token punctuation">`</span> <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">40</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span> <span class="token comment">-- 姓名</span>
  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">)</span>   <span class="token comment">-- 设置主键</span>
<span class="token punctuation">)</span> <span class="token keyword">engine</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">default</span> <span class="token keyword">charset</span><span class="token operator">=</span>utf8<span class="token punctuation">;</span>
</code></pre></div><ul><li>删除数据表</li></ul> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">drop</span> <span class="token keyword">table</span> table_name
<span class="token comment">--- 物理删除表</span>
<span class="token keyword">truncate</span> <span class="token keyword">table</span> table_name
<span class="token comment">-- 删除表内的所有数据</span>
</code></pre></div><h3 id="操作数据的命令"><a href="#操作数据的命令" class="header-anchor">#</a> 操作数据的命令</h3> <ul><li>增加数据</li></ul> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">insert</span> <span class="token keyword">into</span> table_name<span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">,</span> <span class="token punctuation">`</span>name<span class="token punctuation">`</span><span class="token punctuation">)</span> <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">&quot;asi&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">&quot;life&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>删除数据</li></ul> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">delete</span> <span class="token keyword">from</span> table_name <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
</code></pre></div><p>删除数据，是将一行数据删除，但是其索引页并未发生移动。</p> <ul><li>查询数据</li></ul> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> table_name <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
</code></pre></div><p>查询是sql中最复杂的，考虑情况很多。</p> <ul><li>更新数据</li></ul> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">update</span> tb_name <span class="token keyword">set</span> <span class="token punctuation">`</span>user_name<span class="token punctuation">`</span> <span class="token operator">=</span> <span class="token string">&quot;sd&quot;</span> <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="其他关键字"><a href="#其他关键字" class="header-anchor">#</a> 其他关键字</h3> <ul><li>like</li></ul> <p>进行模糊查询。</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> table_name <span class="token keyword">where</span> <span class="token punctuation">`</span>user_name<span class="token punctuation">`</span> <span class="token operator">like</span> <span class="token string">'%s%'</span><span class="token punctuation">;</span>

<span class="token comment">-- like '%s';</span>
<span class="token comment">-- like 's%';  根据最左匹配原则，建议使用这个</span>
<span class="token comment">-- like '%s%';</span>
</code></pre></div><p>注意事项：</p> <p>like 使用 '%s%' 仍可能使用到索引，当sql中使用了覆盖索引时，仍会使用到索引。</p> <p>以下是测试：
表结构如下：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> <span class="token keyword">IF</span> <span class="token keyword">EXISTS</span> <span class="token punctuation">`</span>tb_user<span class="token punctuation">`</span><span class="token punctuation">;</span>
<span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>tb_user<span class="token punctuation">`</span>  <span class="token punctuation">(</span>
  <span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
  <span class="token punctuation">`</span>user_name<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span> <span class="token keyword">CHARACTER</span> <span class="token keyword">SET</span> utf8mb4 <span class="token keyword">COLLATE</span> utf8mb4_bin <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
  <span class="token punctuation">`</span>age<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">)</span> <span class="token keyword">USING</span> <span class="token keyword">BTREE</span><span class="token punctuation">,</span>
  <span class="token keyword">INDEX</span> <span class="token punctuation">`</span>user_name<span class="token punctuation">`</span><span class="token punctuation">(</span><span class="token punctuation">`</span>user_name<span class="token punctuation">`</span><span class="token punctuation">)</span> <span class="token keyword">USING</span> <span class="token keyword">BTREE</span>
<span class="token punctuation">)</span> <span class="token keyword">ENGINE</span> <span class="token operator">=</span> <span class="token keyword">InnoDB</span> <span class="token keyword">CHARACTER</span> <span class="token keyword">SET</span> <span class="token operator">=</span> utf8mb4 <span class="token keyword">COLLATE</span> <span class="token operator">=</span> utf8mb4_bin ROW_FORMAT <span class="token operator">=</span> Dynamic<span class="token punctuation">;</span>

<span class="token comment">-- 使用</span>
<span class="token keyword">insert</span> <span class="token keyword">into</span> tb_user<span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">,</span> <span class="token punctuation">`</span>user_name<span class="token punctuation">`</span><span class="token punctuation">,</span> <span class="token punctuation">`</span>age<span class="token punctuation">`</span><span class="token punctuation">)</span> <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">&quot;asi&quot;</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">-- 插入数据，可通过存储过程进行批量插入，或者通过Java demo进行批量插入。</span>
</code></pre></div><p>使用如下语句执行：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> user_name <span class="token operator">like</span> <span class="token string">&quot;%0%&quot;</span><span class="token punctuation">;</span>
</code></pre></div><p>执行结果如下：</p> <p><img src="https://github.com/asi-life/asiLifePic/blob/master/mysql/explain-like-select-all.png?raw=true" alt="explain-like-select-all"></p> <p>此时走的全表扫描。</p> <p>再使用如下语句执行：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> id<span class="token punctuation">,</span>user_name <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> user_name <span class="token operator">like</span> <span class="token string">&quot;%0%&quot;</span><span class="token punctuation">;</span>
</code></pre></div><p>执行结果如下：</p> <p><img src="https://github.com/asi-life/asiLifePic/blob/master/mysql/explain-like-select-index.png?raw=true" alt="explain-like-select-index"></p> <p>此时走的是覆盖索引。</p> <p><a href="https://zhuanlan.zhihu.com/p/107125866" target="_blank" rel="noopener noreferrer">覆盖索引<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>: 只需要在一棵索引树上就能获取SQL所需的所有列数据，无需回表，速度更快。</p> <ul><li>union</li></ul> <p>用于连接两个或两个以上的select语句的结果组合到一个结果集合中。并且会删除重复的内容。</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">1</span> 
<span class="token keyword">union</span> 
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>order by</li></ul> <p>用于查询结果的排序。</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> table_name <span class="token keyword">where</span> <span class="token punctuation">`</span>name<span class="token punctuation">`</span> <span class="token operator">like</span> <span class="token string">'%s'</span> <span class="token keyword">order</span> <span class="token keyword">by</span> <span class="token punctuation">`</span>name<span class="token punctuation">`</span><span class="token punctuation">;</span>
</code></pre></div><p>使用时注意事项：
尽量让排序字段存在索引，且使用排序时字段的所以，否则数据量大的时候排序十分耗时。</p> <ul><li>group by</li></ul> <p>group by语句根据一个或多个列对结果集进行分组。
同时可以使用count，sum，avg，first, last, max, min等函数。WITH ROLLUP 可以实现在分组统计数据基础上再进行相同的统计（SUM,AVG,COUNT…）。</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">select</span> user_name <span class="token keyword">from</span> tb_user  <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> user_name<span class="token punctuation">;</span>
</code></pre></div><p>注意事项：
一条sql中 group by 不能出现在order by之后。
select 后的数据要在group by中出现过,或者使用了聚合函数，否则将会出错。</p> <ul><li>HAVING</li></ul> <p>WHERE 关键字无法与聚合函数一起使用。
HAVING 子句可以让我们筛选分组后的各组数据。</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token function">avg</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span><span class="token punctuation">,</span>user_name 
<span class="token keyword">from</span> tb_user
<span class="token keyword">where</span> user_name <span class="token operator">like</span> <span class="token string">'q%'</span>
<span class="token keyword">group</span> <span class="token keyword">by</span> user_name
<span class="token keyword">having</span> <span class="token function">avg</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">10</span><span class="token punctuation">;</span>  
</code></pre></div><ul><li>join</li></ul> <p>用于连接两张表。
join 分为
inner join(内连接)：获取两个表中字段匹配的记录，left join(左连接)：获取左表所有记录，即使右表没有对应的值，right join(右连接)：获取右表所有的记录，即使左表没有对应的值。</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> tb_test<span class="token punctuation">;</span>
<span class="token comment">-- 等价于  INNER可省略</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user<span class="token punctuation">,</span>tb_test<span class="token punctuation">;</span>
<span class="token comment">-- 且其结果数位 tb_user的数据 * tb_test的数据。</span>

<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">LEFT</span> <span class="token keyword">JOIN</span> tb_test <span class="token keyword">on</span> tb_user<span class="token punctuation">.</span>id <span class="token operator">=</span> tb_test<span class="token punctuation">.</span>id<span class="token punctuation">;</span>
<span class="token comment">-- 数据量的大小取决与tb_user的数据量</span>

<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">RIGHT</span> <span class="token keyword">JOIN</span> tb_test <span class="token keyword">on</span> tb_user<span class="token punctuation">.</span>id <span class="token operator">=</span> tb_test<span class="token punctuation">.</span>id<span class="token punctuation">;</span>
<span class="token comment">-- 数据量的大小取决与tb_test的数据量</span>
</code></pre></div><p>注意事项：
join前进行数据量的过滤。
使用数据量少的表作为驱动表。
两表的连接字段都需要建立索引。</p> <ul><li>limit offset</li></ul> <p>用于分页的实现。</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> table_name <span class="token keyword">limit</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token comment">-- 表示取前多少条数据。</span>

<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> table_name <span class="token keyword">limit</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">;</span>
<span class="token comment">-- 第一个数表示 要跳过的数量，后一位表示要查询的数量。</span>

<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> table_name <span class="token keyword">limit</span> <span class="token number">3</span> <span class="token keyword">offset</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token comment">-- 第一个表示要查询的数量，第二个表示偏移量，即要跳过的数据。</span>
</code></pre></div><ul><li>alter</li></ul> <p>用于修改数据表名或者修改数据表字段。</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token comment">-- 删除，添加或修改表字段</span>
<span class="token keyword">alter</span> <span class="token keyword">table</span> table_name <span class="token keyword">drop</span> filed<span class="token punctuation">;</span>

<span class="token keyword">alter</span> <span class="token keyword">table</span> table_name <span class="token keyword">add</span> filed <span class="token keyword">INT</span> <span class="token keyword">after</span> filed2<span class="token punctuation">;</span>

<span class="token keyword">alter</span> <span class="token keyword">table</span> table_name <span class="token keyword">modify</span> filed <span class="token keyword">CHAR</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">alter</span> <span class="token keyword">table</span> table_name change filed newFiled <span class="token keyword">BIGINT</span><span class="token punctuation">;</span>

<span class="token comment">-- 修改表名</span>
<span class="token keyword">alter</span> <span class="token keyword">table</span> table_name <span class="token keyword">RENAME</span> <span class="token keyword">to</span> new_table_name<span class="token punctuation">;</span> 
</code></pre></div><ul><li>explain</li></ul> <p>用于检查sql语句的执行情况，查询执行计划。</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> user_name <span class="token operator">like</span> <span class="token string">&quot;%0%&quot;</span><span class="token punctuation">;</span>
</code></pre></div><p><img src="https://github.com/asi-life/asiLifePic/blob/master/mysql/explain%E5%AD%97%E6%AE%B5%E4%BB%8B%E7%BB%8D.png?raw=true" alt="eplain字段介绍"></p> <p>字段：</p> <p>id: 执行计划的标识符。</p> <p>select_type: 该条语句select子句的类型。</p> <p>table: sql查询的表。</p> <p>partitions: 分区。</p> <p>type: 此条语句执行时使用的类型。</p> <p>possible_keys: 可能的索引值。</p> <p>key: 查询用到的索引。</p> <p>key_len: 索引长度。</p> <p>ref: 列与索引的比较。</p> <p>rows: 查询的行数(估计值)。</p> <p>filtered: 按表条件过滤的行百分比。</p> <p>Extra：执行计划额外的描述和说明。</p> <p>重要字段具体说明：</p> <ul><li><p>id
id 相同时，执行顺序由上到下。
如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行。
id如果相同，可以认为是一组，从上往下顺序执行。在所有组中，id值越大，越先执行。</p></li> <li><p>select_type</p> <ul><li>simple： 简单select，没有union和子查询。</li> <li>primary：子查询中最外层查询。</li> <li>union: union中的第二个或后面的select语句。</li> <li>dependent union: union中的第二个或后面的select语句,同时该语句依赖于外部的查询。</li> <li>union result: union的查询结果。</li> <li>subquery: 子查询中的第一个select。</li> <li>dependent subquery: 子查询中的第一个select,同时该语句依赖于外部查询。</li> <li>derived: 派生表的select，from后的子查询</li></ul></li> <li><p>type
对表的访问方式。从上到下查询方式越来越慢, <a href="https://mengkang.net/1124.html" target="_blank" rel="noopener noreferrer">参考链接<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <ul><li>system: 表只有一行，这是const type的特殊情况。</li> <li>const： 最多只有一行匹配。</li> <li>eq_ref：只匹配到一行的时候，最好的连接查询。</li></ul> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token comment">-- # 多表关联查询，单行匹配</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> ref_table<span class="token punctuation">,</span>other_table
<span class="token keyword">WHERE</span> ref_table<span class="token punctuation">.</span>key_column<span class="token operator">=</span>other_table<span class="token punctuation">.</span><span class="token keyword">column</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>ref: 匹配到了多行，触发条件：触发联合索引最左原则（不知道的搜下），或者这个索引不是主键，也不是唯一索引（换句话说，如果这个在这个索引基础之上查询的结果多于一行）。</li> <li>fulltext: 使用全文索引的时候才会出现</li> <li>ref_or_null: 这个查询类型和ref很像，但是 MySQL 会做一个额外的查询，来看哪些行包含了NULL。这种类型常见于解析子查询的优化。</li> <li>index_merge: 在一个查询里面很有多索引用被用到，可能会触发index_merge的优化机制。</li> <li>unique_subquery： 比eq_ref复杂的地方是使用了in的子查询，而且是子查询是主键或者唯一索引</li> <li>index_subquery: 它和unique_subquery，但是它在子查询里使用的是非唯一索引。</li> <li>range: 只有给定范围内的行才能被检索，使用索引来查询出多行。 输出行中的类决定了会使用哪个索引。 key_len列表示使用的最长的 key 部分。 这个类型的ref列是NULL。</li> <li>index: index类型和ALL类型一样，区别就是index类型是扫描的索引树。</li> <li>all: 全表扫描</li></ul></li> <li><p>Extra</p> <ul><li>using filesort： 常见于order by 字段 无法走索引造成,文件排序。需要注意优化,复杂条件可以选择建立联合索引进行优化。</li> <li>using join buffer size 常见于join连接,并且连接字段无法走索引时造成,缓存存储记录,BML优化,需要注意优化</li> <li>using tempoary: 常见于(分组排序,子查询,union等操作),需要形成临时表结果集,需要注意优化,需要注意,当应用到索引时,不一定出现</li> <li>using index 覆盖索引,索引列可以覆盖所有的查询字段,不用回表读取数据文件,代表最优</li> <li>Using index condition：确实命中了索引，但不是所有的列数据都在索引树上，还需要访问实际的行记录</li> <li>using where：SQL使用了where条件过滤数据，需要整体分析是否需要优化。</li> <li>Using join buffer (Block Nested Loop): 需要进行嵌套循环计算,这类SQL语句性能往往也较低，需要进行优化。</li></ul></li></ul> <h2 id="mysql-知识点深入"><a href="#mysql-知识点深入" class="header-anchor">#</a> MySQL 知识点深入</h2> <h3 id="mysql一条语句从客户端到mysql运行流程"><a href="#mysql一条语句从客户端到mysql运行流程" class="header-anchor">#</a> MySQL一条语句从客户端到MySQL运行流程</h3> <p><img src="https://github.com/asi-life/asiLifePic/blob/master/mysql/%E4%B8%80%E6%9D%A1%E8%AF%AD%E5%8F%A5%E5%9C%A8mysql%E4%B8%AD%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png?raw=true" alt="一条语句在mysql服务器中的执行流程"></p> <p>一条sql语句的执行需要经过以下几点：</p> <ol><li><p>连接器：负责和客户端建立连接，获取用户权限，维持和管理连接请求。</p></li> <li><p>解析器，分析器：解析sql，验证sql的正确性，即做此法分析和语法分析。来判断这条sql需要干什么。</p></li> <li><p>优化器：优化sql中一些执行顺序，以及是否索引，使用哪个索引最合适，尽量保证执行的时间最短。来如果执行这条sql。</p></li> <li><p>执行器：首先会判断是否有表的权限。有的话，会打开表执行，根据引擎的定义来调用引擎的接口来执行任务。</p></li></ol> <h3 id="存储引擎"><a href="#存储引擎" class="header-anchor">#</a> 存储引擎</h3> <p>MySQL中常用的存储引擎有InnoDB,MyISAM,MEMORY。</p> <p>三者都有一定的优缺点，可根据具体的场景进行使用，目前最常见的为InnoDB.</p> <table><thead><tr><th style="text-align:center;"></th> <th style="text-align:center;">InnoDB</th> <th style="text-align:center;">MyISAM</th> <th style="text-align:center;">MEMORY</th></tr></thead> <tbody><tr><td style="text-align:center;">支持事务</td> <td style="text-align:center;">是</td> <td style="text-align:center;">否</td> <td style="text-align:center;">否</td></tr> <tr><td style="text-align:center;">支持外键</td> <td style="text-align:center;">是</td> <td style="text-align:center;">否</td> <td style="text-align:center;">否</td></tr> <tr><td style="text-align:center;">聚簇索引</td> <td style="text-align:center;">有</td> <td style="text-align:center;">无</td> <td style="text-align:center;">无</td></tr> <tr><td style="text-align:center;">支持数据恢复</td> <td style="text-align:center;">是</td> <td style="text-align:center;">否</td> <td style="text-align:center;">否</td></tr> <tr><td style="text-align:center;">空间使用</td> <td style="text-align:center;">高</td> <td style="text-align:center;">低</td> <td style="text-align:center;">低</td></tr> <tr><td style="text-align:center;">内存使用</td> <td style="text-align:center;">高</td> <td style="text-align:center;">低</td> <td style="text-align:center;">高</td></tr> <tr><td style="text-align:center;">插入速度</td> <td style="text-align:center;">低</td> <td style="text-align:center;">高</td> <td style="text-align:center;">高</td></tr></tbody></table> <p>注：聚簇索引：是指直接通过一次索引查询到所有的数据，即索引列和每行数据一起进行存储，InnoDB只有主键索引使用聚簇索引。其他都是非聚簇索引：只存放索引和主键id的值。聚簇索引的两个特点：1. 使用记录主键值的大小及逆行记录和页的排序。2. B+树的叶子节点存储的是完整的用户记录。</p> <p>如果需要支持事务和保证数据和恢复的，且需支持外键，频繁的更新和删除时，可以使用innodb.</p> <p>如果不需要支持事务，主要用于存储和查询的话，可以使用MyISAM.</p> <p>如果安全性不要求很高，但是要求特别快，可以根据情况使用MEMORY.</p> <h3 id="索引"><a href="#索引" class="header-anchor">#</a> 索引</h3> <p>索引是MySQL高效运行的重要因素。其主要是通过索引，将数据进行排序。并通过索引页来进行一个快速的查找。类似于我们看书，查字典时，会提供一个目录，我们可以从目录快速查找到我们需要检索的数据所在位置。</p> <ul><li>索引的类型</li></ul> <p>普通索引：仅加速查询</p> <p>唯一索引：加速查询 + 列值唯一(可以有null)</p> <p>主键索引：加速查询 + 列值唯一(不可以有null) + 表中只有一个</p> <p>组合索引：多列值组成一个索引，专门用于组合搜索，效率大于索引合并(是用多个单列索引组合搜索)。</p> <p>全文索引：对文本的内容进行分词，进行搜索</p> <ul><li>创建索引</li></ul> <p>每个表的主键都会默认存在一个主键索引，如果没有主键，mysql也会自己通过隐藏字段设置一个主键索引。</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">INDEX</span> indexName <span class="token keyword">ON</span> table_name <span class="token punctuation">(</span>column_name<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">-- column_name可以为多个字段。</span>

<span class="token keyword">ALTER</span> <span class="token keyword">table</span> table_name <span class="token keyword">add</span> <span class="token keyword">primary</span> <span class="token keyword">key</span><span class="token punctuation">(</span>column_name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">-- 添加主键索引</span>

<span class="token keyword">ALTER</span> <span class="token keyword">table</span> table_name <span class="token keyword">add</span> <span class="token keyword">unique</span> index_name<span class="token punctuation">(</span>column_name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">-- 添加唯一索引</span>

<span class="token keyword">ALTER</span> <span class="token keyword">table</span> table_name <span class="token keyword">add</span> <span class="token keyword">index</span> index_name<span class="token punctuation">(</span>column_name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">-- 添加普通索引</span>

<span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> tbl_name <span class="token keyword">ADD</span> FULLTEXT index_name<span class="token punctuation">(</span>column_name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">-- 添加全文索引</span>
</code></pre></div><ul><li>删除索引</li></ul> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">drop</span> <span class="token keyword">index</span> <span class="token punctuation">[</span>index_name<span class="token punctuation">]</span> <span class="token keyword">on</span> table_name

<span class="token keyword">alter</span> <span class="token keyword">table</span> <span class="token punctuation">[</span>table_name<span class="token punctuation">]</span> <span class="token keyword">drop</span> <span class="token keyword">index</span> <span class="token punctuation">[</span>index_name<span class="token punctuation">]</span>
</code></pre></div><ul><li>显示索引</li></ul> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">SHOW</span> <span class="token keyword">INDEX</span> <span class="token keyword">FROM</span> table_name<span class="token punctuation">;</span>
</code></pre></div><ul><li>索引查用实现</li></ul> <p>最常用的索引方式有：hash索引和B+树索引。</p> <ul><li>hash索引</li></ul> <p>这是一个基于hash表实现的索引方法。将索引列计算出一个哈希值，存储再hash表中，如果存在hash冲突，是用链表进行保存。并且hash只保存hash值和行数的指针。</p> <p>优点：</p> <p>对于等值查询，hash索引的效率非常高。</p> <p>缺点：</p> <p>不能进行排序。</p> <p>不能进行范围查询。</p> <p>不能通过覆盖索引来避免行数据的读取。</p> <p>对于组合索引，不能是用组合索引中的部分索引进行查询，必须全部满足，因为hash值是通过所有索引列进行计算出的。</p> <ul><li>B+树索引</li></ul> <p>首先需要知道几个概念：</p> <p>二叉树：树的任何一个节点最多两个节点。</p> <p>二叉搜索树：树的任何一个节点最多两个节点，且每个节点的值一定大于等于其左节点，小于等于其右节点。</p> <p>平衡二叉树：树的任何一个节点最多两个节点，且每个节点的值一定大于等于其左节点，小于等于其右节点，且每个节点左右两个节点的高度差不超过一个设定值(默认为1)。</p> <p>B树：B为balance的一次，即为平衡树，但不是平衡二叉树。</p> <div class="language- extra-class"><pre><code>1. 其每个节点可以有多个节点，任意非叶子节点最多只有M个子节点(M&gt;2)。
2. 根节点的子节点为[2,M]。
3. 除根节点以外的非叶子节点的子节点为[M/2,M]。 
4. 每个节点存放至少M/2 - 1和最多M-1个关键字。
5. 非叶子节点的关键数个数为指向子节点的指针数-1。
6. 非叶子节点的每个关键字，从左到右进行了排序。 
7. 非叶子节点指向叶子节点的指针都满足其左节点的值都小于其本身，右节点的值都大于其本身。
8. 所有的叶子节点都在同一层。
</code></pre></div><p>以下为M=3时的B树。其中蓝色的为关键字，黄色的为指针，即为节点数。</p> <p><img src="https://github.com/asi-life/asiLifePic/blob/master/mysql/B%E6%A0%91.png?raw=true" alt="B树"></p> <p>B+树：与B树很像，有一些额外的特性。</p> <div class="language- extra-class"><pre><code>1. 有k个子树的非叶子节点包含k个索引。
2. 非叶子节点不保存数据，只来保存索引。
3. 所有的叶子节点中包含了全部的信息。
4. 非叶子节点的索引也在叶子节点中存在。
5. 叶子节点有指向下一个叶子节点的指针。叶子节点的数据从小到大排序。
6. 所有叶子节点都在同一层。
</code></pre></div><p><img src="https://github.com/asi-life/asiLifePic/blob/master/mysql/B+%E6%A0%91.png?raw=true" alt="B+树"></p> <p>因此使用B+树索引的时候，在数据插入的时候已经对索引列进行了排序。对于等值查询，范围查询也能十分快速的查询。并且每次都会查询到叶子节点，查询效率稳定，且与B+树的高度有关，后续讲数据页的时候会介绍高度的计算。</p> <ul><li>索引创建的注意事项</li></ul> <p>索引是查询过程中十分重要的因素，所以需要知道如何正确的创建索引。后续会从底层原理上介绍原因。</p> <ol><li><p>索引不是越多越好，每多一个索引就相当于多了一颗B+树，每次插入的过程就会对B+树进行操作，过多的索引会导致增加操作过慢。</p></li> <li><p>索引一般建议使用在重复率低的字段上。重复值多的数据，使用索引的效果并不明显。</p></li> <li><p>查询过程中经常要排序的字段上建立索引。</p></li> <li><p>索引列的大小。较长的字段上建立索引时，选择一段有标识度的长度作为索引，不要选择全部长度，越长索引列占用空间较大，很可能会增加b+树的高度。</p></li> <li><p>联合索引创建优先于独立索引。</p></li></ol> <ul><li>索引使用的注意事项</li></ul> <p>很多情况下误操作可能会导致索引的失效。从而导致查询过慢。可通过explain 关键字查看sql执行情况，查看是否使用了索引。</p> <ol><li>在索引列上进行计算操作，或使用了函数。</li> <li>进行了类型转换。</li> <li>使用了 != , &lt;&gt; 操作。</li> <li>使用了like '%s%'操作，且未用到覆盖索引。</li> <li>使用了or，且or中有字段未用到索引。</li> <li>数据库优化时，发现全表扫描比索引查询花的时间更少。</li> <li>联合索引时，优化后，范围查询后的字段无法使用索引。或者未用到最左列字段。</li></ol> <ul><li>索引在数据页中显示</li></ul> <p>a). 简单的实现索引存放在数据页中</p> <p>数据时存在在数据页中，每个数据页存放着表中部分数据。而为了能快速定位到属于哪个页，所以需要定制一个目录。每个目录项包括两个部分：</p> <p>a). 页的用记录中最小的主键值，用key表示</p> <p>b). 页号，用page_no表示。</p> <p>但是存在问题，直接利用这些数据是不利于后续进行修改和维护的。</p> <p>b) innoDB中的处理</p> <p>为了方便更好的维护，以及能尽量复用之前的数据页，在record_type中增加了一个类型1，表示索引目录项记录。即表示增加一个数据页，为索引页，在其中添加数据为记录页数据，记录其他存储数据的页的最小的主键值和页号信息。</p> <p>目录页和普通用户记录的区别：</p> <p>a). 目录项记录的record_type值是1，普通用户记录的record_type值是0.</p> <p>b). 目录项记录只有主键值和页的编号两个列，而普通用户记录的列是用户自己定义的，可能包含很多列。</p> <p>c). min_rec_flag属性，目录记录的值为1，普通用户记录的min_rec_flag属性为0.</p> <ul><li>InnoDB中 B+ 树索引的注意事项</li></ul> <p>a). 根页面万年不动窝,(随着数据的增加也不会变)</p> <p>b). 内节点中目录项记录的唯一性</p> <p>如果是二级索引，会在目录项中增加主键值。</p> <p>c).不宜创建过多</p> <p>过多会导致空间上和时间上消耗多大。一个索引就是一棵索引树。</p> <p>时间上，每进行一次增删查改，就需要修改所有的索引树，可能会对节点和记录的排序造成破坏，就会存在页面分裂或者页面回收的问题。</p> <p>d). 扫描区间</p> <p>只要索引列和常数使用 =, &lt;=&gt;, in, not in, is null, is not null, &gt;, &lt;, &gt;=, &lt;=, between, != 或者 like 都可以产生扫描区间。</p> <p>like 只有匹配完整字符串或者匹配字符串前缀才会产生合适的扫描区间。</p> <p>e). 排序和索引相同</p> <p>order by会生成临时文件，导致速度比较慢，如果能用到索引尽量用索引进行排序。</p> <p>联合索引排序时必须和索引顺序一致。且5.x版本不支持acs，desc的混用。</p> <p>f). 只为搜索，排序或者分组创建索引</p> <p>g). 索引列中不重复值的个数尽可能多</p> <p>h). 索引列的类型尽量小</p> <p>i). 可以只为索引列前缀创建索引，以减少索引占用的存储空间</p> <p>j). 尽量使用覆盖索引进行查询，以避免回表操作带来的性能损耗</p> <p>k). 让索引列以列名的形式单独出现再搜索条件中</p> <p>l). 为了尽可能少地让聚簇索引发生页面分裂的情况，建议让主键拥有AUTO_INCREMENT属性</p> <p>m). 定位并删除表中的冗余和重复索引。</p> <h3 id="一条sql在innodb中的执行流程"><a href="#一条sql在innodb中的执行流程" class="header-anchor">#</a> 一条SQL在InnoDB中的执行流程</h3> <p><img src="https://github.com/asi-life/asiLifePic/blob/master/mysql/%E4%B8%80%E6%9D%A1%E8%AF%AD%E5%8F%A5%E5%9C%A8innodb%E4%B8%AD%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png?raw=true" alt="一条语句在innodb中的执行流程.png"></p> <ul><li><p>会检查数据是否在缓存池中，如果数据不在缓存池中，会从磁盘加载。此处涉及到buffer pool的内部数据存储结构。</p></li> <li><p>根据情况加上独占锁，意向锁等。</p></li> <li><p>然后将旧数据写入undo log日志中，主要为了防止后续执行过程中出现问题，便于回滚，查询操作不会写入。新增操作会存入删除操作，删除操作会存入新增操作。</p></li> <li><p>根据语句更新缓存中的数据。</p></li> <li><p>将本次事务写入redo log buffer中。</p></li> <li><p>根据innodb_flush_log_at_trx_commit配置判断是否立刻刷入磁盘中。</p></li> <li><p>将日志信息写入mysql 的binlog日志中。</p></li> <li><p>在rodo log日志中写入当前语句在binlog日志的文件和位置，并提交commit标志。此时才认为整个事务完成。</p></li> <li><p>缓冲池中的更新数据在通过io线程在一段时间内，或者在一定情况下输入磁盘中。</p></li></ul> <h3 id="innodb记录存储结构"><a href="#innodb记录存储结构" class="header-anchor">#</a> InnoDB记录存储结构</h3> <p>InnoDB是一个将表中的数据存储到磁盘上的存储引擎，即使关闭并重启服务器，数据还是存在的。</p> <p>InnoDB将数据划分为若干个页，以页作为磁盘和内存之间交互的基本单位。InnoDB中页的大小一般为16KB。一般情况下，一次最少从磁盘读取16KB的内容到内存中，一次最少把内存中的16KB内容刷新到磁盘中。</p> <p>系统变量 innodb_page_size表明了InnoDB存储引擎中页大小，默认16384(16KB).</p> <h4 id="innodb行数据"><a href="#innodb行数据" class="header-anchor">#</a> InnoDB行数据</h4> <p>InnoDB存储引擎到现在为止设计了4中不同类型的行格式。分别是COMPACT, REDUNDANT, DYNAMIC, COMPRESSED.</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token keyword">table</span><span class="token punctuation">(</span>列信息<span class="token punctuation">)</span> ROW_FORMAT <span class="token operator">=</span> 行格式名称<span class="token punctuation">;</span>

<span class="token keyword">alter</span> <span class="token keyword">table</span> 表名 ROW_FORMAT <span class="token operator">=</span> 行格式名称

</code></pre></div><h4 id="compact-行格式"><a href="#compact-行格式" class="header-anchor">#</a> COMPACT 行格式</h4> <p>主要分为两个部分。</p> <ol><li>记录的额外信息</li></ol> <p>其中包括： 变长字段长度列表，NULL值列表，记录头信息</p> <p>a). 变长字段长度列表</p> <p>MySQL支持一些变长的数据类型，如：VARCHARE(M), VARBINARY(M), TEXT, BLOB类型等。</p> <p>所以变长类型需要保存两部分信息：1. 真正的数据内容。2. 该数据占用的字节数。</p> <p>COMPACT行格式将占用的字节数全部存放在行数据记录的开头位置，从而形成一个变长字段长度列表，各变长字段的真实数据占用的字节数按照列的顺序<font color="red">逆序</font>存放.</p> <p>当变长字符串类容较多时，有时需要两个字节来表示。</p> <p>规则如下</p> <div class="language- extra-class"><pre class="language-text"><code>W 表示：某个字符集中最多需要W字节来表示一个字符。比如 utf8mb4字符集中的W就是4，utf8字符集中的W就是3，gbk字符集中的W就是2，ascii字符集中的W就是1.

M 表示：对于变长类型 VARCHAR(M)来说，这种类型表示能存储最多M个字符，所以这种类型能表示的字符串最多占用的字节数就是M*W.

L 表示： 该变长字段实际存储的字符串占用的字节数。


如果 M * W &lt;= 255, 那么使用一个字节来保存实际数据占用的字节数。

如果 M * W &gt; 255, 则分为两种情况

  L &lt;= 127, 则用1字节来表示真实数据占用的字节数

  L &gt; 127，则用2 字节来表示真实数据占用的字节数

</code></pre></div><p>使用字节的第一个二进制位作为标志位，如果该字节的第一个位为0，则该字节就是单独的字段长度。如果该字节的第一个位为1，该字节就是半个字段长度。</p> <p>b). NULL值列表</p> <p>某些列可能存储NULL值，如果把这些NULL值都放到记录的真实数据种存储会很占地方。所以进行统一管理。</p> <p>NULL值列表使用字节来记录，每个字节中的每一位表示一列。如果该列为NULL，则用1表示。有点类似布尔算法的记录方式。</p> <p>c). 记录头信息</p> <p>记录头信息由固定的5字节组成，用于描述记录的一些属性。5字节即为40个二进制位，不同的为代表不同的意思。</p> <p>0-39 表示对应的40个二进制位.</p> <table><thead><tr><th style="text-align:center;">二进制位</th> <th style="text-align:center;">名称</th> <th style="text-align:center;">大小(位)</th> <th style="text-align:center;">描述</th></tr></thead> <tbody><tr><td style="text-align:center;">0</td> <td style="text-align:center;">预留位1</td> <td style="text-align:center;">1</td> <td style="text-align:center;">没有使用</td></tr> <tr><td style="text-align:center;">1</td> <td style="text-align:center;">预留位2</td> <td style="text-align:center;">1</td> <td style="text-align:center;">没有使用</td></tr> <tr><td style="text-align:center;">2</td> <td style="text-align:center;">deleted_flag</td> <td style="text-align:center;">1</td> <td style="text-align:center;">标记该记录是否被删除</td></tr> <tr><td style="text-align:center;">3</td> <td style="text-align:center;">min_rec_flag</td> <td style="text-align:center;">1</td> <td style="text-align:center;">B+树每层非叶子节点中最小的目录项记录都会添加该标记</td></tr> <tr><td style="text-align:center;">4-7</td> <td style="text-align:center;">n_owned</td> <td style="text-align:center;">4</td> <td style="text-align:center;">一个页面中记录会被分成若干个组，每个组中有一个记录是&quot;带头大哥&quot;，其余都是&quot;小弟&quot;，&quot;带头大哥&quot;记录的n_owned值代表改组中所有的记录条数，&quot;小弟&quot;记录的n_owned值都为0</td></tr> <tr><td style="text-align:center;">8-20</td> <td style="text-align:center;">heap_no</td> <td style="text-align:center;">13</td> <td style="text-align:center;">表示当前记录在页面堆中的相对位置</td></tr> <tr><td style="text-align:center;">21-23</td> <td style="text-align:center;">record_type</td> <td style="text-align:center;">3</td> <td style="text-align:center;">表示当前记录的类型，0表示普通类型，1表示B+树非叶子节点目录项记录，2表示Infimum记录，3表示Supremum记录</td></tr> <tr><td style="text-align:center;">24-39</td> <td style="text-align:center;">next_record</td> <td style="text-align:center;">16</td> <td style="text-align:center;">表示下一条记录的相对位置</td></tr></tbody></table> <ol start="2"><li>记录的真实数据</li></ol> <p>列1的值，列2的值,.... 列n的值</p> <p>记录真实数据量除了添加的列数据以外，还会为每个记录默认添加一些类。</p> <table><thead><tr><th style="text-align:center;">列名</th> <th style="text-align:center;">是否必须</th> <th style="text-align:center;">占用空间</th> <th style="text-align:center;">描述</th></tr></thead> <tbody><tr><td style="text-align:center;">row_id</td> <td style="text-align:center;">否</td> <td style="text-align:center;">6字节</td> <td style="text-align:center;">行ID,唯一标识一条记录</td></tr> <tr><td style="text-align:center;">trx_id</td> <td style="text-align:center;">是</td> <td style="text-align:center;">6字节</td> <td style="text-align:center;">事务ID</td></tr> <tr><td style="text-align:center;">roll_pointer</td> <td style="text-align:center;">是</td> <td style="text-align:center;">7字节</td> <td style="text-align:center;">回滚指针</td></tr></tbody></table> <p>真正名称为：DB_ROW_ID, DB_TRX_ID, DB_ROLL_PTR.</p> <h4 id="redundant-行格式"><a href="#redundant-行格式" class="header-anchor">#</a> REDUNDANT 行格式</h4> <p>与 COMPACT 行格式类似。</p> <p>REDUNDANT有部分区别。</p> <ol><li>记录的额外信息</li></ol> <p>包含字段长度偏移列表，记录头信息。</p> <p>a). 长度偏移列表</p> <p>与 COMPACT行格式的变长字段长度列表是不一样的。</p> <p>记录了该记录中所有列(包括隐藏列)的长度信息都按照逆序存储到字段长度偏移列表。</p> <p>且多了偏移两个子，意味着计算列值长度的方式不像COMPACT行格式那么直观，采用两个相邻偏移量的差值来计算各个列值的长度。</p> <p>b). 记录头信息</p> <p>REDUNDANT行格式的记录头信息占用6字节，总计48个二进制位。</p> <table><thead><tr><th style="text-align:center;">二进制位</th> <th style="text-align:center;">名称</th> <th style="text-align:center;">大小(位)</th> <th style="text-align:center;">描述</th></tr></thead> <tbody><tr><td style="text-align:center;">0</td> <td style="text-align:center;">预留位1</td> <td style="text-align:center;">1</td> <td style="text-align:center;">没有使用</td></tr> <tr><td style="text-align:center;">1</td> <td style="text-align:center;">预留位2</td> <td style="text-align:center;">1</td> <td style="text-align:center;">没有使用</td></tr> <tr><td style="text-align:center;">2</td> <td style="text-align:center;">deleted_flag</td> <td style="text-align:center;">1</td> <td style="text-align:center;">标记该记录是否被删除</td></tr> <tr><td style="text-align:center;">3</td> <td style="text-align:center;">min_rec_flag</td> <td style="text-align:center;">1</td> <td style="text-align:center;">B+树每层非叶子节点中最小的目录项记录都会添加该标记</td></tr> <tr><td style="text-align:center;">4-7</td> <td style="text-align:center;">n_owned</td> <td style="text-align:center;">4</td> <td style="text-align:center;">一个页面中记录会被分成若干个组，每个组中有一个记录是&quot;带头大哥&quot;，其余都是&quot;小弟&quot;，&quot;带头大哥&quot;记录的n_owned值代表改组中所有的记录条数，&quot;小弟&quot;记录的n_owned值都为0</td></tr> <tr><td style="text-align:center;">8-20</td> <td style="text-align:center;">heap_no</td> <td style="text-align:center;">13</td> <td style="text-align:center;">表示当前记录在页面堆中的相对位置</td></tr> <tr><td style="text-align:center;">21-30</td> <td style="text-align:center;">n_field</td> <td style="text-align:center;">10</td> <td style="text-align:center;">表示记录中列的数量</td></tr> <tr><td style="text-align:center;">31</td> <td style="text-align:center;">1byte_offs_flag</td> <td style="text-align:center;">1</td> <td style="text-align:center;">标记字段长度偏移列表中每个列对应的偏移量是使用1字节还是2字节的。</td></tr> <tr><td style="text-align:center;">32-47</td> <td style="text-align:center;">next_record</td> <td style="text-align:center;">16</td> <td style="text-align:center;">表示下一条记录的相对位置</td></tr></tbody></table> <p>与 COMPACT 行格式的记录头信息相比：</p> <p>REDUNDANT 行格式多了 n_field和 1byte_offs_flag两个属性。减掉了record_type这个属性。</p> <h4 id="溢出列"><a href="#溢出列" class="header-anchor">#</a> 溢出列</h4> <p>即一页的数据为16KB，大概为16384字节。如果一列的数据超过了这个数据，就会存在溢出问题。对于这种情况，真实的数据会分散存储在其他几个页中，然后在记录的真实数据处用20字节存储指向这些页的地址。</p> <ol><li>产生溢出页的临界点</li></ol> <p>MySQL中规定一个页中至少存放两行记录。</p> <p>每个页除了存放我们的记录以外，也需要存储一些额外的信息，这些信息加起来需要132字节的空间。而每条记录又需要额外的27字节(2字节用于存储真实数据的长度，1字节用于存储列是否是NULL值，5字节大小的头信息，6字节的row_id列，6字节的trx_id列，7字节的roll_pointer列)。</p> <p>如果该列不发生溢出现象，则需要满足</p> <div class="language- extra-class"><pre class="language-text"><code>132 + 2 * (27 + n) &lt; 16384

=&gt;     n &lt; 8099
</code></pre></div><h4 id="dynamic-行格式和-compressed-行格式"><a href="#dynamic-行格式和-compressed-行格式" class="header-anchor">#</a> DYNAMIC 行格式和 COMPRESSED 行格式</h4> <p>MySQL版本5.7，默认行格式就是 DYNAMIC. 这两个行格式与COMPACT 行格式挺像。只不过在处理溢出列有分歧：不会在记录的真实数据处存储该溢出列真实数据的前少部分数据。而是把该列所有真实数据都存储到溢出页中，只在记录的真实数据处存储20字节大小的指向溢出页的地址。</p> <p>COMPRESSED 不同于 DYNAMIC 的一点是， COMPRESSED行格式会采用压缩算法对页面进行压缩，以节省空间。</p> <h3 id="innodb数据页结构"><a href="#innodb数据页结构" class="header-anchor">#</a> InnoDB数据页结构</h3> <p>InnoDB页数据页结构主要包含以下几部分：</p> <ol><li>38字节的 File Header 文件头部</li></ol> <p>页的一些通用信息。</p> <table><thead><tr><th style="text-align:center;">状态名称</th> <th style="text-align:center;">大小</th> <th style="text-align:center;">描述</th></tr></thead> <tbody><tr><td style="text-align:center;">FIL_PAGE_SPACE_OR_CHKSUM</td> <td style="text-align:center;">4字节</td> <td style="text-align:center;">4.0.14版本之前，表示本页面所在的表空间id，之后表示页的校验和</td></tr> <tr><td style="text-align:center;">FIL_PAGE_OFFSET</td> <td style="text-align:center;">4字节</td> <td style="text-align:center;">页号</td></tr> <tr><td style="text-align:center;">FIL_PAGE_PREV</td> <td style="text-align:center;">4字节</td> <td style="text-align:center;">上一个页的页号</td></tr> <tr><td style="text-align:center;">FIL_PAGE_NEXT</td> <td style="text-align:center;">4字节</td> <td style="text-align:center;">下一个页的页号</td></tr> <tr><td style="text-align:center;">FIL_PAGE_LSN</td> <td style="text-align:center;">8字节</td> <td style="text-align:center;">页面被最后修改时对应的LSN(Log Sequence Number, 日志序列号)值</td></tr> <tr><td style="text-align:center;">FIL_PAGE_TYPE</td> <td style="text-align:center;">2字节</td> <td style="text-align:center;">该页的类型</td></tr> <tr><td style="text-align:center;">FIL_PAGE_FILE_FLUSH_LSN</td> <td style="text-align:center;">8字节</td> <td style="text-align:center;">仅在系统表空间的第一个页中定义，代表文件至少被刷新到了对应的LSN值</td></tr> <tr><td style="text-align:center;">FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID</td> <td style="text-align:center;">8字节</td> <td style="text-align:center;">页属于哪个表空间</td></tr></tbody></table> <p>重要字段：</p> <p>a). FIL_PAGE_OFFSET</p> <p>页号，4字节，即32位，则最大有2的32次方个页信息。默认16KB来算，最多支持64TB的数据。</p> <p>b). FIL_PAGE_TYPE。</p> <p>页类型有</p> <table><thead><tr><th style="text-align:center;">类型名称</th> <th style="text-align:center;">十六进制</th> <th style="text-align:center;">描述</th></tr></thead> <tbody><tr><td style="text-align:center;">FIL_PAGE_TYPE_ALLOCATED</td> <td style="text-align:center;">0X0000</td> <td style="text-align:center;">最新分配，还未使用</td></tr> <tr><td style="text-align:center;">FIL_PAGE_UNDO_LOG</td> <td style="text-align:center;">0X0002</td> <td style="text-align:center;">undo日志页</td></tr> <tr><td style="text-align:center;">FIL_PAGE_INODE</td> <td style="text-align:center;">0X0003</td> <td style="text-align:center;">存储段的信息</td></tr> <tr><td style="text-align:center;">FIL_PAGE_IBUF_FREE_LIST</td> <td style="text-align:center;">0X0004</td> <td style="text-align:center;">Change Buffer空闲列表</td></tr> <tr><td style="text-align:center;">FIL_PAGE_IBUF_BITMAP</td> <td style="text-align:center;">0X0005</td> <td style="text-align:center;">Change Buffer的一些属性</td></tr> <tr><td style="text-align:center;">FIL_PAGE_TYPE_SYS</td> <td style="text-align:center;">0X0006</td> <td style="text-align:center;">存储一些系统数据</td></tr> <tr><td style="text-align:center;">FIL_PAGE_TYPE_TRX_SYS</td> <td style="text-align:center;">0X0007</td> <td style="text-align:center;">事务系统数据</td></tr> <tr><td style="text-align:center;">FIL_PAGE_TYPE_FSP_HDR</td> <td style="text-align:center;">0X0008</td> <td style="text-align:center;">表空间头部信息</td></tr> <tr><td style="text-align:center;">FIL_PAGE_TYPE_XDES</td> <td style="text-align:center;">0X0009</td> <td style="text-align:center;">存储区的一些属性</td></tr> <tr><td style="text-align:center;">FIL_PAGE_TYPE_BLOB</td> <td style="text-align:center;">0X000A</td> <td style="text-align:center;">溢出页</td></tr> <tr><td style="text-align:center;">FIL_PAGE_INDEX</td> <td style="text-align:center;">0X45BF</td> <td style="text-align:center;">索引页，也就是我们所说的数据页</td></tr></tbody></table> <ol start="2"><li>56字节的 Page Header 页面头部</li></ol> <p>数据页专有的一些信息。</p> <p>为了得到存储再数据页中的记录的状态信息，比如数据页中已经存储了多少条记录，Free Space再页面中的地址偏移量，页目录中存储了多少个槽等信息，而增加了Page Header 部分。</p> <table><thead><tr><th style="text-align:center;">状态名称</th> <th style="text-align:center;">大小</th> <th style="text-align:center;">描述</th></tr></thead> <tbody><tr><td style="text-align:center;">PAGE_N_DIR_SLOTS</td> <td style="text-align:center;">2字节</td> <td style="text-align:center;">在页目录中槽的数量</td></tr> <tr><td style="text-align:center;">PAGE_HEAP_TOP</td> <td style="text-align:center;">2字节</td> <td style="text-align:center;">还未使用的空间最小地址，也就是说从该地址之后就是Free Space</td></tr> <tr><td style="text-align:center;">PAGE_N_HEAP</td> <td style="text-align:center;">2字节</td> <td style="text-align:center;">第一位表示本记录是否尾紧凑型的记录，剩余的15位表示本页中的堆中记录的数量(包括Infimum 和 supremum记录以及标记为&quot;已删除&quot;的记录)</td></tr> <tr><td style="text-align:center;">PAGE_FREE</td> <td style="text-align:center;">2字节</td> <td style="text-align:center;">各个已删除的记录通过next_record组成一个单向链表，这个单向链表中的记录所占用的存储空间可以被重新利用。PAGE_FREE表示该链表头节点对应记录在页面中的偏移量</td></tr> <tr><td style="text-align:center;">PAGE_GARBAGE</td> <td style="text-align:center;">2字节</td> <td style="text-align:center;">已删除记录占用的字节数</td></tr> <tr><td style="text-align:center;">PAGE_LAST_INSERT</td> <td style="text-align:center;">2字节</td> <td style="text-align:center;">最后插入记录的位置</td></tr> <tr><td style="text-align:center;">PAGE_DIRECTION</td> <td style="text-align:center;">2字节</td> <td style="text-align:center;">记录插入的方向</td></tr> <tr><td style="text-align:center;">PAGE_N_DIRECTION</td> <td style="text-align:center;">2字节</td> <td style="text-align:center;">一个方向连续插入的记录数量</td></tr> <tr><td style="text-align:center;">PAGE_N_RECS</td> <td style="text-align:center;">2字节</td> <td style="text-align:center;">该页中用户记录的数量(不包括 Infimum 和 Supremum 记录以及被删除的记录)</td></tr> <tr><td style="text-align:center;">PAGE_MAX_TRX_ID</td> <td style="text-align:center;">8字节</td> <td style="text-align:center;">修改当前页的最大事务id，该值仅在二级索引页面中的定义</td></tr> <tr><td style="text-align:center;">PAGE_LEVEL</td> <td style="text-align:center;">2字节</td> <td style="text-align:center;">当前页在B+树种所处的层级</td></tr> <tr><td style="text-align:center;">PAGE_INDEX_ID</td> <td style="text-align:center;">8字节</td> <td style="text-align:center;">索引ID,表示当前页属于哪些索引</td></tr> <tr><td style="text-align:center;">PAGE_BTR_SEG_LEAF</td> <td style="text-align:center;">10字节</td> <td style="text-align:center;">B+树叶子节点段的头部信息，仅在B+树的根页面种定义，对应相应的段</td></tr> <tr><td style="text-align:center;">PAGE_BTR_SEG_TOP</td> <td style="text-align:center;">10字节</td> <td style="text-align:center;">B+树非叶子节点段的头部信息，仅在B+树的根页面种定义，对应相应的段</td></tr></tbody></table> <ol start="3"><li>26字节的 Infimum + Supremum (记录) 页面中最小记录和最大记录</li></ol> <p>两个虚拟的记录。</p> <p>两条记录由InnoDB创建，该记录中的heap_no分别为0和1.</p> <p>每条记录由 5个字节的头部信息和8个字节的固定单词组成。</p> <ol start="4"><li>不确定字节的 User Recrds (记录) 用户记录</li></ol> <p>用户存储的记录内容。</p> <p>各记录之间用next_record进行连接。heap_no不断进行增加。</p> <ol start="5"><li>不确定字节的 Free Space 空闲空间</li></ol> <p>页中尚未使用的空间。</p> <ol start="6"><li>不确定字节的 Page Directory 页目录</li></ol> <p>页中某些记录的相对位置。</p> <p>将用户的记录制作了一个类似字典的目录。</p> <p>a). 将所有正常的记录(包括 Infimum 和 Supremum记录，但不包括已经移除到垃圾链表中的记录)划分为几个组。</p> <p>b). 每个组的最后一条记录(组内最大的那条记录)相当于&quot;带头答个&quot;，组内其余的记录相当于小弟，&quot;带头大哥&quot;记录的头信息中的n_owned属性表示改组共有几条记录。</p> <p>c). 将每组的最后一条在页面中的地址偏移量(该记录的真实数据与页面中第0各字节之间的距离)单独提取出来，按顺序到靠近页尾部的地方。这个地方就是Page Directory。页目录中的这些地址偏移量成为槽(Slot), 每个槽占用2字节。页目录就是由多个槽组成。</p> <p>InnoDB对每个分组条数是由规定的：对于Infimum记录所在的分组只能有1条记录，Supremum记录所在的分组拥有的记录条数只能在1-8条之间，剩下的分组中记录的条数范围只能是在4-8条之间。</p> <p>具体步骤如下：</p> <p>a). 在初始情况下，一个数据页中只有Infimum记录和Supremum记录在页面中的地址偏移量。</p> <p>b). 之后没=每插入一条记录，都会从页目录中找到对应记录的主键值比待插入记录的主键值大，并且差值最小的槽，然后把该槽对应的记录的n_owned值加1，直到该组的记录数等于8个。</p> <p>当一个组中记录数等于8后，再插入一条记录，会将组中的记录拆成两个组，其中一个组4条记录，另一个5条记录。这个拆分过程会在页目录中新增一个槽，记录这个新增分组中最大的那条记录的偏移量。</p> <ol start="7"><li>8字节的 File Trailer 文件尾部。</li></ol> <p>检验页是否完整。</p> <p>主要分为两个部分：</p> <p>a). 前4字节代表页的校验和。这个部分与File Header种的校验和相对应。每当一个页面在内存种发生修改时，在刷新之前就要把页面的校验和算出来。File Header中的校验和会被首先刷新到磁盘，当完全写完后，校验和也会被写到页的尾部。如果页面刷新成功，则页首和页尾的校验和应该是一致的。如果刷新了一部分后断电了，就会导致File Header 和 File Trailer校验和不一致。</p> <p>b). 后4字节代表页面被最后修改时对应的LSN的后4字节，正常情况下应该与File Header 部分的 FIL_PAGE_LSN的后4字节相同。</p> <h3 id="mysql的数据目录"><a href="#mysql的数据目录" class="header-anchor">#</a> MySQL的数据目录</h3> <h4 id="mysql数据目录"><a href="#mysql数据目录" class="header-anchor">#</a> MySQL数据目录</h4> <ol><li>数据目录和安装目录的区别</li></ol> <p>安装目录是指我们安装MySQL的目录。</p> <p>数据目录是指存储MySQL在运行过程中产生的数据。</p> <ol start="2"><li>如何查看数据目录地址</li></ol> <p>本质是一个系统环境变量。</p> <p>在MySQL命令行可以通过</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">show</span> variables <span class="token operator">like</span> <span class="token string">'datadir'</span><span class="token punctuation">;</span>
</code></pre></div><p>进行查看</p> <h4 id="数据目录的结构"><a href="#数据目录的结构" class="header-anchor">#</a> 数据目录的结构</h4> <ol><li>数据库在文件系统中的表示</li></ol> <p>每当我们创建一个数据库时，MySQL会帮我们做两件事：</p> <p>a). 在数据目录创建一个与数据库名同名的子目录。</p> <p>b). 在与该数据库名同名的子目录下创建一个名为db.opt的文件。这个文件包含了该数据库的一些属性，比如数据库的字符集和比较规则。</p> <ol start="2"><li>表在文件系统中的表示</li></ol> <p>a). 表结构的定义</p> <p>b). 表中的数据</p> <p>InnoDB时如何存储表数据的：</p> <p>(1) 系统表空间(system tablespace)</p> <p>这个系统表空间可以对应文件系统上一个或多个实际的文件。默认情况下，InnoDB会在数据目录下创建一个名为ibdata1,大小为12MB的文件，对应系统表空间在文件系统上的表示。</p> <p>(2) 独立表空间(file-per-table tablespace)</p> <p>5.6.6以及之后的版本，InnoDB不再默认把各个表的存储到系统表空间，而是每个表建立一个独立表空间。扩展名为.ibd</p> <h4 id="文件系统对数据库的影响"><a href="#文件系统对数据库的影响" class="header-anchor">#</a> 文件系统对数据库的影响</h4> <p>a). 数据库名称和表名不能超过文件系统所允许的最大长度</p> <p>b). 特殊字符的问题</p> <p>c). 文件长度受文件系统最大长度的限制</p> <h4 id="mysql系统数据库介绍"><a href="#mysql系统数据库介绍" class="header-anchor">#</a> MySQL系统数据库介绍</h4> <p>a). mysql. 存储了MySQL的用户账户和权限信息，一些存储过程和事件的定义信息，一些运行过程中产生的日志信息，一些帮助信息以及时区信息等。</p> <p>b). information_schema. 这个数据库保存着MySQL服务器维护的所有其他数据库的信息，比如有哪些表，哪些视图，哪些触发器，哪些列，哪些索引等。</p> <p>c). performance_schama. 这个数据库主要保存MySQL服务器运行过程中的一些状态信息，算是对MySQL服务器的一个性能监控。它包含的信息有统计最近执行了哪些语句，在执行过程中每个阶段花费了多长时间，内存的使用情况等。</p> <p>d). sys. 这个数据库主要时通过视图的形式把infomation_schema和performance_schema结合起来。让开发人员更方便的了解MySQL服务器的性能信息。</p> <h3 id="innodb的表空间"><a href="#innodb的表空间" class="header-anchor">#</a> InnoDB的表空间</h3> <h4 id="独立表空间结构"><a href="#独立表空间结构" class="header-anchor">#</a> 独立表空间结构</h4> <ol><li>区的概念</li></ol> <p>表空间最多能有2^32次方个页，为了更好的管理这些页，提出了区。对于16KB的页来说，连续的64个页就是一个区，也就是说一个区默认占用1MB空间大小。每256个区域被划分为一组。</p> <p>第一个组最开始的3个页面的类型是固定的。分别为：</p> <p>a). FSP_HDR: 这个类型的页面用来登记整个表空间的一些整体属性以及本组所有的区的属性。整个表空间只有一个FSP_HDR类型的页面。</p> <p>b). IBUF_BITMAP: 这个类型的页面用来存储关于 Change Buffer的一些信息。</p> <p>c). INODE: 存储了许多称为INODE Entry的数据结构。</p> <p>其余各组最开始的2个页面的类型是固定的。分别为：</p> <p>a). XDES: 全称是 extent descriptor。用来登记本组256个区的属性。</p> <p>b). IBUF_BITMAP. 同上。</p> <ol start="2"><li>段的概念</li></ol> <p>一个区就是在物理位置上连续的64个页(区里页面的页号都是连续的)。在表中的数据量很大时，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照区为单位进行分配。甚至在表中的数据非常非常多的时候，可以一次性分配多个连续的区。</p> <p>B+树执行查询时只是在扫描叶子节点的记录，而如果不区分叶子节点和非叶子节点，把节点代表的页面放到申请的曲中，扫描效果就大打折扣了.InnoDB对B+树的叶子节点和非叶子节点进行了区别对象。叶子节点有自己独有的区，非叶子节点也有自己独有的区。存放叶子节点的区的集合就算是一个段。存放非叶子节点的区的集合也算是一个段。</p> <p>索引会生成两个段：一个叶子节点段和一个非叶子节点段。</p> <p>段是以区为单位申请存储空间的，一个区默认占用1MB存储空间。为了防止插入一条数据就申请一个区，造成空间的浪费。提出了碎片区的概念。</p> <p>碎片区：在一个碎片区中，并不是所有的页都是为了存储同一个段的数据而存在的，碎片区的页可以用于不同的目的，有些页属于段A，有些属于段B。</p> <ol start="3"><li>区的分类</li></ol> <p>a). 空闲的区   FREE</p> <p>现在还没用到这个区的任何页面</p> <p>b). 有剩余空闲页面的碎片区。 FREE_FRAG</p> <p>表示碎片区中还有可被分配的空闲页面。</p> <p>c). 没有剩余空闲页面的碎片区。 FULL_FRAG</p> <p>没有剩余空闲页面的碎片区，表示碎片区中的所有页面都被分配使用，没有空闲页面。</p> <p>d). 附属于某个段的区。 FSEG</p> <p>还会定义一些特殊用途的段。数据量特别大时，将使用区作为分配单位，完全用于存储该段中的数据。</p> <p>为了方便管理这些区，设计了一个 XDES Entry(Extent Descriptor Entry)的结构。每一个区都对应着一个XDES Entry结构。</p> <p>一个 XDES Entry主要包含以下几个部分：</p> <p>a). 8字节的Segment ID</p> <p>每一个段都有一个唯一的编号，用ID表示，表示该区所在的段，前提是该区已经被分配给某个段，不然该字段没有意义</p> <p>b). 12字节的List Node</p> <p>将若干个XDES Entry结构串成一个链表。存在前后两个指针</p> <p>c). 4字节的State</p> <p>表明区的状态。</p> <p>d). 16字节的Page State Bitmap</p> <p>16字节，128位。一个区默认64个页，128位被划分为64各部分，每个部分有两位，对应区中的一个页。</p> <ol start="4"><li>XDES Entry 链表</li></ol> <p>1). 向某个段插入数据时，申请新页面的过程</p> <p>a). 当段中数据较少时，首先会查看表空间中是否有状态为 FREE_FRAG的区。如果存在，从该区取一些零散页把数据插进去。否则到表空间中申请一个状态为FREE的区。把该区的状态变成FREE_FRAG，然后从该申请的曲中去一个零散页把数据插进去。</p> <p>b). 之后，不同的段使用零散页的时候从该区区，直到该区中没有空闲页面。将状态变成FULL_FRAG.</p> <p>所以引出:</p> <p>如何直到哪些区时FREE, 哪些区是FREE_FRAG，哪些区是FULL_FRAG的。不可能一个一个遍历，进行状态判断。</p> <p>通过List Node把状态为FREE的区对应的XDES Entry结构连城一个链表，这个链表称为FREE链表。</p> <p>通过List Node把状态为FREE_FRAG的区对应的XDES Entry结构连接成一个链表，这个链表称为FULL_FRAG链表。</p> <p>则到时候只要去查链表头部即可。</p> <p>2). 为了知道哪些区属于哪个段。</p> <p>每个段中，会根据SegmentID找到对应的区的XDES Entry建立三个链表。</p> <p>a). FREE链表：同一个段中，所有页面都是空闲页面的区对应的XDES Entry结构会被加入到这个链表中。</p> <p>b). NOT_FULL链表：同一个段中，仍有空闲页面的区对应的XDES Entry结构会被加入到这个链表。</p> <p>c). FULL链表，同一个段中，已经没有空闲页面的区对应的XDES Entry结构会被加入到这个链表。</p> <p>所以一个除了主键的表中会有 2(段) * 3(每个段维护的链表) + 3(直属于表空间的3个链表) = 9个链表。</p> <p>3). 链表基节点</p> <p>为了方便找到这些节点，提出了 List Base Node(链表基节点)的结构。</p> <p>主要包含以下数据：</p> <p>a. List Length 该链表长度. 4字节</p> <p>b. First Node Page Number 4字节 和 First Node Offset 2字节 表明了该链表的头节点在表空间中的位置。</p> <p>c. Last Node Page Number 4字节 和 Last Node Offset 2字节 表明了该链表的尾节点在表空间的位置。</p> <p>4). 段的结构</p> <p>INODE Entry结构记录段的一些信息。段是由一些零散页面和一些完整的区的集合。</p> <p>属性如下：</p> <p>a). SegmentID: 8字节，这个INODE Entry结构对应的段的编号(ID)</p> <p>b). NOT_FULL_N_USED: 4字节，在NOT_FULL链表中已经使用了多少个页面</p> <p>c). 3个List Base Node: 16 * 3字节 分别为段的FREE链表，NOT_FULL链表，FULL链表定义了List Base Node。</p> <p>d). Magic Number: 4字节，用来标记这个INODE Entry是否已经被初始化。如果这个数字是97937874，则表明已经被初始化，否则没有被初始化。</p> <p>e). Fragment Array Entry: 4 * 32字节。表示一个零散页面的页号。</p> <p>5). 各类型页面详细情况</p> <p>a). FSP_HDR类型</p> <p>第一个组的第一个页面，也是表空间的第一个页面，页号为0. 存储了表空间的一些整体属性以及第一个组内256个区对应的XDES Entry结构。</p> <p>FSP_HDR的页面由五部分组成：</p> <table><thead><tr><th style="text-align:center;">名称</th> <th style="text-align:center;">中文名</th> <th style="text-align:center;">占用空间大小(字节)</th> <th style="text-align:center;">描述</th></tr></thead> <tbody><tr><td style="text-align:center;">File Header</td> <td style="text-align:center;">文件头部</td> <td style="text-align:center;">38</td> <td style="text-align:center;">页的一些通用信息</td></tr> <tr><td style="text-align:center;">File Space Header</td> <td style="text-align:center;">表空间头部</td> <td style="text-align:center;">112</td> <td style="text-align:center;">表空间的一些整体属性信息</td></tr> <tr><td style="text-align:center;">XDES Entry</td> <td style="text-align:center;">区描述信息</td> <td style="text-align:center;">10240</td> <td style="text-align:center;">存储本组256个区对应的属性信息</td></tr> <tr><td style="text-align:center;">Empty Space</td> <td style="text-align:center;">尚未使用的空间</td> <td style="text-align:center;">5986</td> <td style="text-align:center;">页剩余部分</td></tr> <tr><td style="text-align:center;">File Trailer</td> <td style="text-align:center;">文件尾部</td> <td style="text-align:center;">8</td> <td style="text-align:center;">校验页是否完整</td></tr></tbody></table> <p>其中重要的有</p> <p>File Space Header</p> <table><thead><tr><th style="text-align:center;">名称</th> <th style="text-align:center;">占用空间大小(字节)</th> <th style="text-align:center;">描述</th></tr></thead> <tbody><tr><td style="text-align:center;">Space ID</td> <td style="text-align:center;">4</td> <td style="text-align:center;">表空间的ID</td></tr> <tr><td style="text-align:center;">Not Used</td> <td style="text-align:center;">4</td> <td style="text-align:center;">未被使用，可以忽略</td></tr> <tr><td style="text-align:center;">Size</td> <td style="text-align:center;">4</td> <td style="text-align:center;">当前表空间拥有的页面数</td></tr> <tr><td style="text-align:center;">FREE Limit</td> <td style="text-align:center;">4</td> <td style="text-align:center;">尚未被初始化的最小页号，大于或等于这个页号的区对应的XDES Entry结构都没有被加入FREE链表</td></tr> <tr><td style="text-align:center;">Space Flags</td> <td style="text-align:center;">4</td> <td style="text-align:center;">表空间的一些占用存储空间比较小的属性</td></tr> <tr><td style="text-align:center;">FRAG_N_USED</td> <td style="text-align:center;">4</td> <td style="text-align:center;">FREE_FRAG 链表中已使用的页面数量</td></tr> <tr><td style="text-align:center;">List Base Node for FREE list</td> <td style="text-align:center;">16</td> <td style="text-align:center;">FREE链表的基节点</td></tr> <tr><td style="text-align:center;">List Base Node for FREE_FRAG list</td> <td style="text-align:center;">16</td> <td style="text-align:center;">FREE_FRAG链表的基节点</td></tr> <tr><td style="text-align:center;">List Base Node for FULL_FRAG list</td> <td style="text-align:center;">16</td> <td style="text-align:center;">FULL_FRAG链表的基节点</td></tr> <tr><td style="text-align:center;">NEXT Unused Segment ID</td> <td style="text-align:center;">8</td> <td style="text-align:center;">当前表空间中下一个未使用的Segment ID</td></tr> <tr><td style="text-align:center;">List Base Node for SEG_INODES_FULL List</td> <td style="text-align:center;">16</td> <td style="text-align:center;">SEG_INODES_FULL链表的基节点</td></tr> <tr><td style="text-align:center;">List Base Node for SEG_INODES_FREE List</td> <td style="text-align:center;">16</td> <td style="text-align:center;">SEG_INODES_FREE链表的基节点</td></tr></tbody></table> <p>XDES Entry</p> <p>XDES Entry就存储在表空间的第一个页面中，一个XDES Entry结构的大小是40个字节，由于一个页面大小有限，所以把256个区华为一组。</p> <p>b). XDES类型</p> <p>除开第一组外的各组的第一个页面类型定义为XDES类型。与FSP_HDR类型相似，但是没有File Space Header部分以外，其他部分都一样。</p> <p>c). IBUF_BITMAP类型</p> <p>记录Change Buffer有关的信息。</p> <p>插入数据时，需要找聚簇索引页面，然后再找二级索引页。这些页面在表空间是随机分布的。将产生大量的随机I/O，严重影响性能。</p> <p>所以引入Change Buffer的结构。本质上是一颗表空间的B+树。</p> <p>如果该页面尚未被加载到内存中，那么修改将被暂时缓存到Change Buffer中。后续服务器空闲或者其他情况下，再将其加载到内存中，再将修改合并。</p> <p>d). INODE类型</p> <p>记录了段的相关属性。</p> <table><thead><tr><th style="text-align:center;">名称</th> <th style="text-align:center;">中文名</th> <th style="text-align:center;">占用空间大小(字节)</th> <th style="text-align:center;">描述</th></tr></thead> <tbody><tr><td style="text-align:center;">File Header</td> <td style="text-align:center;">文件头部</td> <td style="text-align:center;">38</td> <td style="text-align:center;">页的一些通用信息</td></tr> <tr><td style="text-align:center;">List Node for INODE Page List</td> <td style="text-align:center;">通用链表节点</td> <td style="text-align:center;">12</td> <td style="text-align:center;">存储上一个INODE页面和下一个INODE页面的指针</td></tr> <tr><td style="text-align:center;">INODE Entry</td> <td style="text-align:center;">段描述信息</td> <td style="text-align:center;">16320</td> <td style="text-align:center;">具体的INODE Entry结构</td></tr> <tr><td style="text-align:center;">Empty Space</td> <td style="text-align:center;">尚未使用的空间</td> <td style="text-align:center;">6</td> <td style="text-align:center;">页剩余部分</td></tr> <tr><td style="text-align:center;">File Trailer</td> <td style="text-align:center;">文件尾部</td> <td style="text-align:center;">8</td> <td style="text-align:center;">校验页是否完整</td></tr></tbody></table> <h4 id="系统表空间"><a href="#系统表空间" class="header-anchor">#</a> 系统表空间</h4> <p>全局只有一个。</p> <p>与独立表空间不同之处，就是在表空间开头有许多记录整个系统属性的页面。</p> <table><thead><tr><th style="text-align:center;">页号</th> <th style="text-align:center;">页面类型</th> <th style="text-align:center;">英文描述</th> <th style="text-align:center;">描述</th></tr></thead> <tbody><tr><td style="text-align:center;">3</td> <td style="text-align:center;">SYS</td> <td style="text-align:center;">Insert Buffer Header</td> <td style="text-align:center;">存储Change Buffer的头部信息</td></tr> <tr><td style="text-align:center;">4</td> <td style="text-align:center;">INDEX</td> <td style="text-align:center;">Insert Buffer Root</td> <td style="text-align:center;">存储Change BUffer的根页面</td></tr> <tr><td style="text-align:center;">5</td> <td style="text-align:center;">TRX_SYS</td> <td style="text-align:center;">Transction System</td> <td style="text-align:center;">事务系统的相关信息</td></tr> <tr><td style="text-align:center;">6</td> <td style="text-align:center;">SYS</td> <td style="text-align:center;">First Rollback Segment</td> <td style="text-align:center;">第一个回滚段的信息</td></tr> <tr><td style="text-align:center;">7</td> <td style="text-align:center;">SYS</td> <td style="text-align:center;">Data Dictionary Header</td> <td style="text-align:center;">数据字典头部信息</td></tr></tbody></table> <h3 id="单表访问方法"><a href="#单表访问方法" class="header-anchor">#</a> 单表访问方法</h3> <ol><li>const</li></ol> <p>通过主键或者唯一二级索引与常数的值进行等值比较来定位一条记录时，称为const。</p> <ol start="2"><li>ref</li></ol> <p>某个普通的二级索引列与常数进行等值比较，找多多条连续的记录，称为ref。</p> <ol start="3"><li>ref_or_null</li></ol> <p>某个普通的二级索引列与常数进行等值比较，且想找出为Null的值，扫描区间为['xx','xx']和[NULL,NULL];</p> <p>称为ref_or_null.</p> <p>NULL记录会被放在索引的最左边。</p> <ol start="4"><li>range</li></ol> <p>使用普通的二级索引，扫描区间有多个，称为range</p> <ol start="5"><li>index</li></ol> <p>使用普通二级索引，扫描区间为(-∞, +∞)时为index。</p> <ol start="6"><li>all</li></ol> <p>全表扫描</p> <ol start="7"><li>注意事项</li></ol> <p>a). 二级索引 + 回表操作，会增加I/O</p> <p>b). 索引合并</p> <p>一般情况下，MySQL只会为单个索引生成扫描区间。但是某些特殊情况下，MySQL也可能为多个索引生成扫描区间。</p> <p>具体索引合并有三种：</p> <ul><li>Intersection 索引合并 (交集)</li></ul> <div class="language-sql extra-class"><pre class="language-sql"><code>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> table1 <span class="token keyword">where</span> index_key1 <span class="token operator">=</span> <span class="token string">'a'</span> <span class="token operator">and</span> index_key2 <span class="token operator">=</span> <span class="token string">'b'</span><span class="token punctuation">;</span>
</code></pre></div><p>上述语句，如果单纯使用index_key1索引或者index_key2的索引步骤为：先使用index_key1找到值为'a'的数据，然后进行回表，回表后再根据index_key2等于'b'进行数据过滤。</p> <p>此种情况下可以同时使用index_key1和index_key2进行查询。使用index_key1中扫描值为'a'的数据，同时使用index_key2扫描找到值为'b'的数据，然后从两者的操作结果中找出id列值相同的记录。再通过这些id执行回表操作。</p> <div class="language- extra-class"><pre><code>- Union 索引合并 (并集)
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>
select * from table1 where index_key1 = 'a' or index_key2 = 'b';
</code></pre></div><p>上述语句，如果单纯使用index_key1索引或者index_key2肯定不行，因为或的原因，最终会进行全表扫描</p> <p>可以同时使用index_key1和index_key2进行搜索。最终取并集，在进行回表操作。</p> <div class="language- extra-class"><pre><code>- Sort-Union 索引合并
</code></pre></div><p>Union索引和并的使用条件太苛刻，必须保证从各个索引中扫描到的记录的主键值是有序的。</p> <p>所以出现了Sort-Union索引合并，对分别使用索引获取到的集合id，进行排序，然后再进行Union索引合并方式。</p> <h3 id="连接的原理"><a href="#连接的原理" class="header-anchor">#</a> 连接的原理</h3> <h4 id="笛卡尔积"><a href="#笛卡尔积" class="header-anchor">#</a> 笛卡尔积</h4> <p>将两个表的数据进行连接，a表有m条数据，b表有n条数据，则最终的表有 m*n条数据。</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1<span class="token punctuation">,</span>t2 <span class="token keyword">where</span> t1<span class="token punctuation">.</span>m1 <span class="token operator">&gt;</span> <span class="token number">1</span> <span class="token operator">and</span> t1<span class="token punctuation">.</span>m1 <span class="token operator">=</span> t2<span class="token punctuation">.</span>m2 <span class="token operator">and</span> t2<span class="token punctuation">.</span>n2 <span class="token operator">&lt;</span> <span class="token string">'d'</span>
</code></pre></div><p>有三个条件</p> <div class="language- extra-class"><pre class="language-text"><code>t1.m1 &gt; 1

t1.m1 = t2.m2

t2.n2 &lt; 'd'
</code></pre></div><p>连接步骤如下：</p> <ol><li>首先确定第一个需要查询的表，这个表称为驱动表</li></ol> <p>通过这个表的匹配条件进行查询。假设选取t1为驱动表，t1.m1 &gt; 1作为查询条件</p> <ol start="2"><li>步骤1中从驱动表每获取到一条记录，都需要到t2表中查找匹配的记录。</li></ol> <h4 id="内连接和外连接"><a href="#内连接和外连接" class="header-anchor">#</a> 内连接和外连接</h4> <ol><li><p>内连接的两张表，如果驱动表在被驱动表找不到匹配的记录，则该记录不会加入到最后的结果集中。</p></li> <li><p>外连接的两张表，即使驱动表的记录在被驱动中没有记录，也需要加入到结果集中。分为左外连接(选取左侧的表为驱动表)和右外连接(选取右侧的表为驱动表)。</p></li></ol> <p>Where子句中的过滤条件：</p> <p>只要是不符合过滤条件的记录都不会加入到最后的结果集。</p> <p>On子句中的过滤条件：</p> <p>如果被驱动表中找不到匹配ON子句中过滤条件的记录，仍会被加入结果集中。</p> <p>外连接语句</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1 <span class="token punctuation">[</span><span class="token keyword">left</span> <span class="token operator">|</span> <span class="token keyword">right</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token keyword">outer</span><span class="token punctuation">]</span> <span class="token keyword">JOIN</span> t2 <span class="token keyword">ON</span> 连接条件 <span class="token punctuation">[</span><span class="token keyword">where</span> 普通过滤条件<span class="token punctuation">]</span>
</code></pre></div><p>内连接语句</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1 <span class="token punctuation">[</span><span class="token keyword">inner</span> <span class="token operator">|</span> <span class="token keyword">cross</span><span class="token punctuation">]</span> <span class="token keyword">join</span> t2 <span class="token punctuation">[</span><span class="token keyword">on</span> 连接条件<span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token keyword">where</span> 普通过滤条件<span class="token punctuation">]</span>
</code></pre></div><p>对于内连接来说，凡是不符合ON子句和Where子句中条件记录都会被过滤掉。</p> <h4 id="连接的原理-2"><a href="#连接的原理-2" class="header-anchor">#</a> 连接的原理</h4> <ol><li>嵌套循环连接</li></ol> <p>对于两表连接来说，驱动表只会被访问一遍，但被驱动表却要被访问多遍。具体多少次取决于对驱动表执行单表查询后的结果集中有多少条记录。</p> <p>这是最简单也是最笨拙的一种连接查询算法。</p> <ol start="2"><li>使用索引加快连接速度</li></ol> <p>在嵌套循环连接中可能需要多次访问被驱动表。而对于驱动表的扫描相当于是单表扫描。所以可以尝试在被驱动表上增加索引，增加被驱动表的查询速度。</p> <ol start="3"><li>基于块的嵌套循环连接</li></ol> <p>把被驱动表中的记录加载到内存时，一次性地驱动表中地多条记录进行批量。大大减少重复从磁盘加载被驱动表地代价。</p> <p>因此MySQL提出了Join Buffer(连接缓冲区)。就是在执行连接查询前申请地一块固定大小地内存。把若干条驱动表结果集中地记录装在这个Join Buffer中，然后开始扫描被驱动表，每一条被驱动表地记录一次性地与Join Buffer中地多条驱动表记录进行匹配。</p> <h3 id="基于成本的优化"><a href="#基于成本的优化" class="header-anchor">#</a> 基于成本的优化</h3> <h4 id="单表查询的成本"><a href="#单表查询的成本" class="header-anchor">#</a> 单表查询的成本</h4> <ol><li>基于成本的优化步骤</li></ol> <p>a). 根据索引条件，找出所有可能使用的索引</p> <p>b). 计算全表扫描的代价</p> <p>c). 计算使用不同索引执行查询的代价</p> <p>d). 对比各种执行方案的代价，找出成本最低的哪个方案</p> <ol start="2"><li>如何找到最优的方案</li></ol> <p>a). 根据搜索条件，找出所有可能使用的索引</p> <p>b). 计算全表扫描的代价 = I/O成本 + CPU 成本。</p> <p>而I/O成本 + CPU成本需要两个信息：</p> <p>聚簇索引占用的页面数 和 该表中的记录数。</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">show</span> <span class="token keyword">table</span> <span class="token keyword">STATUS</span><span class="token punctuation">;</span>

<span class="token operator">|</span> Name    <span class="token operator">|</span> <span class="token keyword">Engine</span> <span class="token operator">|</span> Version <span class="token operator">|</span> Row_format <span class="token operator">|</span> <span class="token keyword">Rows</span>  <span class="token operator">|</span> Avg_row_length <span class="token operator">|</span> Data_length <span class="token operator">|</span> Max_data_length <span class="token operator">|</span> Index_length <span class="token operator">|</span> Data_free <span class="token operator">|</span> <span class="token keyword">Auto_increment</span> <span class="token operator">|</span> Create_time         <span class="token operator">|</span> Update_time <span class="token operator">|</span> Check_time <span class="token operator">|</span> Collation   <span class="token operator">|</span> Checksum <span class="token operator">|</span> Create_options <span class="token operator">|</span> <span class="token keyword">Comment</span> <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">---------+--------+---------+------------+-------+----------------+-------------+-----------------+--------------+-----------+----------------+---------------------+-------------+------------+-------------+----------+----------------+---------+</span>
<span class="token operator">|</span> tb_test <span class="token operator">|</span> <span class="token keyword">InnoDB</span> <span class="token operator">|</span>      <span class="token number">10</span> <span class="token operator">|</span> Dynamic    <span class="token operator">|</span>     <span class="token number">2</span> <span class="token operator">|</span>           <span class="token number">8192</span> <span class="token operator">|</span>       <span class="token number">16384</span> <span class="token operator">|</span>               <span class="token number">0</span> <span class="token operator">|</span>            <span class="token number">0</span> <span class="token operator">|</span>         <span class="token number">0</span> <span class="token operator">|</span> <span class="token boolean">NULL</span>           <span class="token operator">|</span> <span class="token number">2021</span><span class="token operator">-</span><span class="token number">09</span><span class="token operator">-</span><span class="token number">15</span> <span class="token number">12</span>:<span class="token number">59</span>:<span class="token number">16</span> <span class="token operator">|</span> <span class="token boolean">NULL</span>        <span class="token operator">|</span> <span class="token boolean">NULL</span>       <span class="token operator">|</span> utf8mb4_bin <span class="token operator">|</span> <span class="token boolean">NULL</span>     <span class="token operator">|</span>                <span class="token operator">|</span>         <span class="token operator">|</span>
<span class="token operator">|</span> tb_user <span class="token operator">|</span> <span class="token keyword">InnoDB</span> <span class="token operator">|</span>      <span class="token number">10</span> <span class="token operator">|</span> Dynamic    <span class="token operator">|</span> <span class="token number">12432</span> <span class="token operator">|</span>             <span class="token number">32</span> <span class="token operator">|</span>      <span class="token number">409600</span> <span class="token operator">|</span>               <span class="token number">0</span> <span class="token operator">|</span>       <span class="token number">294912</span> <span class="token operator">|</span>         <span class="token number">0</span> <span class="token operator">|</span> <span class="token boolean">NULL</span>           <span class="token operator">|</span> <span class="token number">2021</span><span class="token operator">-</span><span class="token number">09</span><span class="token operator">-</span><span class="token number">15</span> <span class="token number">13</span>:<span class="token number">06</span>:<span class="token number">18</span> <span class="token operator">|</span> <span class="token boolean">NULL</span>        <span class="token operator">|</span> <span class="token boolean">NULL</span>       <span class="token operator">|</span> utf8mb4_bin <span class="token operator">|</span> <span class="token boolean">NULL</span>     <span class="token operator">|</span>                <span class="token operator">|</span>         <span class="token operator">|</span>

</code></pre></div><p>可以使用该命令查看具体的表信息。</p> <p>其中Rows： 表示表中的记录条数。对于MyISAM存储引擎的表来说，是准确的。对于使用InnoDB存储引擎的表来说，该值是一个估计值，从聚簇索引中选取几个叶子节点页面，统计每个页面中包含额记录数量，然后计算一个页面中平均包含的记录数量，然后再乘以全部叶子节点的数量。</p> <p>Data_length: 表示表占用的存储空间字节数。对于使用MyISAM存储引擎的表来说，该值就是数据文件的大小；对于使用InnoDB存储引擎的表来说，该值就相当于聚簇索引占用的存储空间大小。</p> <p>Data_length = 聚簇索引的页面数量 * 每个页面的大小。</p> <p>所以I/O成本 = 页面数量 * 1.0 + 1.1 ;</p> <p>1.0指的是加载一个页面的成本常数，后面的1.1是微调值。</p> <p>CPU成本 = rows * 0.2 + 1.0 ;</p> <p>0.2 指的是访问一条记录所需要的成本数，后面的1.0是微调值。</p> <p>c). 计算使用不同索引执行查询的代价</p> <p>对于使用二级索引 + 回表方式执行的查询，主要依赖于两方面的数据：扫描区间数量和需要回表的记录数。</p> <div class="language- extra-class"><pre class="language-text"><code>1. 扫描区间的数量

无论某个扫描区间的二级索引到底占用了多少页面，查询优化器粗暴地认为读取索引地一个扫描区间地I/O成本与读取一个页面的I/O成本是相同的。

2. 需要回表的记录数

查询优化器需要计算二级索引的某个扫描区间到底包含多少条记录，

步骤如下：

a). 先根据扫描区间找到满足条件的第一条记录(区间最左记录)

b). 根据扫描区间找到满足条件的最后一条记录(区间最右记录)

c). 如果两个记录像个不远(不大于10个页面即可)。既可以精确统计出满足条件的所有条数。

统计两个记录之间页面的数量，是通过目录页进行计算的。

</code></pre></div><p>回表操作成本计算，每次回表操作相当于一次页面访问。有多少次回表，就有多少次I/O成本。</p> <p>总成本为：I/O成本 + CPU成本</p> <p>I/O成本 = 1.0 + 回表数量 * 1.0 (扫描区间的数量 + 预估的二级索引记录条数)</p> <p>CPU成本 = 读取二级索引记录的成本 + 读取并检测回表操作后聚簇索引记录的成本。</p> <p>读取二级索引记录的成本 = 预估的二级索引记录条数 * 0.2 + 0.01.</p> <p>读取并检测回表操作后聚簇索引记录的成本 = 预估的回表次数 * 0.2;</p> <ol start="3"><li>基于索引统计数据的成本计算</li></ol> <p>通过直接访问索引对应的B+树来计算某个扫描区间内对应的索引记录条数的方式称为index dive.</p> <p>MySQL为每个表的每个索引维护一份统计数据。</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">show</span> <span class="token keyword">index</span> <span class="token keyword">from</span> table_name



<span class="token operator">|</span> <span class="token keyword">Table</span>   <span class="token operator">|</span> Non_unique <span class="token operator">|</span> Key_name      <span class="token operator">|</span> Seq_in_index <span class="token operator">|</span> Column_name <span class="token operator">|</span> Collation <span class="token operator">|</span> Cardinality <span class="token operator">|</span> Sub_part <span class="token operator">|</span> Packed <span class="token operator">|</span> <span class="token boolean">Null</span> <span class="token operator">|</span> Index_type <span class="token operator">|</span> <span class="token keyword">Comment</span> <span class="token operator">|</span> Index_comment <span class="token operator">|</span> Visible <span class="token operator">|</span> Expression <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">---------+------------+---------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+</span>
<span class="token operator">|</span> tb_user <span class="token operator">|</span>          <span class="token number">0</span> <span class="token operator">|</span> <span class="token keyword">PRIMARY</span>       <span class="token operator">|</span>            <span class="token number">1</span> <span class="token operator">|</span> id          <span class="token operator">|</span> A         <span class="token operator">|</span>       <span class="token number">12432</span> <span class="token operator">|</span> <span class="token boolean">NULL</span>     <span class="token operator">|</span> <span class="token boolean">NULL</span>   <span class="token operator">|</span>      <span class="token operator">|</span> <span class="token keyword">BTREE</span>      <span class="token operator">|</span>         <span class="token operator">|</span>               <span class="token operator">|</span> YES     <span class="token operator">|</span> <span class="token boolean">NULL</span>       <span class="token operator">|</span>
<span class="token operator">|</span> tb_user <span class="token operator">|</span>          <span class="token number">1</span> <span class="token operator">|</span> idx_user_name <span class="token operator">|</span>            <span class="token number">1</span> <span class="token operator">|</span> user_name   <span class="token operator">|</span> A         <span class="token operator">|</span>        <span class="token number">3000</span> <span class="token operator">|</span> <span class="token boolean">NULL</span>     <span class="token operator">|</span> <span class="token boolean">NULL</span>   <span class="token operator">|</span> YES  <span class="token operator">|</span> <span class="token keyword">BTREE</span>      <span class="token operator">|</span>         <span class="token operator">|</span>               <span class="token operator">|</span> YES     <span class="token operator">|</span> <span class="token boolean">NULL</span>       <span class="token operator">|</span>
<span class="token operator">|</span> tb_user <span class="token operator">|</span>          <span class="token number">1</span> <span class="token operator">|</span> idx_age       <span class="token operator">|</span>            <span class="token number">1</span> <span class="token operator">|</span> age         <span class="token operator">|</span> A         <span class="token operator">|</span>        <span class="token number">3000</span> <span class="token operator">|</span> <span class="token boolean">NULL</span>     <span class="token operator">|</span> <span class="token boolean">NULL</span>   <span class="token operator">|</span> YES  <span class="token operator">|</span> <span class="token keyword">BTREE</span>      <span class="token operator">|</span>         <span class="token operator">|</span>               <span class="token operator">|</span> YES     <span class="token operator">|</span> <span class="token boolean">NULL</span>       <span class="token operator">|</span>
</code></pre></div><p>相关字段说明</p> <table><thead><tr><th style="text-align:center;">属性名</th> <th style="text-align:center;">描述</th></tr></thead> <tbody><tr><td style="text-align:center;">Table</td> <td style="text-align:center;">该列所属索引所在的表名</td></tr> <tr><td style="text-align:center;">Non_unique</td> <td style="text-align:center;">该列所属索引是否是唯一索引。1表示唯一索引</td></tr> <tr><td style="text-align:center;">Key_name</td> <td style="text-align:center;">该列所属索引的名称</td></tr> <tr><td style="text-align:center;">Seq_in_index</td> <td style="text-align:center;">该列在索引包含的列中的位置，从1开始计数</td></tr> <tr><td style="text-align:center;">Column_name</td> <td style="text-align:center;">该列的名称</td></tr> <tr><td style="text-align:center;">Collation</td> <td style="text-align:center;">该列中的值是按照某个排序方式存放的，A表示升序</td></tr> <tr><td style="text-align:center;">Cardinality</td> <td style="text-align:center;">该列中不重复值的数量</td></tr> <tr><td style="text-align:center;">sub_part</td> <td style="text-align:center;">只想对前n个字符建立索引</td></tr> <tr><td style="text-align:center;">Packed</td> <td style="text-align:center;">如何被压缩</td></tr> <tr><td style="text-align:center;">Null</td> <td style="text-align:center;">是否允许为null</td></tr> <tr><td style="text-align:center;">Index_type</td> <td style="text-align:center;">该索引的类型</td></tr> <tr><td style="text-align:center;">Comment</td> <td style="text-align:center;">额外信息</td></tr> <tr><td style="text-align:center;">Index_commit</td> <td style="text-align:center;">创建索引时，给所以加的备注</td></tr></tbody></table> <p>所以使用in的估算方法为：</p> <p>计算一个值的重复次数大约等于 rows / Cardinality.</p> <p>所以随着in里面数据的增多，则大概估算即为 n * rows / Cardinality 的数据量。而这些时需要回表的。</p> <p>此方法比较快，但是不精确。</p> <h4 id="连接查询的成本"><a href="#连接查询的成本" class="header-anchor">#</a> 连接查询的成本</h4> <ol><li>条件过滤</li></ol> <p>MySQL中连接查询采用的是桥套循环连接算法，驱动表会访问一次，被驱动表可能会被访问多次。</p> <p>所以查询成本为：</p> <p>a). 单词查询驱动表的成本</p> <p>b). 多次查询被驱动表的成本(具体查询多少次取决于针对驱动表查询后的结果集中有多少条记录)。</p> <p>把查询驱动表后得到的记录条数称为驱动表的扇出(fanout)。驱动表扇出值越小，对被驱动表的查询次数也就越小，连接查询的总成本也就越低。</p> <p>而计算扇出值，需要靠猜测：</p> <p>a). 如果使用全表扫描的方式执行单表查询，那么计算驱动表扇出值时需要猜测满足全部搜索条件的记录到底有多少条。</p> <p>b). 如果使用索引来执行单表查询，那么计算驱动表扇出值时需要猜测除了满足形成索引扫描区间的索引条件外，还满足其他搜索条件的记录有多少条。</p> <p>底层相当复杂</p> <ol start="2"><li>两表连接的成本分析</li></ol> <p>连接查询的成本 = 单词访问驱动表的成本 + 驱动表扇出值 * 单词访问被驱动表的成本</p> <p>对于左外连接和右外连接，驱动表固定，只需要计算一次即可。</p> <p>对于内连接来说，驱动表和被驱动表的位置可以呼唤，需要考虑：当不同的表作为驱动表时，最终的查询成本可能不同，也就是需要考虑最优的表连接顺序。然后分别为驱动表和被驱动表选择成本最低的访问方法。</p> <p>优化重点：</p> <p>a). 尽量减少驱动表的扇出</p> <p>b). 访问被驱动表的成本要尽量低。</p> <ol start="3"><li>多表连接的成本分析</li></ol> <p>a). 提前结束某种连接顺序的成本评估</p> <p>维护全局变量x，表示当前最小的连接查询成本。如果某次小于该值，则直接结束</p> <p>b). 系统变量oprimizer_search_depth</p> <p>如果连接表的个数小于该值，则穷举每一种连接顺序。否则值对该值相同的表进行穷举分析。</p> <p>c). 某些规则不考虑某些连接顺序。</p> <h3 id="基于规则的优化"><a href="#基于规则的优化" class="header-anchor">#</a> 基于规则的优化</h3> <h4 id="条件化简"><a href="#条件化简" class="header-anchor">#</a> 条件化简</h4> <ol><li><p>移除不必要的括号</p></li> <li><p>常量传递</p></li> <li><p>移除没用的条件</p></li> <li><p>表达式计算</p></li> <li><p>HAVING子句和WHERE子句的合并</p></li></ol> <p>如果查询语句没有出现诸如SUM, MAX这样的聚集函数以及GROUP BY子句，查询优化器就把HAVING子句和WHERE子句的合并</p> <ol start="6"><li>常量表检测</li></ol> <h4 id="外连接消除"><a href="#外连接消除" class="header-anchor">#</a> 外连接消除</h4> <p>外连接中ON不会把匹配的删除掉，而内连接会把ON中不匹配的删除掉。</p> <p>我们再Where 子句中的搜索条件指定&quot;被驱动表的列不为NULL&quot;的搜索，那么外连接中被驱动表中找不到符合ON子句条件的驱动表记录也就从最后的结果集中被排除了。此时和外连接结果会和内连接一样了。</p> <h4 id="子查询优化"><a href="#子查询优化" class="header-anchor">#</a> 子查询优化</h4> <p>子查询语法。将一个查询语句放在 select , from, where, on子句中。</p> <ol><li>子查询注意事项：</li></ol> <p>a). 子查询必须用小括号括起来</p> <p>b). 在SELECT 子句中的子查询必须时标量子查询。</p> <p>c). 某些子查询为集合时，排序，去重是没有意义的</p> <p>d). 进行增删改时，不需要进行子查询</p> <ol start="2"><li>子查询在MySQL中时怎么执行的</li></ol> <p>a). 标量子查询，行子查询的执行方式</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> s1 <span class="token keyword">where</span> key1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">select</span> common_field <span class="token keyword">from</span> s2 <span class="token keyword">where</span> key3 <span class="token operator">=</span> <span class="token string">'a'</span> <span class="token keyword">limit</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>执行步骤：</p> <div class="language- extra-class"><pre class="language-text"><code>1. 单独执行 (select common_field from s2 where key3 = 'a' limit 1) 这个子查询

2. 然后将子查询得到的结果当作外层查询参数，再执行 select * from s1 where key1 =
</code></pre></div><div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> s1 <span class="token keyword">where</span> keys1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">select</span> common_field <span class="token keyword">from</span> s2 <span class="token keyword">where</span> s1<span class="token punctuation">.</span>key3 <span class="token operator">=</span> s2<span class="token punctuation">.</span>key3 <span class="token keyword">limit</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
</code></pre></div><p>执行步骤：</p> <div class="language- extra-class"><pre class="language-text"><code>1. 从外层查询获取一条记录

2. 从这条记录中找出子查询中涉及的值

3. 最后根据子查询的查询结果来检测外层查询WHERE子句的条件是否成立。如果成立，就把外层查询的那条记录加入到结果集，否则就丢弃。

4. 跳到步骤1，知道外层查询中获取不到记录为止。
</code></pre></div><p>b). in子查询的优化</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> s1 <span class="token keyword">where</span> key1 <span class="token operator">in</span> <span class="token punctuation">(</span><span class="token keyword">select</span> common_field <span class="token keyword">from</span> s2 <span class="token keyword">where</span> key3 <span class="token operator">=</span>  <span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>对于不想关的子查询，子查询结果集的记录条数很少，那么把子查询和外层查询分别看成两个单独的单表查询，效率还是蛮高的。</p> <p>如果结果集太多，可能会导致内存放不下，胡总和无法有效的使用索引。</p> <p>所以MySQL决定，不直接将不相关子查询的结果集当作外层查询的参数，而是将该结果集写入一个临时表中：该临时表的列就是子查询结果集中的列。写入临时表的记录会去重。</p> <p>一般情况下，子查询结果集不会大的离谱，会基于内存的使用MEMORY存储引擎的临时表，而且会为该表建立哈希索引。</p> <p>如果子查询的结果集非常大，超过了系统变量tmp_table_size 或者 max_heap_table_size的值。临时表会转而使用基于磁盘的存储引擎来保存结果集中的记录，索引类型也会转为B+树(物化表)。</p> <p>转成物化表后就会转成内连接。查询优化器评估不同连接顺序需要的成本是多少，然后选择最低成本的那种方式来执行查询。</p> <p>总成本如下:</p> <div class="language- extra-class"><pre class="language-text"><code>如果外表作为驱动表：
1. 物化子查询时需要的成本

2. 扫描s1表时的成本

3. s1表中的记录数量 * 通过条件 m_val = xxx对 物化表进行单表访问的晨报

如果物化表作为驱动表：
1. 物化子查询需要的成本

2. 扫描物化表时的成本

3. 物化表中的记录数量 * 通过条件key1=xxx对s1表进行单表访问的成本

</code></pre></div><p>子查询转化为半连接：</p> <p>即不生成物化表，进行sql优化</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">select</span> s1<span class="token punctuation">.</span><span class="token operator">*</span> <span class="token keyword">from</span> s1 semi <span class="token keyword">join</span> s2 <span class="token keyword">on</span> s1<span class="token punctuation">.</span>key1 <span class="token operator">=</span> s2<span class="token punctuation">.</span>common_field <span class="token keyword">where</span> key3 <span class="token operator">=</span> <span class="token string">'a'</span> 
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>半连接为MySQL内部的实现。

主要实现方式有

1. Table pullout(子查询中的表上拉)

2. Duplicate Weedout(重复值消除)

3. LooseScan (松散扫描)

4. Semi-join Materialization(半连接物化)

5. FirstMatch (首次匹配)

半连接的适用条件：

1. 子查询必须是与IN操作符组成的布尔表达式，并且再外层查询的WHERE 或者 ON子句中出现

2. 外层查询可以有其他的搜索条件，只不过必须使用AND操作符与IN子查询的搜索条件连接起来

3. 子查询必须是一个单一的查询，不能由UNION连接起来的若干个查询

4. 子查询不能包含GROUP BY,HAVING语句或者聚集函数。

</code></pre></div><p>如果IN子查询符合转化为半连接的条件，查询优化器会优先把该子查询转化为半连接，在考虑从半连接的五种实现方式中找出成本最低的。</p> <p>如果IN子查询不符合转化为半连接的条件，那么会从先将子查询物化，再执行查询 和 执行IN到EXISTS的转化。</p> <h3 id="explain详解"><a href="#explain详解" class="header-anchor">#</a> EXPLAIN详解</h3> <p>使用explain 查询一个sql的执行计划。</p> <p>主要有以下属性：</p> <table><thead><tr><th style="text-align:center;">列名</th> <th style="text-align:center;">描述</th></tr></thead> <tbody><tr><td style="text-align:center;">id</td> <td style="text-align:center;">在一个大的查询语句中，每个select关键字对应一个唯一id</td></tr> <tr><td style="text-align:center;">select_type</td> <td style="text-align:center;">select关键字对应的查询的类型</td></tr> <tr><td style="text-align:center;">table</td> <td style="text-align:center;">表名</td></tr> <tr><td style="text-align:center;">partitions</td> <td style="text-align:center;">匹配的分区信息</td></tr> <tr><td style="text-align:center;">type</td> <td style="text-align:center;">针对单表的访问方法</td></tr> <tr><td style="text-align:center;">possible_keys</td> <td style="text-align:center;">可能用到的索引</td></tr> <tr><td style="text-align:center;">key</td> <td style="text-align:center;">实际使用的索引</td></tr> <tr><td style="text-align:center;">key_len</td> <td style="text-align:center;">实际使用的索引长度</td></tr> <tr><td style="text-align:center;">ref</td> <td style="text-align:center;">当使用索引等值查询时，与索引列进行等值匹配的对象信息</td></tr> <tr><td style="text-align:center;">rows</td> <td style="text-align:center;">预估需要读取的记录条数</td></tr> <tr><td style="text-align:center;">filtered</td> <td style="text-align:center;">针对预估没经过搜索条件过滤后剩余记录条数的百分比</td></tr> <tr><td style="text-align:center;">Extra</td> <td style="text-align:center;">一些额外的信息</td></tr></tbody></table> <h4 id="字段详细说明"><a href="#字段详细说明" class="header-anchor">#</a> 字段详细说明</h4> <ol><li>table</li></ol> <p>无论查询中有多少个表，都会被拆成对单表的查询。</p> <ol start="2"><li>id</li></ol> <p>一个id 分别对应一条查询语句。</p> <ol start="3"><li>select_type</li></ol> <p>主要有以下的类型：</p> <table><thead><tr><th style="text-align:center;">类型</th> <th style="text-align:center;">描述</th></tr></thead> <tbody><tr><td style="text-align:center;">SIMPLE</td> <td style="text-align:center;">查询语句中不包含UNION或者子查询</td></tr> <tr><td style="text-align:center;">PRIMARY</td> <td style="text-align:center;">对于包含了UNION, UNION ALL或者子查询的大查询来说，它是由几个小查询组成的，其中最走遍的那个查询的select_type为PRIMARY</td></tr> <tr><td style="text-align:center;">UNION</td> <td style="text-align:center;">对于包含UNION或者UNION ALL的大查询来说，除了最左边的Select以外，其他小查询的select_type就是 UNION</td></tr> <tr><td style="text-align:center;">UNION RESULT</td> <td style="text-align:center;">使用临时表来完成UNION查询的去重工作，针对于临时表的查询select_type为UNION RESULT</td></tr> <tr><td style="text-align:center;">SUBQUERY</td> <td style="text-align:center;">如果包含子查询的查询语句不能够转为对应的半连接形式，并且该连接的子查询是不相关子查询，该子查询的第一个SELECT 关键字代表的那个查询</td></tr> <tr><td style="text-align:center;">DEPENDENT SUBQUERY</td> <td style="text-align:center;">如果包含子查询的查询语句不能够转为对应的半连接形式，并且该子查询被查询优化器转换为相关子查询的形式，该子查询的第一个SELECT 关键字代表的那个查询</td></tr> <tr><td style="text-align:center;">DEPENDENT UNION</td> <td style="text-align:center;">包含UNION或者UNION ALL的大查询中，如果各个小查询都依赖于外层查询，则除了最左边的那个小查询之外，其余小查询的select_type都是DEPENDENT UNION</td></tr> <tr><td style="text-align:center;">DERIVED</td> <td style="text-align:center;">在派生表查询中，如果是以物化派生表的方式执行查询，派生表对应的子查询</td></tr> <tr><td style="text-align:center;">MATERIALIZED</td> <td style="text-align:center;">当查询优化器在执行包含子查询的语句时，选择将子查询物化之后与外层查询进行连接查询</td></tr> <tr><td style="text-align:center;">UNCACHEABLE SUBQUERY</td> <td style="text-align:center;">不常用</td></tr> <tr><td style="text-align:center;">UNCACHEABLE UNION</td> <td style="text-align:center;">不常用</td></tr></tbody></table> <ol start="4"><li>partitions</li></ol> <p>分区表才会出现的</p> <ol start="5"><li>type</li></ol> <p>前面有讲过InnoDB存储引擎的表进行单表访问的一些访问方法。完整的为： system，const，eq_ref，ref，fulltext，ref_or_null, index_merge, unique_subquery, index_subquery, range, index, all.</p> <p>下面介绍上面未谈到的。</p> <p>a). system</p> <p>当表中只有一条记录并且该表的存储引擎(比如MyISAM，MEMORY)的统计数据时精确的，那么对该表的访问方法就是system。</p> <p>b). eq_ref</p> <p>连接查询时，被驱动表是通过主键或者不允许存储NULL值的唯一二级索引列等值匹配的方式进行访问的。</p> <p>c). fulltext</p> <p>全文索引</p> <p>d). index_merge</p> <p>某些场景下会使用索引合并</p> <p>e). unique_subquery: 针对的是一些包含in子查询的查询语句，如果查询优化器决定将in子查询转换为EXISTS子查询，而且子查询再转换之后可以使用主键或者不允许存储NULL值的唯一二级索引进行等值匹配。</p> <p>f). index_subquery: 与unique_subquery类似，只不过再访问子查询中的表时使用的是普通索引。</p> <ol start="6"><li>key_len</li></ol> <p>希望从执行条件中看出形成扫描区间的边界条件是什么。</p> <p>主要由三部分组成</p> <p>a). 该列的实际数据最多占用的存储空间长度。</p> <p>b). 如果该列可以存储NULL值，则key_len值再该列的实际数据最多占用的存储空间长度的基础上再加1字节。</p> <p>c). 对于使用变成类型的列来说，都会有2两字节的空间来存储该列的实际数据占用的存储空间长度。key_len还要加上这2字节。</p> <p>比如varchar(100), utf8,则实际数据最多占用 3 * 100个字节。允许为NULL，再加1。是变长类型的类，再加2.</p> <ol start="7"><li>ref</li></ol> <p>当访问方法是const, eq_ref,ref, ref_or_null, unique_subquery, index_subquery中的其中一个时，ref列展示的就是与索引列进行等值匹配的东西是啥。</p> <ol start="8"><li>rows</li></ol> <p>查询优化器决定使用全表扫描的方式对某个表执行查询时，代表该表的估计行数。</p> <p>如果使用索引来执行查询，执行计算的rows列就是预计扫描的索引记录行数。</p> <ol start="9"><li>filtered</li></ol> <p>如果使用全表扫描的方式来执行单表查询，那么计算驱动表扇出时需要估计出满足全部搜索条件的记录到底有多少条。</p> <p>如果使用索引来执行单表扫描，那么计算驱动表扇出时需要估计出在满足形成索引扫描区间的搜索条件外，还满足其他搜索条件的记录有多少条。</p> <ol start="10"><li>Extra</li></ol> <p>额外信息。</p> <p>主要有如下信息</p> <table><thead><tr><th style="text-align:center;">内容</th> <th style="text-align:center;">描述</th></tr></thead> <tbody><tr><td style="text-align:center;">No tables used</td> <td style="text-align:center;">当查询语句中没有FROM子句时将会提示该额外信息</td></tr> <tr><td style="text-align:center;">Impossible WHERE</td> <td style="text-align:center;">查询语句的WHERE子句永远为False时会提示该信息</td></tr> <tr><td style="text-align:center;">No matching min/max row</td> <td style="text-align:center;">当查询列表处有min或者max聚集函数，但是并没有记录符合where子句的搜索条件时</td></tr> <tr><td style="text-align:center;">using index</td> <td style="text-align:center;">使用覆盖索引执行查询时</td></tr> <tr><td style="text-align:center;">Using index condition</td> <td style="text-align:center;">有些搜索条件中虽然出现了索引列，但却不能充当边界条件来形成扫描区间</td></tr> <tr><td style="text-align:center;">Using where</td> <td style="text-align:center;">当某个搜索条件需要在server层进行判断时</td></tr> <tr><td style="text-align:center;">using join buffer</td> <td style="text-align:center;">当被驱动表不能有效地利用索引加快访问速度时，一般会分配一块连接缓冲区地内存块加快查询</td></tr> <tr><td style="text-align:center;">using intersect(),using union(), using sort_union()</td> <td style="text-align:center;">进行了索引合并</td></tr> <tr><td style="text-align:center;">zero limit</td> <td style="text-align:center;">当limit子句地参数为0时</td></tr> <tr><td style="text-align:center;">using filesort</td> <td style="text-align:center;">对结果集进行排序</td></tr> <tr><td style="text-align:center;">using temporary</td> <td style="text-align:center;">借助临时表完成group by，去重操作，使用了内部临时表</td></tr> <tr><td style="text-align:center;">start temporary</td> <td style="text-align:center;">查询优化器会优先尝试将in子查询转换成半连接。使用了Duplicate weedout策略</td></tr> <tr><td style="text-align:center;">LooseScan</td> <td style="text-align:center;">查询优化器会优先尝试将in子查询转换成半连接。使用了LooseScan策略</td></tr> <tr><td style="text-align:center;">FirstMatch</td> <td style="text-align:center;">查询优化器会优先尝试将in子查询转换成半连接。使用了FirstMatch策略</td></tr></tbody></table> <p>explain format = json xxx 表示将查询结果转为json。</p> <p>可以看到查询的成本。</p> <h3 id="optimizer-trace"><a href="#optimizer-trace" class="header-anchor">#</a> optimizer trace</h3> <p>可以让用户方便的查看优化器生成执行计划的整个过程。</p> <p>由系统变量optimizer_trace 控制开启还是关闭。</p> <h4 id="开启"><a href="#开启" class="header-anchor">#</a> 开启</h4> <p>进行查看：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">show</span> variables <span class="token operator">like</span> <span class="token string">'optimizer_trace'</span>
</code></pre></div><p>进行修改：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">set</span> optimizer_trace <span class="token operator">=</span> <span class="token string">&quot;enabled=on,one_line=off&quot;</span>
</code></pre></div><p>执行sql</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> user_name <span class="token operator">=</span> <span class="token string">'3000'</span> <span class="token operator">and</span> age <span class="token operator">=</span> <span class="token number">2000</span> <span class="token operator">and</span> id <span class="token operator">&gt;</span> <span class="token number">3000</span><span class="token punctuation">;</span>
</code></pre></div><p>查看优化过程</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> information_schema<span class="token punctuation">.</span>OPTIMIZER_TRACE<span class="token punctuation">;</span>
</code></pre></div><p>主要有四个字段：</p> <ol><li><p>query : 表示我们输入的查询语句</p></li> <li><p>trace： 优化过程的json格式的文本</p></li> <li><p>MISSING_BYTES_BEYOND_MAX_MEM_SIZE: 在执行计划生成过程中可能会输出很多能从，多余的文本将不被显示。该字段表示被忽略的文本字节数。</p></li> <li><p>INSUFFICIENT_PRIVILEGES: 表示是否有权限查看执行计划的生成过程。</p></li></ol> <p>可以通过trace进行分析。主要分为三个阶段：</p> <ol><li><p>准备阶段</p></li> <li><p>优化阶段</p></li> <li><p>执行阶段</p></li></ol> <h3 id="innodb的buffer-pool"><a href="#innodb的buffer-pool" class="header-anchor">#</a> InnoDB的Buffer Pool</h3> <h4 id="简介"><a href="#简介" class="header-anchor">#</a> 简介</h4> <ol><li>啥是Buffer Pool</li></ol> <p>为了缓存磁盘中的页，在MySQL服务器启动时就向操作系统申请了一片连续的内存，这片内存就叫做Buffer Pool。</p> <p>通过在配置文件my.ini中设置</p> <div class="language- extra-class"><pre class="language-text"><code>[server]
innodb_buffer_pool_size=268435456
</code></pre></div><p>单位为字节。最少为5M，设置低于5M，系统也会设置成5M。</p> <ol start="2"><li>Buffer Pool内部组成</li></ol> <p>Buffer Pool对应的一片连续的内存划分为若干个页面，页面大小与InnoDB表空间使用的页面大小一致，默认是16KB. 为了与磁盘中的页面区分开来，我们把这些Buffer Pool中的页面称为缓冲页。</p> <p>为了更好的管理，为每个缓冲页都创建了一些控制信息。这些控制信息包括页所属的表空间编号，页号，缓冲页在BufferPool中的地址，链表节点信息等。</p> <p>每个缓冲页对应的控制信息占用的内存大小是相同的，我们把每个页对应的控制信息占用的一块内存称为控制块。控制块与缓冲页是一一对应的，都存放在Buffer Pool中。其中控制块存放在Buffer Pool的前面，缓冲页存放在Buffer Pool的后面。</p> <ol start="3"><li>free链表的管理</li></ol> <p>从磁盘上读取一个页到Buffer Pool中时，该放到哪个缓冲页的位置呢。如何区分Buffer Pool中哪些缓冲页是空闲的，哪些是被使用的。</p> <p>把所有空闲的缓冲页对应的控制块作为一个节点放到链表中，这个链表也可以称为free链表(空闲链表)。刚刚完成初始化的Buffer Pool中，所有的缓冲页都是空闲的，所以每个缓冲页对应的控制块都会加入到free链表中。</p> <p>同事建立一个基节点，包含链表的头节点地址，尾节点地址，以及当前链表中节点的数量等信息。</p> <ol start="4"><li>缓冲页的哈希处理</li></ol> <p>当需要访问某个页的数据时，需要把该页从磁盘加载到Buffer Pool中。需要判断一个页是否在Buffer Pool中。</p> <p>所以使用 表空间号 + 页号来定位一个页，所以使用哈希表来保存表空间号+页号，value为缓冲页控制块。</p> <ol start="5"><li>flush链表的管理</li></ol> <p>如果修改了Buffer Pool中某个缓冲页的数据，它就与磁盘上的页不一致了，这样的缓冲页也称为脏页。为了提供性能，不让其修改完后立马刷新磁盘。引入了Flush链表。原理同free链表一样。但是存储的是脏页的控制块。</p> <ol start="6"><li>LRU链表的管理</li></ol> <p>a). 缓冲区不够</p> <p>如果缓存的页占比内存大小超过了Buffer Pool，即Free链表中没有空余的空闲缓冲页了。则需要把某些旧的缓冲页给移除掉。</p> <p>b). 简单的LRU链表</p> <p>所以为了移除一些缓冲页，则需要淘汰掉最近很少使用的部分缓冲页。则新增一个LRU链表</p> <p>如果该页不在Buffer Pool中，在把该页从磁盘加载到Buffer Pool中的缓冲页时，就把缓冲页对应的控制块作为节点塞到LRU链表的头部。</p> <p>如果该页已经被加载到Buffer Pool，则直接把该页对应的控制块移动到LRU链表的头部。</p> <p>c). 划分区域的LRU链表</p> <p>aa). InnoDB提供了预读服务，当我们用到某个页时，会把后面读取的某些页面也预先加载到Buffer Pool中</p> <p>分为线性预读： 提供了系统变量inndb_read_ahead_threshold, 如果顺序访问的某个区(extent)的页面超过这个值，会触发一次异步读取下一个区中全部的页面到Buffer Pool中的请求。默认为56</p> <p>随机预读：如果某个区的13个连续的页面都被加载到Buffer Pool中，无论这些页面是不是顺序读取的，都会触发一次异步读取本区中所有其他页面到Buffer Pool中的请求。innodb_random_read_ahead系统变量，默认false。</p> <p>ab). 进行全表扫描</p> <p>会导致其他语句刚执行完不久的页给直接移除了。</p> <p>所以可能会降低Buffer Pool的命中率：</p> <p>aa). 加载到Buffer Pool中的页不一定被用到</p> <p>ab). 如果有非常多的使用频率低的页面被同时加载到Buffer Pool中，则可能会把那些使用频率非常告的页也从Buffer Pool中淘汰了。</p> <p>所以针对这两个情况，把LRU分成两部分：</p> <p>aa). 一部分存储使用频率非常高的缓冲页，这一部分称为热数据。young区</p> <p>ab). 另一部分存储使用频率不是很高的缓冲页，这一部分称为冷数据。old区</p> <p>同时添加系统变量 innodb_old_blocks_pct的值来确定old区域所在LRU链表中所占的比例。默认为37%.</p> <p>有了两个区域后，则可以进行优化：</p> <p>aa). 针对预读</p> <p>当磁盘的某个页面在初次加载到Buffer Pool中的某个缓冲页时，该缓冲页对应的控制块会放到old区域的头部。</p> <p>ab). 针对全表扫描</p> <p>全表扫描，首次加载到Buffer Pool中的页放到old区头部，后续马上被访问到，才会放到young区的头部。</p> <p>其中马上被访问到的意思是：第一次加载的时候会记录这个访问时间，如果后续访问时间与第一次访问时间在某个时间段内，那么该页面就不会从old区域移动到young区域的头部。该时间段由系统变量 innodb_old_blocks_time控制，默认1秒。</p> <p>d). 更进一步优化LRU链表</p> <p>为了防止每次访问一个缓冲页就要把它移动到LRU链表的头部，这样开销太大。只有被访问的缓冲页位于young区域1/4的后面时，才会移动到LRU链表的头部。降低调整LRU链表的频率。</p> <ol start="7"><li>其他的一些链表</li></ol> <p>为了更好的管理Buffer Pool中的缓冲页，还有其他链表，比如管理解压页unzip LRU链表，用于管理压缩页的zip clean链表，zip free数组中每一个元素都代表一个链表，组成伙伴系统来为压缩页提供内存空间。</p> <ol start="8"><li>刷新脏页到磁盘</li></ol> <p>后台由专门的线程负责每隔一段时间把脏页刷新到磁盘。</p> <p>a). 从LRU链表的冷数据刷新一部分页面到磁盘</p> <p>定时从LRU链表尾部开始扫描一些页面，扫描的页面数量可以通过系统变量 inndb_lru_scan_depth来指定。BUF_FLUSH_LRU.</p> <p>b). 从flush链表中刷新一部分页面到磁盘</p> <p>刷新速率取决于当时系统是否繁忙。BUF_FLUSH_LIST.</p> <ol start="9"><li>多个Buffer Pool实例</li></ol> <p>在Buffer Pool 特别大时，对其进行拆分若干个小的Buffer Pool。都是独立的。服务器通过设置innodb_buffer_pool_instances 来修改BufferPool的实例个数。innodb_buffer_pool_size 小于1G时，始终为1.</p> <ol start="10"><li>配置Buffer Pool的注意事项</li></ol> <p>a). innodb_buffer_pool_size 必须是 innodb_buffer_pool_chunk_size(一个Buffer Pool实例中chunk的个数。用于在服务器运行期间修改buffer_pool的大小) * innodb_buffer_pool_instances的倍数</p> <ol start="11"><li>查看Buffer Pool的状态信息</li></ol> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">SHOW</span> <span class="token keyword">ENGINE</span> <span class="token keyword">INNODB</span> <span class="token keyword">STATUS</span>
</code></pre></div><p>会打印上面提到的很多信息。</p> <h3 id="事务"><a href="#事务" class="header-anchor">#</a> 事务</h3> <p>从innodb的执行流程可以看出很多过程是为了实现事务。</p> <p>事务即一连串操作，要么全部完成，要么全是失败。</p> <h4 id="事务的特性"><a href="#事务的特性" class="header-anchor">#</a> 事务的特性</h4> <p>ACID</p> <ul><li><p>原子性(Atomicity): 事务是一个不可分隔的整体，事务开始后所有操作要么全部成功，要么全部失败。通过undo log文件来保证。</p></li> <li><p>一致性(Consistency)：事务必须使数据库从一个一致性状态转化到另一个一致性状态。主要通过AID和业务流程来完成。</p></li> <li><p>隔离性(Isolation)：多个事务之间的隔离情况。主要通过MVCC和锁来实现。</p></li> <li><p>持久性(Durability)；提交后，数据会保存到数据库中，并且不能再回滚。通过redo log实现。</p></li></ul> <h4 id="事务状态"><a href="#事务状态" class="header-anchor">#</a> 事务状态</h4> <ol><li><p>活动的(active): 事务对应的数据库操作正在执行的过程。</p></li> <li><p>部分提交的(partially committed): 当事务中的最后一个操作执行完成，但由于操作都在内存中执行，所造成的影响并没有刷新到磁盘时，说该事务处于部分提交状态。</p></li> <li><p>失败的(failed): 当事务处于活动状态或者部分提交的状态时，可能遇到了某些错误而无法进行。</p></li> <li><p>中止的(aborted): 事务执行了半截而变为失败的状态。也为回滚，恢复到事务执行之前的状态。</p></li> <li><p>提交的(commited): 处于部分提交的事务将修改后的树都刷新到磁盘中。</p></li></ol> <h4 id="相关语法"><a href="#相关语法" class="header-anchor">#</a> 相关语法</h4> <p>开启事务：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">BEGIN</span> <span class="token punctuation">[</span><span class="token keyword">WORK</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></div><div class="language-SQL extra-class"><pre class="language-sql"><code><span class="token keyword">START</span> <span class="token keyword">TRANSACTION</span><span class="token punctuation">;</span>

<span class="token comment">-- 也是开启事务</span>

<span class="token comment">-- 后面可以跟几个修饰符 </span>
<span class="token comment">-- read only</span>
<span class="token comment">-- read wirte</span>
<span class="token comment">-- with consistent snapshot  启动一致性读</span>
</code></pre></div><p>提交事务：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">COMMIT</span> <span class="token punctuation">[</span><span class="token keyword">WORK</span><span class="token punctuation">]</span>
</code></pre></div><p>手动中止事务:</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">rollback</span> <span class="token punctuation">[</span><span class="token keyword">work</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></div><p>自动提交事务：</p> <p>由系统变量控制</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">show</span> variables <span class="token operator">like</span> <span class="token string">'autocommit'</span><span class="token punctuation">;</span>
</code></pre></div><p>默认开启。</p> <p>隐式提交：</p> <p>a). 隐式使用或修改mysql数据库中的表</p> <p>alter user, create user, drop user, grant, rename user, revoke, set password</p> <p>b). 事务控制或关于锁定的语句</p> <p>开启一个事务，则上一个事务会隐式提交。</p> <p>使用Lock TABLES, UNLOCK TABLES也会隐式提交前面语句所属事务。</p> <p>c). 加载数据的语句</p> <p>load data</p> <p>d). MySQL复制的一些语句</p> <p>start salve, stop slave, reset slave, change master to.</p> <p>e). 其他语句</p> <p>使用 analyze table, cache index, check table, fulsh, load index into cache, optimize table, repair table, reset等。</p> <p>保存点：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">savepoint</span> <span class="token punctuation">[</span>save_point_name<span class="token punctuation">]</span>
</code></pre></div><p>回滚到保存点：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">rollback</span> <span class="token punctuation">[</span><span class="token keyword">work</span><span class="token punctuation">]</span> <span class="token keyword">to</span> <span class="token punctuation">[</span><span class="token keyword">savepoint</span><span class="token punctuation">]</span> save_point_name
</code></pre></div><p>删除保存点：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">release</span> <span class="token keyword">savepoint</span> save_point_name
</code></pre></div><h3 id="redo-日志"><a href="#redo-日志" class="header-anchor">#</a> redo 日志</h3> <h4 id="redo-日志是啥"><a href="#redo-日志是啥" class="header-anchor">#</a> redo 日志是啥</h4> <p>为了防止Buffer Pool在未刷新磁盘前挂掉。而保证数据不丢失。我们需要把每次提交事务时把事务在内存中修改过的内容记录起来。而这个记录的地方就是redo log。也称重做日志。</p> <p>a). redo log 占用的空间非常小：在存储表空间ID,页号，偏移量以及需要更新的值时，需要的存储空间很小。</p> <p>b). 是顺序写入磁盘的。每执行一条语句，就会产生若干条redo日志。这些日志是按照产生顺序写入磁盘的。</p> <h4 id="redo-日志格式"><a href="#redo-日志格式" class="header-anchor">#</a> redo 日志格式</h4> <p>redo日志本质上只是记录了一下事务对数据库进行了哪些修改。针对事务对数据库的不同修改场景，定义了多种类型的redo日志，绝大部分类型的redo日志都是分为4个部分的通用结构。</p> <p>a). type: 这条redo日志的类型</p> <p>b). space ID: 表空间ID</p> <p>c). page number: 页号</p> <p>d). data: 这条redo 日志的具体内容</p> <ol><li>简单的redo日志类型</li></ol> <p>前文在介绍InnoDB记录行格式的时候说过，如果没有为某个表显示地定义主键，并且表中页没有定义不允许存储NULL值地UNIQUE键，那么InnoDB会自动为表添加一个名为row_id的隐藏列作为主键，为row_id隐藏列进行赋值的方式如下：</p> <p>a). 服务器会在内存中维护一个全局变量，每当向某个包含row_id隐藏列的表中插入一条记录时，就会把这个全局变量的值当作新记录的row_id列的值，并且把这个全局变量自增1.</p> <p>b). 每当这个全局变量的值为256的倍数时，就会将变量的值刷新到系统表空间页号为7的页面中一个名为Max Row ID(8字节)的属性中。</p> <p>c). 当系统启动时，会将这个Max Row ID属性加载到内存中，并将该值加上256之后赋值给前面提到的全局变量。</p> <p>而上面这个写入操作实际上是Buffer Pool中完成的。所以需要用redo 日志的形式记录下来。redo日志只需要记录一下在某个页面的某个偏移量处修改了几个字节的值，具体修改后的内容是啥就好了。</p> <p>根据写入的数据的多少划分了几种不同的redo日志类型：</p> <p>a). MLOG_1BYTE(type 字段对应的十进制数字为1)：表示在页面的某个偏移量处写入1字节的redo日志类型。</p> <p>b). MLOG_2BYTE(type 字段对应的十进制数字为2)：表示在页面的某个偏移量处写入2字节的redo日志类型。</p> <p>c). MLOG_4BYTE(type 字段对应的十进制数字为4)：表示在页面的某个偏移量处写入4字节的redo日志类型。</p> <p>d). MLOG_8BYTE(type 字段对应的十进制数字为8)：表示在页面的某个偏移量处写入8字节的redo日志类型。</p> <p>e). MLOG_WRITE_STRING(type 字段对应的十进制数字为30)：表示在页面的某个偏移量处写入一个字节序列。</p> <p>写入1字节，2字节，4字节，8字节其结构为:</p> <p>a). type</p> <p>b). space ID</p> <p>c). page number</p> <p>d). offeset</p> <p>e). 具体数据</p> <p>写入WRITE_STRING类型的日志结构谢日的为字节序列。不能确定写入的具体数据占用多少字节，所以在上面的基础上增加了 len 字段。</p> <ol start="2"><li>复杂一些的redo类型</li></ol> <p>一些语句需要修改非常多的页面，包括系统数据页面和用户数据页面(用户数据指的就是聚簇索引和二级索引对应的B+树)。</p> <p>以一条INSERT语句为例,需要关注的点：</p> <p>a). 表中包含多少个索引，一条INSERT语句就可能能更新多少颗B+树。</p> <p>b). 针对某一颗B+树来说，既可能更新叶子节点页面，也可能更新内节点页面，还可能创建新的页面。</p> <p>语句执行过程中，insert语句对所有页面的修改都会保存到redo日志中。而Insert添加一条数据，每往叶子节点代表的数据页中插入一条记录，还有很多地方都会跟着更新，比如：</p> <p>a). 可能更新Page Directory中的槽信息</p> <p>b). 可能更新 Page Header中的各种页面统计信息，比如 PAGE_N_DIR_SLOTS 表示的槽数量可能会修改， PAGE_HEAP_TOP 代表的还未使用的空间最小地址会修改， PAGE_N_HEAP代表的本页面中的记录数量可能会更改。</p> <p>c). 数据页中的记录按照索引列从小到大的顺序组成一个单向链表，每插入一条记录，还需要更新上一条记录的头信息中的next_record属性来维护这个单向链表。</p> <p>改动的地方相当多，而需要redo日志记录这些改动：</p> <p>方案一: 在每个修改的地方都记录一条redo日志。</p> <p>方案二：将整个页面第一个被修改的字节到最后一个被修改的字节之间所有的数据当成一条物理redo日志中的具体修改。</p> <p>而上述两者方案浪费空间，所以提出了一些新的redo日志类型：</p> <p>a). MLOG_REC_INSERT(type 字段对应的十进制数字为9): 表示在插入一条使用非紧凑行格式(REDUNDANT)的记录时，redo日志的类型</p> <p>b). MLOG_COMP_REC_INSERT(type 字段对应的十进制数字为38): 表示在插入一条使用紧凑行格式(COMPACT,DYNAMIC, COMPRESSED)的记录时，redo日志的类型</p> <p>c). MLOG_COMP_PAGE_CREATE(type 字段对应的十进制数字为58): 表示在创建一个存储紧凑行格式记录的页面时，redo日志的类型</p> <p>d). MLOG_COMP_REC_DELETE(type 字段对应的十进制数字为42): 表示在删除一条使用紧凑行格式记录时，redo日志的类型</p> <p>e). MLOG_COMP_LIST_START_DELETE(type 字段对应的十进制数字为44): 表示在从某条给定记录开始删除页面中一系列使用紧凑行格式的记录时，redo日志的类型。</p> <p>f). MLOG_COMP_LIST_END_DELETE(type 字段对应的十进制数字为43): 与MLOG_COMP_LIST_START_DELETE类型的rodo日志呼应，表示删除一系列记录，直到MLOG_COMP_LIST_END_DELETE类型的redo日志对应的记录为止。</p> <p>g). MLOG_ZIP_PAGE_COMPRESS(type 字段对应的十进制数字51): 表示在压缩一个数据页时，redo日志的类型。</p> <p>这些类型的redo日志既包含物理层面的意思，也包含逻辑层面的意思：</p> <p>a). 从物理层面看，这些日志都指明了对哪个表空间的哪个页进行修改。</p> <p>b). 从逻辑层面看，在系统崩溃后重启时，并不能直接根据这些日志中的记载，在页面内的某个偏移量处恢复某个数据，而是需要调用一些函数，在执行完这些函数后才能将页面恢复成系统崩溃前的样子。</p> <p>以下以MLOG_COMP_REC_INSERT类型的redo日志的结构进行举例：</p> <p>a). type</p> <p>b). spaceID</p> <p>c). page number</p> <p>d). n_fields  该条记录有多少个字段</p> <p>e). n_uniques  决定该记录唯一的字段数量</p> <p>f). field1_len, field2_len ... fieldn_len 各个字段占用的存储空间大小</p> <p>g). offset 前一条记录的地址</p> <p>h). end_seg_len 从该字段可以计算出当前记录总共占用存储空间的大小</p> <p>i). 一些记录头信息  表示记录头信息的前4个比特(info bits)的值以及record_type的值</p> <p>j). extra_size  记录的额外信息占用的存储空间大小</p> <p>k). mismatch index 为了节省redo 日志大小而设立的字段，可以忽略</p> <p>m). 记录的真实数据</p> <p>redo并没有记录PAGE_N_DIR_SLOTS, PAGE_HEAP_TOP, PAGE_N_HEAP 等的值被修改成什么，而只是把本页面中插入一条记录所有必备的要素记录下来。后续通过函数去修改相关的值。</p> <h4 id="mini-transaction"><a href="#mini-transaction" class="header-anchor">#</a> Mini-Transaction</h4> <ol><li>以组的形式写入redo日志</li></ol> <p>执行语句的过程中产生的redo日志。划分为若干个不可分割的组</p> <p>a). 更新Max Row ID属性时产生的redo日志为一组，是不可分割的。</p> <p>b). 向聚簇索引对应B+树的页面插入一条记录时产生的redo日志是一组，是不可分割的。</p> <p>c). 向某个二级索引对应的B+树的页面插入一条记录时产生的redo日志是一组，是不可分割的。</p> <p>d). 还有其他一些不可分割的组。</p> <p>如何保证产生的redo日志是一组：</p> <p>在该组的最后一条redo日志后面加上一条特殊类型的redo日志。该类型的redo日志的名称为 MLOG_MULTI_REC_END。所以需要保证原子性的操作所产生的一系列redo日志，必须是一条类型为MLOG_MULTI_REC_END的redo日志结尾。</p> <ol start="2"><li>Mini-Transaction的概念</li></ol> <p>对底层页面进行一次原子访问的过程称为一个 Mini-Transaction(MTR). 一个MTR可以包含一组redo日志。</p> <p>一个事务可以包含若干条语句，每一条语句又包含若干个MTR,每一个MTR又可以包含若干条redo日志。</p> <h4 id="redo日志的写入过程"><a href="#redo日志的写入过程" class="header-anchor">#</a> redo日志的写入过程</h4> <ol><li>redo log block</li></ol> <p>把通过MTR生成的redo日志都放在大小为512字节的页中。为了与前文提到的表空间中的页进行区别，我们这里把用来存储redo日志的页称为block。</p> <p>一个redo log block的结构包含三部分：</p> <p>a). log block header</p> <p>12个字节。</p> <p>包含4个字节的 LOG_BLOCK_HDR_NO, 2个字节的LOG_BLOCK_HDR_DATA_LEN, 2个字节的LOG_BLOCK_FIRST_REC_GROUP, 4个字节的LOG_BLOCK_CHECKPOINT_NO.</p> <p>LOG_BLOCK_HDR_NO: 每一个block都由一个大于0的唯一编号，该属性就表示该编号值。</p> <p>LOG_BLOCK_HDR_DATA_LEN: 表示block中已经使用了多个字节：初始值为12.随着往block中写入的redo日志越来越多，该属性值也跟着增长。如果log block body被全部写满，该属性的值被设置为512</p> <p>LOG_BLOCK_FIRST_REC_GROUP：一条redo日志也可以称为一条redo日志记录。一个MTR会生成多条redo日志记录，这个MTR生成的这些redo日志记录被称为一个redo日志记录组(redo log record group). 这个代表该block 中第一个MTR生成的redo日志记录组的偏移量，其实也就是这个block中第一个MTR生成的第一条redo日志记录的偏移量。</p> <p>LOG_BLOCK_CHECKPOINT_NO: 表示checkpoint的序号；checkpoint是后续内容的重点。</p> <p>b). log block body</p> <p>496个字节.</p> <p>c). log block trailer</p> <p>4个字节，为LOG_BLOCK_CHECKSUM: 表示该block的校验值，用于正确性校验。</p> <ol start="2"><li>redo 日志缓冲区</li></ol> <p>为了解决磁盘速度过慢的问题，引入redo日志缓冲区。申请了一大片 redo log buffer的连续内存空间。</p> <ol start="3"><li>redo日志写入log buffer</li></ol> <p>往log buffer中写入redo日志的过程是顺序写入的，也就是先往前面的block中写，当该block的空闲空间用完之后再往下一个block中写。提供了buf_free的全局变量，指明后续写入的redo日志应该写到log buffer中的哪个位置。</p> <p>MTR执行过程中可能产生若干条日志，这些redo日志是一个不可分割的组，所以并不是没生成一条redo日志就将其插入到log buffer中，而是将每个MTR运行过程中产生的日志先暂时存放到一个地方：当该MTR结束的时候，再将过程中产生的一组redo日志全部复制到log buffer中。</p> <h4 id="redo日志文件"><a href="#redo日志文件" class="header-anchor">#</a> redo日志文件</h4> <ol><li>redo日志刷盘时机</li></ol> <p>a). log buffer 空间不足时</p> <p>b). 事务提交时</p> <p>c). 后台有一个线程，大约以每秒一次的频率将log buffer中的redo 日志刷新到磁盘</p> <p>d). 正常关闭服务器时</p> <p>e). 做checkpoint</p> <ol start="2"><li>redo 日志文件组</li></ol> <p>data目录下有ib_logfile0 和 ib_logfile1两个文件，log buffer中的日志在默认情况下就是刷新到这两个磁盘文件中。如果对默认的redo日志文件不满意，可以通过下面几个启动选项来调节。</p> <p>innodb_log_group_home_dir: 指定了redo日志文件所在的目录，默认值就是当前的数据目录。</p> <p>innodb_log_file_size: 每隔redo日志文件的大小，默认值48M</p> <p>innodb_log_files_in_group: 指定了redo日志文件的个数，默认为2，最大值为100.</p> <p>总文件大小： innodb_log_files_in_group * innodb_log_file_size</p> <ol start="3"><li>redo日志文件格式</li></ol> <p>log buffer本质上是一片连续的内存空间，被划分成若干个512字节大小的block。将log buffer 中的redo日志刷新到磁盘的本质就是把block的镜像写入日志文件中，所以redo日志文件其实也是由若干个512字节大小的block组成。</p> <p>日志文件信息如下:</p> <p>a). 前2048个字节(也就是前4个block)用来存储一些管理信息</p> <p>b). 从第2048字节往后的字节用来存储log buffer中的block镜像。</p> <p>前2048个字节为4个特殊的block。</p> <p>每隔block块的结构如下：</p> <p>a). log file header</p> <p>描述该redo日志文件的一些整体属性。</p> <p>主要包括4字节的 LOG_HEADER_FORMAT, 4字节的 LOG_HEADER_PAD1, 8字节LOG_HEADER_START_LSN, 32字节 LOG_HEADER_CREATOR, 460字节的无用空间，4字节 LOG_BLOCK_CHECKSUM.</p> <table><thead><tr><th style="text-align:center;">属性名</th> <th style="text-align:center;">长度(字节)</th> <th style="text-align:center;">描述</th></tr></thead> <tbody><tr><td style="text-align:center;">LOG_HEADER_FORMAT</td> <td style="text-align:center;">4</td> <td style="text-align:center;">redo日志的版本</td></tr> <tr><td style="text-align:center;">LOG_HEADER_PAD1</td> <td style="text-align:center;">4</td> <td style="text-align:center;">用于字节填充，没什么实际意义</td></tr> <tr><td style="text-align:center;">LOG_HEADER_START_LSN</td> <td style="text-align:center;">8</td> <td style="text-align:center;">标记本redo日志文件偏移量为2048字节处对应的lsn值</td></tr> <tr><td style="text-align:center;">LOG_HEADER_CREATOR</td> <td style="text-align:center;">32</td> <td style="text-align:center;">一个字符串，标记redo日志文件的创建者是谁</td></tr> <tr><td style="text-align:center;">LOG_BLOCK_CHECKSUM</td> <td style="text-align:center;">4</td> <td style="text-align:center;">本block的校验值</td></tr></tbody></table> <p>b). checkpoint1</p> <p>记录关于checkpoint的一些属性。</p> <p>主要包含8字节的 LOG_CHECKPOINT_NO, 8字节的 LOG_CHECKPOINT_LSN, 8字节的 LOG_CHECKPOINT_OFFSET, 8字节的 LOG_CHECKPOINT_LOG_BUF_SIZE, 4字节的 LOG_BLOCK_CHECKSUM.</p> <table><thead><tr><th style="text-align:center;">属性名</th> <th style="text-align:center;">长度(字节)</th> <th style="text-align:center;">描述</th></tr></thead> <tbody><tr><td style="text-align:center;">LOG_CHECHPOINT_NO</td> <td style="text-align:center;">8</td> <td style="text-align:center;">服务器执行checkpoint的编号，每执行一次checkpoint，该值就加1</td></tr> <tr><td style="text-align:center;">LOG_CHECKPOINT_LSN</td> <td style="text-align:center;">8</td> <td style="text-align:center;">服务器在结束checkpoint时对应的lsn值；系统在崩溃后恢复时将从该值开始</td></tr> <tr><td style="text-align:center;">LOG_CHECKPOINT_OFFSET</td> <td style="text-align:center;">8</td> <td style="text-align:center;">上个属性中的lsn值在redo日志文件组中的偏移量</td></tr> <tr><td style="text-align:center;">LOG_CHECKPOINT_LOG_BUF_SIZE</td> <td style="text-align:center;">8</td> <td style="text-align:center;">服务器在执行checkpoint操作时对应的log buffer的大小</td></tr> <tr><td style="text-align:center;">LOG_BLOCK_CHECKSUM</td> <td style="text-align:center;">4</td> <td style="text-align:center;">本block的校验值，所有block都有该值</td></tr></tbody></table> <p>c). 无用</p> <p>d). checkpoint2</p> <h4 id="log-sequence-number"><a href="#log-sequence-number" class="header-anchor">#</a> log sequence number</h4> <p>自系统开始运行，就在不断地修改页面，这就意味着会不断地生成redo日志。redo日志的两在不断递增。所以设计了lsn的全局变量，用来记录当前总共已经写入的redo日志量。lsn初始值为8704.</p> <p>系统第一次启动后，在初始化log buffer时，buf_free就会指向第一个block的偏移量为12字节(log block header的大小)的地方，lsn值也会跟着增加12.</p> <p>如果某个MTR产生的一组redo日志占用的存储空间比较小，也就是待插入的block剩余空闲空间能容纳这个MTR提交的日志时，lsn增长的量就是该MTR生成的redo日志占用的字节数。</p> <p>lsn值越小，说明redo日志产生得越早。</p> <ol><li>flushed_to_disk_lsn</li></ol> <p>全局变量：flushed_to_disk_lsn，标记当前log buffer中已经有哪些日志被刷新到磁盘中。</p> <ol start="2"><li>lsn值和redo日志文件组中的偏移量的对应关系</li></ol> <p>lsn的值代表系统写入的redo日志量的一个总和。一个MTR中产生多个redo日志，lsn的值就增加多少(还要加上log block header 和 log block trailer的大小)。</p> <ol start="3"><li>flush 链表中的lsn</li></ol> <p>MTR结束时还有一件非常重要的事情要做，把MTR执行过程中修改过的页面加入到Buffer Pool的flush链表中。</p> <p>当第一次修改某个已经加载到Buffer Pool中的页面时，就会把这个页面对应的控制块插入到flush链表的头部；之后再修改该页面，由于它已经在flush链表中，所以就不再次插入了，也就是说，flush链表中的脏页是按照页面的第一次修改时间进行排序的。</p> <p>在这个过程中，会在缓冲页对应的控制块中记录两个关于页面何时修改的属性：</p> <p>oldest_modification: 第一次修改Buffer Pool中的某个缓冲页时，就将修改该页面的MTR开始时对应的lsn值写入这个属性。</p> <p>newest_modification: 没修改一次也没，都会将修改页面的MTR结束时对应的lsn值写入这个属性。</p> <p>flush链表中的脏页按照第一次修改发生的事件顺序进行排序，也就是按照oldest_modification 代表的lsn值进行排序；被多次更新的页面不会重复插入到flush链表中，但是会更新newest_modification属性的值。</p> <h4 id="checkpoint"><a href="#checkpoint" class="header-anchor">#</a> checkpoint</h4> <p>redo日志文件组的容量是有限的，所以需要循环使用redo日志文件组的文件。但是这会造成最后写入的日志文件和最开始写入的redo日志文件相碰。</p> <p>随着系统的运行，如果页a被刷新到了磁盘，那么页a对应的控制块就会从flush链表中移除。</p> <p>全局变量checkpoint_lsn，用来表示当前系统中可以覆盖的redo日志总量是多少。变量初始值为8704.</p> <p>执行一次checkpoint的意思即为增加checkpoint_lsn的操作。</p> <p>步骤：</p> <p>a). 计算当前系统中可以被覆盖的redo日志对应的lsn值最大是多少</p> <p>b). 将checkpoint_lsn与对应的redo日志文件组偏移量以及此次checkpoint的编号写到日志文件的管理信息中。</p> <p>将脏页刷新到磁盘中和执行一次checkpoint是两回事。每执行一次checkpoint都要修改redo日志文件的管理信息，执行checkpoint是有代价的。</p> <h4 id="查询系统中的各种lsn值"><a href="#查询系统中的各种lsn值" class="header-anchor">#</a> 查询系统中的各种lsn值</h4> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">SHOW</span> <span class="token keyword">ENGINE</span> <span class="token keyword">INNODB</span> <span class="token keyword">STATUS</span>
</code></pre></div><p>查看当前InnoDB存储引擎中各种lsn值的情况。</p> <p>Log squence number表示系统中的lsn值，当前系统已经写入redo日志量，包括写入到log buffer中的redo 日志</p> <p>Log flushed up to表示 flushed_to_disk_lsn的值，就是当前系统已经写入磁盘的redo日志量</p> <p>Pages flushed up to表示flush链表中被最早修改的那个页面对应的 oldest_modification 属性值。</p> <p>Last checkpoint at 表示当前系统的checkpoint_lsn值</p> <h4 id="innodb-flush-log-at-trx-commit-的用法"><a href="#innodb-flush-log-at-trx-commit-的用法" class="header-anchor">#</a> innodb_flush_log_at_trx_commit 的用法</h4> <p>用户线程在事务提交时需要将该事务执行过程中产生的所有redo日志都刷新到磁盘。</p> <p>innodb_flush_log_at_trx_commit有三个值：</p> <p>0: 表示在事务提交时不立即向磁盘同步redo日志，这个任务交给后台线程处理。可能会导致丢失。</p> <p>1: 表示在事务提交时，需要将redo日志同步到磁盘，保证事务的持久性</p> <p>2: 将redo日志写到操作系统的缓冲区中，但并不需要保证将日志真正地刷新到磁盘。</p> <h4 id="崩溃恢复"><a href="#崩溃恢复" class="header-anchor">#</a> 崩溃恢复</h4> <ol><li>确认恢复的起点</li></ol> <p>从lsn值等于checkpoint的redo日志开始。以及它再redo日志文件组中的偏移量checkpoint_offset</p> <ol start="2"><li>确认恢复的终点</li></ol> <p>log block header有一个LOG_BLOCK_HDR_DATA_LEN的属性。记录了当前block中使用了多少字节的空间。所以知道扫描某个block的该值不为512为止。</p> <ol start="3"><li>如何恢复</li></ol> <p>a). 使用哈希表</p> <p>通过spaceId和page number属性计算出哈希值。相同哈希值的放同一个槽中。</p> <p>遍历哈希表。对同一个页面进行修改的redo日志都会放同一个槽中。且必须要按顺序排序。</p> <p>b). 跳过已经刷新到磁盘中的页面</p> <h4 id="log-block-hrd-no-计算"><a href="#log-block-hrd-no-计算" class="header-anchor">#</a> LOG_BLOCK_HRD_NO 计算</h4> <p>((lsn / 512) &amp; 0x3FFFFFFF) + 1;</p> <p>如果为1，代表本block是在log buffer中的block书信到磁盘的某次操作中时，第一个被刷入的block。</p> <h3 id="undo日志"><a href="#undo日志" class="header-anchor">#</a> undo日志</h3> <p>主要用于事务回滚。</p> <h4 id="事务id"><a href="#事务id" class="header-anchor">#</a> 事务id</h4> <ol><li>分配事务id的时机</li></ol> <p>一个事务可以是一个只读事务，也可以是一个读写事务。</p> <p>如果某个事务再执行过程中对某个表执行了增删改操作，那么InnoDB存储引擎就会给它分配一个独一无二的id。</p> <p>a). 对于只读事务来说，只有在它第一次对某个用户创建临时表执行增删改操作时，才会为这个事务分配一个事务id。</p> <p>b). 对于读写事务来说，只有在它第一次对某个表(包括用户创建的临时表)执行增删改操作时，才会为这个事务分配一个事务id。</p> <ol start="2"><li>事务id是怎么生成的。</li></ol> <p>分配策略与row_id的分配大致相同。</p> <p>a). 维护一个全局变量，每当需要为某个事务分配事务id时，就会把该变量的值当作事务id分配个该事务，并且把变量自增1.</p> <p>b). 每当这个值为256的倍数时，就会将该变量的值刷新到系统表空间页号为5的页面中一个Max Trx ID的属性中。8字节</p> <p>c). 系统下一次重启，加载到内存中，并加上256后赋值给全局变量。</p> <h4 id="undo-日志的格式"><a href="#undo-日志的格式" class="header-anchor">#</a> undo 日志的格式</h4> <p>InnoDB进行记录的增删改操作时，都需要先把对应的undo日志记下来。一般每对一条记录进行一次改动，就对应着一条undo日志。这些undo 日志会从0开始编号，也就是说根据生成的顺序分别称为第0号undo日志，第1号undo日志...第n号undo日志。这个编号也称为undo no。</p> <p>这些undo日志被记录到类型为FIL_PAGE_UNDO_LOG(对应的十六进制是0x0002)的页面中。</p> <ol><li>insert操作对应的undo日志</li></ol> <p>设计了一个类型为 TRX_UNDO_INSERT_REC 的undo日志。结构如下：</p> <p>a). end of record: 本条undo日志结束，下一条开始时在页面中的地址</p> <p>b). undo type: 本条undo日志类型，也就是 TRX_UNDO_INSERT_REC</p> <p>c). undo no: 本条undo日志对应的编号</p> <p>d). table id: 本条undo日志对应的记录所在表的table id</p> <p>e). 主键各列信息&lt;len, value&gt;列表：主键的每隔列占用的存储空间大小和真实值。如果记录中的主键只包含一列，只需把该列占用的存储空间大小和真实值记录下来。</p> <p>f). 上一条undo日志结束，本条开始时在页面中的地址。</p> <p>一个事务中增加一条语句就会产生一条undo日志。</p> <p>而此时另一个隐藏的重要的字段：roll_pointer。占用7个字节。本质上就是指向记录对应的undo日志的指针。</p> <p>数据存放在数据页中，undo日志存放在类型为FIL_PAGE_UNDO_LOG的日志中，所以每个roll_pointer指针指向 类型为FIL_PAGE_UNDO_LOG中的某条记录。</p> <ol start="2"><li>DELETE操作对应的undo日志</li></ol> <p>被删除的记录会根据每条记录的头信息中的删除标志组成一个链表，称为垃圾链表。</p> <p>删除过程有两个阶段：</p> <p>a). 将记录的delete_flag标识位设置为1，修改记录的trx_id, roll_pointer值。delete_mark阶段。</p> <p>b). 当该删除语句所在的事务提交之后，会有专门的线程来真正地把记录删除掉。就是把正常记录链表中删除，并且加入到垃圾链表中，然后调整一些页面信息。为purge阶段。</p> <p>增加了 TRX_UNDO_DEL_MARK_REC 类型地undo日志。结构如下：</p> <p>a). end of record: 本条undo日志结束，下一条开始时在页面中的地址</p> <p>b). undo type: 类型：TRX_UNDO_DEL_MARK_REC</p> <p>c). undo no: 对应的编号</p> <p>d). table id: 对应的记录所在表的table id</p> <p>e). info bits: 记录头信息的前4个比特的值</p> <p>f). trx_id: 旧记录的trx_id的值</p> <p>g). roll_pointer: 旧记录的roll_pointer的值</p> <p>h). 主键各类信息&lt;len, value&gt;列表，主键的每个列占用的存储空间大小和真实值</p> <p>i). len of index_col_info: 索引列各列信息，部分和本部分占用的存储空间大小</p> <p>j). 索引列各列信息&lt;pos, len, value&gt;列表： 凡是被索引的列的各列信息</p> <p>k). start of record: 上条undo日志结束，本条开始时，在页面中的地址。</p> <ol start="3"><li>UPDATE 操作对应的undo日志</li></ol> <p>分为更新主键和不更新两种情况。</p> <p>a). 不更新主键：</p> <p>又分为被更新的列占用的存储空间不发生编号和发生变化两种情况。</p> <p>aa). 就地更新(in-place update)</p> <p>如果更新后的列于更新前的列占用的存储空间一样答，那么可以就地更新，直接进行修改。</p> <p>ab). 先删除旧记录，再插入新纪录。</p> <p>有任何一个被更新的列再更新前和更新后占用的存储空间大小不一致，那么就需要先把这条旧记录从聚簇索引页面种删除，然后再根据更新后列的值创建一条新的记录并插入到页面种。</p> <p>设计了 TRX_UNDO_UPD_EXIST_REC类型的undo日志, 与 TRX_UNDO_DEL_MARK_REC 类型的日志类似。</p> <p>a). end of record: 本条undo日志结束，下一条开始时在页面中的地址</p> <p>b). undo type: 类型：TRX_UNDO_DEL_MARK_REC</p> <p>c). undo no: 对应的编号</p> <p>d). table id: 对应的记录所在表的table id</p> <p>e). info bits: 记录头信息的前4个比特的值</p> <p>f). trx_id: 旧记录的trx_id的值</p> <p>g). roll_pointer: 旧记录的roll_pointer的值</p> <p>h). 主键各类信息&lt;len, value&gt;列表，主键的每个列占用的存储空间大小和真实值</p> <p>i). n_update: 共有多少个列被更新了</p> <p>j). 被更新的列更新前信息&lt;pos, old_len, old_value&gt;：被更新的列更新前信息</p> <p>k). len of index_col_info: 索引列各列信息，部分和本部分占用的存储空间大小</p> <p>m). 索引列各列信息&lt;pos, len, value&gt;列表： 凡是被索引的列的各列信息</p> <p>n). start of record: 上条undo日志结束，本条开始时，在页面中的地址。</p> <p>需要注意：</p> <p>aa). n_update属性标识再本条update语句执行后将有几个列被更新，后面跟着的&lt;pos, old_len, old_value&gt;列表中的pos, old_len, old_value分别表示被更新列再记录种的位置，更新前该列占用的存储空间大小，更新前该列的真实值。</p> <p>ab). 如果再UPDATE语句中更新的列包含索引列，那么也会添加&quot;索引列各列信息&quot;这个部分，否则不会添加这个部分。</p> <p>b). 更新主键</p> <p>意味着聚簇索引将发生变化</p> <p>增加了 TRX_UNDO_EXIST_REC 类型的undo日志结构,其结构跟TRX_UNDO_UPD_EXIST_REC一样。</p> <div class="language- extra-class"><pre class="language-text"><code>a). end of record: 本条undo日志结束，下一条开始时在页面中的地址

b). undo type: 类型：TRX_UNDO_DEL_MARK_REC

c). undo no: 对应的编号

d). table id: 对应的记录所在表的table id

e). info bits: 记录头信息的前4个比特的值

f). trx_id: 旧记录的trx_id的值

g). roll_pointer: 旧记录的roll_pointer的值

h). 主键各类信息&lt;len, value&gt;列表，主键的每个列占用的存储空间大小和真实值

i). n_update: 共有多少个列被更新了

j). 被更新的列更新前信息&lt;pos, old_len, old_value&gt;：被更新的列更新前信息

k). len of index_col_info: 索引列各列信息，部分和本部分占用的存储空间大小

m). 索引列各列信息&lt;pos, len, value&gt;列表： 凡是被索引的列的各列信息

n). start of record: 上条undo日志结束，本条开始时，在页面中的地址。

</code></pre></div><p>步骤：</p> <p>aa). 将旧纪录进行delete mark操作。</p> <p>ab). 根据更新后各列的值创建一条新的记录，并将其插入到聚簇索引中。</p> <ol start="4"><li>增删改对二级索引的影响</li></ol> <p>INSERT 操作和 DELETE操作和再聚簇索引中执行产生的印象差不多。</p> <p>update则需要根据是是否更新主键变成是否更新索引值。</p> <h4 id="通用链表结构"><a href="#通用链表结构" class="header-anchor">#</a> 通用链表结构</h4> <p>在写入undo日志的过程中，会用到多个链表。结构如下：</p> <p>a). Prev Node Page Number (4字节)</p> <p>b). Prev Node Offset(2字节)</p> <p>c). Next Node Page Number(2字节)</p> <p>d). Next Node Offset(2字节)</p> <p>其中a),b)相当于指向前一个节点的指针。c),d)指向后一个节点的指针。</p> <p>还增加了基节点：</p> <p>a). List Length(4字节): 节点大小</p> <p>b). First Node Page Number (4字节)</p> <p>c). First Node Offset(2字节)</p> <p>d). Last Node Page Number(2字节)</p> <p>e). Last Node Offset(2字节)</p> <h4 id="fil-page-undo-log-页面"><a href="#fil-page-undo-log-页面" class="header-anchor">#</a> FIL_PAGE_UNDO_LOG 页面</h4> <p>专门用来存储undo日志。</p> <p>结构：</p> <p>a). 38字节的 File Header</p> <p>b). 18字节的 Undo Page Header</p> <p>c). 16320字节的存放真正的undo日志及其他东西</p> <p>d). 8字节的File Trailer</p> <p>Undo Page Header为Undo页面特有的：</p> <p>a). TRX_UNDO_PAGE_TYPE: 2字节，准备存储什么类型的undo日志</p> <p>b). TRX_UNDO_PAGE_START: 2字节，从什么位置开始存储undo日志，或者说表示第一条undo日志在本页面中的起始偏移量。</p> <p>c). TRX_UNDO_PAGE_FREE: 2字节，最后一条结束的偏移量</p> <p>d). TRX_UNDO_PAGE_NODE: 12字节，链表节点。</p> <h4 id="undo页面链表"><a href="#undo页面链表" class="header-anchor">#</a> Undo页面链表</h4> <ol><li>单个事务中的Undo页面链表</li></ol> <p>一个事务包含多个语句，日志在一个页面中放不下，需要放到多个页面，则通过TRX_UNDO_PAGE_NODE 形成了链表。</p> <p>同时一个事务执行过程中，会混着执行insert，delete，update语句，意味着会产生不同类型的undo日志。一个事务的执行过程中可能需要2个Undo页面的链表：一个称为 insert undo链表，一个称为 update undo链表。</p> <p>而对普通表和临时表的改动所产生的undo日志要分别记录，所以一个事务中最多有4个以Undo页面组成的链表。</p> <p>分配规则如下：</p> <p>a). 刚开启事务时，一个Undo页面链表也不分配</p> <p>b). 当事务执行过程中向普通表插入记录或者执行更新记录主键的操作之后，就会为其分配一个普通表的insert undo链表。</p> <p>c). 当事务执行过程中删除或者更新了普通表的记录之后，就会为其分配一个普通表的update undo链表。</p> <p>d). 当事务执行过程中向临时表插入记录或者执行更新记录主键的操作之后，就会为其分配一个临时表的insert undo链表。</p> <p>e). 当事务执行过程中删除或者更新了临时表的记录之后，就会为其分配一个临时表的update undo链表。</p> <h4 id="undo日志具体写入过程"><a href="#undo日志具体写入过程" class="header-anchor">#</a> undo日志具体写入过程</h4> <ol><li>Undo Log Segment Header</li></ol> <p>每个Undo 页面链表都对应着一个段，称为 Undo Log Segment。链表的页面都是从这个段中申请的。将其中的第一个页面设计了一个 Undo Log Segment Header的部分：</p> <p>a). 38字节的 File Header</p> <p>b). 18字节的 Undo Page Header</p> <p>c). 30字节的 Undo Log Segment Header</p> <p>d). 186字节的 Undo Log Header</p> <p>d). 16104字节的存放真正的undo日志及其他东西</p> <p>e). 8字节的File Trailer</p> <p>Undo Log Segment Header的结构如下：</p> <p>a). 2字节的 TRX_UNDO_STATE: 本Undo页面链表处于什么状态。
有 TRX_UNDO_ACTIVE: 活跃状态，一个活跃的事务正在写入；TRX_UNDO_CACHED:被缓存的状态，等待被其他事务重用；TRX_UNDO_TO_FREE: 等待被释放，不能被重用；TRX_UNDO_TO_PURGE: 等待被purge状态；TRX_UNDO_PREPARED: 用于存储处于PREPARE阶段的事务产生的日志。</p> <p>b). 2字节的 TRX_UNDO_LAST_LOG: 本页面链表最后一个Undo Log Header的位置</p> <p>c). 10字节的 TRX_UNDO_FSEG_HEADER: 段信息，找到该段对应的INODE Entry</p> <p>d). 12字节的 TRX_UNDO_PAGE_LIST; Undo页面链表的基节点。</p> <ol start="2"><li>Undo Log Header</li></ol> <p>一个事务往Undo 页面中写入 undo日志，直接往后面堆即可。写完一个页面，申请下一个。</p> <p>同一个事务向一个Undo 页面链表中写入的undo日志算一个组。</p> <p>会有一个地方对每个事务写入了几个组的信息进行记录：Undo Log Header.在第一个页面中</p> <p>a). TRX_UNDO_TRX_ID：8字节，生成本组undo日志的事务id</p> <p>b). TRX_UNDO_TRX_NO：8字节，事务提交后生成的一个序号，标记事务的提交顺序</p> <p>c). TRX_UNDO_DEL_MARKS：2字节，标记本组undo日志中是否包含由delete mark操作产生的undo日志</p> <p>d). TRX_UNDO_LOG_START：2字节，表示本组undo 日志中第一条undo日志在页面中的偏移量</p> <p>e). TRX_UNDO_XID_EXISTS：1字节，本组undo日志是否包含xid信息</p> <p>f). TRX_UNDO_DICT_TRANS：1字节，标记本组undo日志是不是由DDL语句产生的</p> <p>g). TRX_UNDO_TABLE_ID：8字节，如果TRX_UNDO_DICT_TRANS为TRUE，表示DDL语句操作的表的table id</p> <p>h). TRX_UNDO_NEXT_LOG：2字节，下一组undo日志在页面中开始的偏移量</p> <p>i). TRX_UNDO_PREV_LOG：2字节，上一组undo日志在页面中开始的偏移量</p> <p>j). TRX_UNDO_HISTORY_NODE：12字节，代表一个名为History链表的节点。</p> <p>k). XID信息：140字节</p> <h4 id="重用undo页面"><a href="#重用undo页面" class="header-anchor">#</a> 重用Undo页面</h4> <p>一个Undo页面链表如果可以被重用，需要满足两个条件</p> <p>a). 该链表中只包含一个Undo页面</p> <p>b). 该Undo页面已经使用的空间小于整个页面空间的3/4</p> <p>对于insert undo链表。能直接覆盖</p> <p>对于update undo链表，需要保存旧的undo日志。</p> <h4 id="回滚段"><a href="#回滚段" class="header-anchor">#</a> 回滚段</h4> <ol><li>概念</li></ol> <p>Rollback Segment Header 页面，存放了各个Undo页面链表的first undo page的页号，称为undo slot。</p> <p>结构如下：</p> <p>a). 38字节的 File Header</p> <p>b). 4字节的 TRX_RSEG_MAX_SIZE：管理所有Undo页面链表中，Undo页面数量之和的最大值不能超过这个值。默认无限大</p> <p>c). 4字节的 TRX_RSEG_HISTORY_SIZE：History链表占用的页面数量</p> <p>d). 16字节的 TRX_RSEG_HISTORY：History链表的基节点</p> <p>e). 10字节的 TRX RSEG FSEG_HEADER: 可以找到段的INODE Entry</p> <p>f). 4096字节 TRX_RSEG_UNDO_SLOTS： 各个Undo页面链表的 first undo page的页号集合。</p> <p>g). 12208字节无用</p> <p>h). 8字节的 File Trailer</p> <p>每一个 Rollback Segment Header 页面对应一个段，也成为回滚段。</p> <ol start="2"><li>从回滚段中申请Undo页面链表</li></ol> <p>无事务时，各个undo slot都被设置为一个特殊值：FIL_NULL(0xFFFFFFFF)</p> <p>有事务发生时，判断该值是否为FIL_NULL,如果是，在表空间新创建一个段(Undo Log Segment), 然后从段中申请一个页面作为链表的first undo page，最后把该undo slot的值设置为刚申请的这个页面地址。不为FIL_NULL,说明已经被占用，需要跳到下一个undp slot,判断下一个是否为空。</p> <p>包含了1024个undo slot。当存在1024个事务了会报错。</p> <p>而一个事务提交后，undo slot有两种不同的结果</p> <p>a). 满足重用条件会被重用。insert undo 链表加入insert undo cached链表中。update undo链表加入到update undo cached链表中。</p> <p>b). 不满足重用。insert undo链表被设置成 TRX_UNDO_TO_FREE. update undo链表会被设置成TRX_UNDO_TO_PRUGE.并将值设为FIL_NULL. 然后将本次事务写入一组undo 日志放到 History链表中。</p> <p>128个回滚段。存在在表空间的五号页中。</p> <ol start="3"><li>回滚段的分类</li></ol> <p>0(系统表空间中)，33-127属于一类(既可以在系统表空间，也可在独立表空间)。</p> <p>如果一个事务执行过程中对普通表进行改动，则从这类中分配。</p> <p>1-32号属于一类。主要对了临时表分配。</p> <ol start="4"><li>roll_pointer 的组成</li></ol> <p>roll_pointer 7个字节</p> <p>a). is_insert：是否为 TRX_UNDO_INSERT大类，1bit</p> <p>b). rseg id：指针指向的undo日志的回滚段编号。7bit</p> <p>c). page number： 指针指向的undo日志所在页面的页号，32bit</p> <p>d). offset: 该指针指向的undo 日志在页面中的偏移量，16bit</p> <h4 id="回滚段的相关配置"><a href="#回滚段的相关配置" class="header-anchor">#</a> 回滚段的相关配置</h4> <ol><li>回滚段数量</li></ol> <p>innodb_rollback_segements字段。可配置范围1-128。</p> <ol start="2"><li>undo 表空间</li></ol> <p>innodb_undo_directory 指定undo表空间所在的目录。</p> <p>innodb_undo_tablespace 定义undo 表空间的数量。</p> <h4 id="undo日志在崩溃恢复时的作用"><a href="#undo日志在崩溃恢复时的作用" class="header-anchor">#</a> undo日志在崩溃恢复时的作用</h4> <p>为了防止崩溃恢复时，将未提交的事务修改过的页面在MySQL重启后恢复。</p> <p>系统表空间将128个回滚段的位置，在每个回滚段的1024个undo slot中找到那些值不为FIL_NULL的undo slot，每一个undo slot对应着一个Undo 页面链表。然后从Undo 页面链表第一个页面的Undo Segment Header中找到TRX_UNDO_STATE属性，如果该属性的值为TRX_UNDO_ACTIVIE, 再在 Undo Segment Header 中找到 TRX_UNDO_LAST_LOG属性，找到本Undo页面链表最后一个Undo Log Header的位置，可以找到对应事务的id和一些信息，该事务id对应的事务就是未提交的事务。</p> <h3 id="事务隔离级别和mvcc"><a href="#事务隔离级别和mvcc" class="header-anchor">#</a> 事务隔离级别和MVCC</h3> <h4 id="事务隔离级别"><a href="#事务隔离级别" class="header-anchor">#</a> 事务隔离级别</h4> <p>innodb中主要有四种事务隔离级别：</p> <p>读未提交：一个事务可以读取到另一个事务未提交时的修改。会导致脏读，不可重复读，幻读问题。</p> <p>读提交：一个事务只能读取到另一个事务提交后的修改。会导致不可重复读，幻读问题。</p> <p>可重复读：一个事务的更新操作不会影响到另一个事务的读取，尽量保证一个事务在多次读取过程中的数据不会受其他事务的更新影响。会导致幻读问题。MySQL默认隔离级别。</p> <p>串行化：事务间通过串行的形式执行，没有事务间的冲突。但是效率很低。</p> <p>修改隔离级别：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">set</span> <span class="token punctuation">[</span><span class="token keyword">global</span> <span class="token operator">|</span> <span class="token keyword">session</span><span class="token punctuation">]</span> <span class="token keyword">transaction</span> <span class="token keyword">isolation</span> <span class="token keyword">level</span> <span class="token punctuation">[</span><span class="token keyword">level</span><span class="token punctuation">]</span>
</code></pre></div><div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">set</span> <span class="token keyword">global</span> transaction_isolation <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token keyword">level</span><span class="token punctuation">]</span> <span class="token comment">-- 全局</span>

<span class="token keyword">set</span> @<span class="token variable">@global.var_name</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token keyword">level</span><span class="token punctuation">]</span> <span class="token comment">-- 全局</span>

<span class="token keyword">set</span> <span class="token keyword">session</span> var_name <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token keyword">level</span><span class="token punctuation">]</span> <span class="token comment">-- 会话</span>

<span class="token keyword">set</span> @<span class="token variable">@session.var_name</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token keyword">level</span><span class="token punctuation">]</span> <span class="token comment">-- 会话</span>

<span class="token keyword">set</span> var_name <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token keyword">level</span><span class="token punctuation">]</span> <span class="token comment">--会话</span>

<span class="token keyword">set</span> @<span class="token variable">@var_name</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token keyword">level</span><span class="token punctuation">]</span> <span class="token comment">--下一个事务</span>

</code></pre></div><p>level 可以为 REPEATABLE READ, READ COMMITTED, READ UNCOMMITED, SERIALIZABLE.</p> <h4 id="mvcc原理"><a href="#mvcc原理" class="header-anchor">#</a> MVCC原理</h4> <ol><li>版本链</li></ol> <p>每对记录进行一次改动，都会记录一条undo日志。每条undo 日志也都有一个 roll_pointer，通过这个属性将这些undo日志串成一个链表。</p> <p>在每次更新记录后，都会将旧值放到一条undo日志中，随着更新次数的增多，所有的版本都会被roll_pointer属性链接成一个链表，这个链表称为版本链。</p> <p>利用这个记录的版本链来控制并发事务访问相同记录时的行为，称之为多版本并发控制(Multi-Version Concurrency Control, MVCC)。</p> <ol start="2"><li>ReadView</li></ol> <p>对于使用 READ UNCOMMITTED隔离级别的事务来说，由于可以读到未提交事务修改过的记录，所以直接读取记录的最新版本就好了。对于使用SERIALIZABLE隔离级别的事务来说，会进行加锁。而对于 READ COMMITTED 和 REPEATABLE READ隔离级别的事务来说，都必须保证督导已经提交的事务修改过的记录。也就是说另一个事务已经修改了记录但是尚未提交，则不能直接读取最新版本的记录。</p> <p>即：对于 READ COMMITTED 和 REPEATABLE READ隔离级别的事务来说，需要判断版本链中哪个版本时当前事务可见的。</p> <p>为此设计了 ReadView(一致性视图)。</p> <p>a). m_ids: 在生成ReadView时，当前系统中活跃的读写事务的事务id列表。</p> <p>b). min_trx_id: 在生成ReadView时，当前系统中活跃的读写事务中最小的事务id；也就是m_ids中的最小值。</p> <p>c). max_trx_id: 在生成ReadView时，系统应该分配给下一个事务的事务id值。</p> <p>d). creator_trx_id: 生成该ReadView的事务的事务id。</p> <p>有了ReadView，在访问某条记录时：</p> <p>a). 如果被访问版本的trx_id属性值与ReadView中的creator_trx_id值相同，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问。</p> <p>b). 如果被访问版本的trx_id属性值小于ReadView中的min_trx_id值，表明生成该版本的事务在当前事务生成ReadView前已经提交，所以该版本可以被当前事务访问。</p> <p>c). 如果被访问版本的trx_id属性值大于或等于ReadView中的max_trx_id值，表明生成该版本的事务在当前事务生成ReadViews后才开启，所以该版本不可以被当前事务访问。</p> <p>d). 如果被访问版本的trx_id属性值在ReadView中 min_trx_id和max_trx_id之间，则需要判断trx_id属性值是否在m_ids列表中。如果在，说明创建ReadView时生成该版本的事务还是活跃的，该版本不能访问，如果不在，说明已经提交，可以被访问。</p> <p>如果某个版本的数据对当前事务不可见，那就顺着版本链找到下一个版本的数据。知道满足可访问条件为止。如果都不可见，则查询结果不包含该记录。</p> <p>READ COMMITTED 和 REPEATABLE READ隔离级别下，ReadView生成时机不同。</p> <p>a). Read committed ___ 每次读取数据前都生成一个ReadView</p> <p>b). Repeatable read ____ 在第一次读取数据时生成一个ReadView</p> <ol start="3"><li>二级索引与MVCC</li></ol> <p>只有在聚簇索引记录中才有 trx_id 和 roll_pointer 隐藏列。</p> <p>a). 二级索引页面的Page Header部分有一个名为 PAGE_MAX_TRX_ID的属性，每当对该页面中的记录进行增删改时，如果执行该操作的事务的事务id大于PAGE_MAX_TRX_ID属性值，就会把PAGE_MAX_TRX_ID属性设置为执行该操作的事务的事务id。PAGE_MAX_TRX_ID属性值代表着修改该二级索引页面的最大事务id是什么。select语句执行时，会看一下对应的ReadView的min_trx_id是否大于该页面的PAGE_MAX_TRX_ID属性值。如果是，说明该页面的所有记录都对该ReadView可见，否则执行b).</p> <p>b). 利用二级索引记录中的主键进行回表操作。再根据聚簇索引进行处理判断。</p> <p>我们只有进行普通的Select查询时，MVCC才生效。</p> <h3 id="purge"><a href="#purge" class="header-anchor">#</a> Purge</h3> <ol><li><p>insert undo 日志在事务提交之后就可以释放掉了，而update undo日志还需要支持MVCC，因此不能立即删除掉。</p></li> <li><p>为了支持MVCC，delete mark操作仅仅是在记录上打一个删除标记，并没有真正将记录删除。</p></li></ol> <p>update undo 日志和被标记为删除的记录只是为了支持MVCC存在的，只要系统种最早产生的哪个ReadView不再访问它们，它们的使命就结束了，就可以丢进历史的垃圾堆里了。</p> <p>保证生成ReadView时某个事务已经提交了，那么该ReadView肯定就不需要访问该事务运行过程中产生的undo日志了。</p> <p>a). 在一个事务提交时，会为这个事务生成一个名为事务no的值，该值用来表示事务提交的顺序，先提交的事务的事务no值小，后提交的事务的事务no值大。</p> <p>b). 一个ReadView结构还会包含一个事务no的属性，会把当前系统中最大的事务no值还大1的值赋给这个属性。</p> <p>把当前系统中所有的ReadView按照创建时间连成了一个链表。当执行purge操作时(这个purge操作是在专门的后台线程中执行的)，就把系统中最早生成的ReadView给取出来。如果当前系统中不存在ReadView，就创建一个(这个ReadView的事务no值肯定比当前已经提交的事务的事务no值大)。然后从各个回滚段的History取出事务no值较小的各组undo日志。如果一组undo日志的事务no值小于当前系统最找生成的ReadView的事务no属性值，意味着该组undo日志没有用了，就会从History链表中移除，释放掉它们占用的存储空间。</p> <p>系统中最早生成的ReadView决定了purge操作中可以清理哪些update undo 日志以及打了删除标记的记录。</p> <p>如果最早的事务一直没有提交，ReadView会一直不是放，系统中的update undo日志就会和打了删除标记的记录就会越来越多，文件就会越来越大，版本链将会越来越长。</p> <h3 id="锁"><a href="#锁" class="header-anchor">#</a> 锁</h3> <h4 id="解决并发事务带来问题的两种基本方式"><a href="#解决并发事务带来问题的两种基本方式" class="header-anchor">#</a> 解决并发事务带来问题的两种基本方式</h4> <p>并发事务访问相同记录的情况大致分为3种：</p> <p>a). 读-读情况：不会有任何问题</p> <p>b). 写-写情况：并发事务相继堆相同的记录进行改动</p> <p>c). 读-写：一个事务进行读取操作，另一个事务进行改动操作。</p> <ol><li>写-写情况</li></ol> <p>为了防止脏写的发生，多个未提交事务相继对一条记录进行改动时，需要让它们排队执行。而具体实现过程就是通过对记录进行加锁实现的。</p> <p>锁的结构如下：</p> <p>a). trx信息： 表示这个锁结构是与哪个事务关联的</p> <p>b). is_waiting: 表示当前事务是否在等待。</p> <p>is_waiting 表示当前这个锁对应的事务是否在等待。</p> <p>a). 获取锁成功，或者加锁成功: 在内存种生成了对应的锁结构，而且锁结构的is_waiting为false。并不是所有的加锁操作都需要生成对应的锁结构，存在加隐式锁的情况，隐式锁并不会生成实际的锁结构，但仍能起到保护记录的作用。</p> <p>b). 获取锁失败，或者加锁失败，或者没有获取到锁：在内存中生成了对应的锁结构，不过锁结构的is_waiting属性为true，也就是事务需要等待，不可以继续执行操作。</p> <p>c). 不加锁：不需要在内存中生成对应的锁结构，可以直接执行操作。不包括为记录加隐式锁的情况。</p> <ol start="2"><li>读-写或者写-读的情况</li></ol> <p>MySQL在REPEATABLE READ隔离级别下很大程度地避免了幻读现象。</p> <p>如何避免脏读，不可重复读，幻读这些现象？</p> <p>a). 读操作使用多版本并发控制，写操作进行加锁。</p> <p>b). 读，写操作都采用加锁方式。</p> <ol start="3"><li>一致性读</li></ol> <p>事务利用MVCC进行地读操作称为 一致性读(Consistent Read)。所用的普通的SELECT 语句在 Read Committed，REPEATABLE READ隔离级别下算是一致性读。</p> <ol start="4"><li>锁定读</li></ol> <p>a). 共享锁和独占锁</p> <p>在使用加锁的方式解决问题时，既要允许读-读不受影响，又要使用写-写，读-写或写-读相互堵塞。</p> <p>aa). 共享锁(Shared Lock): 简称 S 锁。在事务要读取一条记录时，需要先获取该记录的S锁。</p> <p>ab). 独占锁(Exclusive Lock): 排它锁，简称X锁。事务要改动一条记录时，需要先获取该记录的X锁。</p> <table><thead><tr><th style="text-align:center;">兼容性</th> <th style="text-align:center;">X锁</th> <th style="text-align:center;">S锁</th></tr></thead> <tbody><tr><td style="text-align:center;">X锁</td> <td style="text-align:center;">不兼容</td> <td style="text-align:center;">不兼容</td></tr> <tr><td style="text-align:center;">S锁</td> <td style="text-align:center;">不兼容</td> <td style="text-align:center;">兼容</td></tr></tbody></table> <p>b). 锁定读的语句</p> <p>对读取的记录加S锁：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">table</span> <span class="token keyword">lock</span> <span class="token operator">in</span> <span class="token keyword">SHARE</span> <span class="token keyword">MODE</span><span class="token punctuation">;</span>
</code></pre></div><p>对读取的记录加X锁</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">table</span> <span class="token keyword">for</span> <span class="token keyword">update</span><span class="token punctuation">;</span>
</code></pre></div><ol start="5"><li>写操作</li></ol> <p>a). DELETE: 对一条记录执行delete操作的过程其实是先在B+树种定位到这条记录的位置，然后获取这条记录的X锁，最后在执行delete mark操作。</p> <p>b). UPDATE: 对一条进行进行update分为三种情况</p> <div class="language- extra-class"><pre class="language-text"><code>1. 如果未修改该记录的键值并且被更新的列所占的存储空间在修改前后未发生变化，则现在B+树中定位到这条记录的位置，然后再获取记录的X锁，最后再原记录的位置进行修改操作。

2. 如果未修改该记录的键值并且至少有一个被更新的列占用的存储空间再修改前后发生变化，则先再B+树种定位到这条记录的位置，然后获取记录的X锁，之后将该记录彻底删除掉，最后再插入一条新记录。

3. 如果修改了该记录的键值，则相当于再原记录上执行DELETE操作之后再来一次Insert操作，加锁操作就需要按照DELETE和INSERT的规则进行了。
</code></pre></div><p>c). INSERT:一般情况下，新插入一条记录受隐式锁保护，不需要再内存种为其生成对应的锁结构。</p> <h4 id="多粒度锁"><a href="#多粒度锁" class="header-anchor">#</a> 多粒度锁</h4> <p>锁都是针对记录的，可以将其称为行级锁或者行锁。对一条记录加行锁，影响的也只是这条记录而已，即可说这个行锁的粒度比较细。其实一个事务也可以再表级锁进行加锁，自然就将其称为表级锁或者表锁。对一个表加锁，会影响表中的所有记录，则这个锁的粒度比较粗。</p> <ol><li>给表加S锁</li></ol> <p>如果一个事务给表加了S锁，那么：</p> <p>a). 别的事务可以继续获取该表的S锁</p> <p>b). 别的事务可以继续获取该表中某些记录的S锁</p> <p>c). 别的事务不可以继续获取该表的X锁</p> <p>d). 别的事务不可以继续获得该表种某些记录的X锁。</p> <p>如果一个事务给表加了X锁，那么：</p> <p>a). 别的事务不可以继续获得该表的S锁</p> <p>b). 别的事务不可以继续获得该表种某些记录的S锁。</p> <p>c). 别的事务不可以继续获得该表的X锁。</p> <p>d). 别的事务不可以继续获得该表中的某些记录的X锁。</p> <p>为了提高判断是否有锁的效率：</p> <p>提出了意向锁。</p> <p>a). 意向共享锁(Intention Share Lock): 简称IS锁，当事务准备在某条记录上加S锁时，需要现在表级别加一个IS锁。</p> <p>b). 意向独占(Intention Exclusive Lock): 简称IX锁，当事务准备在某条记录上加X锁时，需要现在表级别加一个IX锁。</p> <p>IS锁，IX锁是表级锁，它们的提出仅仅为了在之后加表级别的S锁和X锁时可以快速判断表中的记录是否被上锁。</p> <table><thead><tr><th style="text-align:center;">兼容性</th> <th style="text-align:center;">X锁</th> <th style="text-align:center;">IX锁</th> <th style="text-align:center;">S锁</th> <th style="text-align:center;">IS锁</th></tr></thead> <tbody><tr><td style="text-align:center;">X锁</td> <td style="text-align:center;">不兼容</td> <td style="text-align:center;">不兼容</td> <td style="text-align:center;">不兼容</td> <td style="text-align:center;">不兼容</td></tr> <tr><td style="text-align:center;">IX锁</td> <td style="text-align:center;">不兼容</td> <td style="text-align:center;">兼容</td> <td style="text-align:center;">不兼容</td> <td style="text-align:center;">兼容</td></tr> <tr><td style="text-align:center;">S锁</td> <td style="text-align:center;">不兼容</td> <td style="text-align:center;">不兼容</td> <td style="text-align:center;">兼容</td> <td style="text-align:center;">兼容</td></tr> <tr><td style="text-align:center;">IS锁</td> <td style="text-align:center;">不兼容</td> <td style="text-align:center;">兼容</td> <td style="text-align:center;">兼容</td> <td style="text-align:center;">兼容</td></tr></tbody></table> <h4 id="mysql中的行锁和表锁"><a href="#mysql中的行锁和表锁" class="header-anchor">#</a> MySQL中的行锁和表锁</h4> <ol><li>其他存储引擎中的锁</li></ol> <p>对于MyISAM, MEMORY, MERGE等存储引擎来说，只支持表级锁，而且这些存储引擎并不支持事务，所以对表加锁时，一般都是针对当前会话来说的。</p> <ol start="2"><li>InnoDB存储引擎中的锁</li></ol> <p>InnoDB存储引擎即支持表级锁，也支持行级锁。表级锁粒度粗，占用资源较少。</p> <p>a). InnoDB中的表级锁</p> <p>aa). 表级别的S锁，X锁</p> <p>在对某个表执行SELELCT, INSERT, DELETE, UPDATE语句时，InnoDB存储引擎是不会为这个表添加表级别的S锁或者X锁的。</p> <p>只会在一些特殊情况下(比如在系统崩溃恢复时)用到。不过我们还是可以手动获取以下，比如在系统变量autocommit=0，innodb_table_locks = 1时，要手动获取InnDB存储引擎提供的表t的S锁或者X锁，可以使用:</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">LOCK</span> <span class="token keyword">TABLES</span> t <span class="token keyword">READ</span><span class="token punctuation">;</span>

<span class="token keyword">LOCK</span> <span class="token keyword">TABLES</span> t <span class="token keyword">WRITE</span><span class="token punctuation">;</span>
</code></pre></div><p>ab). 表级别的IS锁，IX锁</p> <p>对使用InnoDB存储引擎的表的某些记录加S锁之前，需要先在表级别加一个IS锁。对表某些记录加X锁之前，需要先在表级别加一个IX锁。</p> <p>ac). 表级别的AUTO-INC锁</p> <p>在使用MySQL的过程中，我们可以为表的某个列添加AUTO_INCREMENT属性，之后再插入记录时，可以不指定该列的值，系统会自动为它赋予递增的值。</p> <p>系统自动给AUTO_INCREMENT修饰的列进行递增赋值的实现方式主要有两个：</p> <p>aa). 采用AUTO-INC锁，也就是在执行插入语句时就加一个表级别的AUTO-INC锁，然后为每条待插入记录的AUTO_INCREMENT修饰的列分配递增的值。在该语句执行结束后，再把AUTO-INC锁释放掉。</p> <p>ab). 采用一个轻量级的锁，在为插入语句生成AUTO_INCREMENT修饰的列的值时获取这个轻量级锁，然后在生成本次插入语句需要用到的AUTO_INCREMENT修饰的列的值之后，就把该轻量级锁释放掉，而不需要等到整个插入语句执行完后才释放锁。</p> <ol start="3"><li>InnoDB中的行级锁</li></ol> <p>行级锁，也称为记录锁。</p> <p>行级锁类型：</p> <p>a). Record Lock</p> <p>记录锁就是这种类型，就是仅仅把一条记录锁上。官方命名为： LOCK_REC_NOT_GAR.</p> <p>有S锁和X锁之分，称为S型正经记录锁和X型正经记录锁。当一个事务获取了一条记录的S型正经记录锁后，其他事务也可以继续获取该记录的S型正经记录锁，但不可以继续获取X型正经记录锁。当一个事务获取了一条记录的X型正经记录锁后，其他事务既不可以继续获取该记录的S型正经记录锁，也不可以继续获取X型正经记录锁。</p> <p>b). Gap Lock</p> <p>间隙锁。</p> <p>例如：给id为8的记录加上间隙锁，意味着不允许别的事务在id为8的记录前面的间隙插入新记录。</p> <p>间隙锁仅仅是为了防止插入幻影记录而提出的。虽然gap锁有共享gap锁和独占锁这样的说法。但是作用是相同的。如果对一条记录加了gap锁，并不会限制其他事务对这条记录加正经记录锁或者继续加gap锁。</p> <p>c). Next-Key Lock</p> <p>既想锁住某条记录，又想阻值其他事务在该记录前面的间隙插入新纪录。提出了名为Next-Key Lock的锁。</p> <p>next-key 锁的本质就是一个正经记录锁和一个grap锁的合体。</p> <p>d). Insert Intention Lock</p> <p>一个事务在插入一条记录时，需要判断插入位置是否已被别的事务加了grp锁。如果有的话，插入操作需要等待，直到拥有gap锁的事务提交位置。事务在等待时也需要在内存生成一个锁结构，表示现在处于等待状态。命名为 Insert Intention Lock, 插入意向锁。</p> <p>e). 隐式锁</p> <p>在内存中生成锁结构并且维护它们并不是一件零成本的事情。</p> <p>隐式锁起到了延迟生成锁结构的用处。如果别的事务在执行过程中不需要获取与该隐式锁相冲突的锁，就可以避免在内存中生成锁结构。一般情况下执行INSERT语句是不需要在内存中生成锁结构的。</p> <p>但是如果其他事务读取这条记录并加锁或者立即修改这条记录咋办。</p> <p>通过事务id来解决：</p> <p>a). 对于聚簇索引，有trx_id隐藏列，记录着最后改动该记录的事务的事务id。在当前事务中新插入一条聚簇索引记录后，该记录的trx_id隐藏列代表的就是当前事务的事务id。如果其他事务此时想对该记录添加S锁或者X锁，首先要看一下该记录的trx_id隐藏列代表的事务是否是当前的活跃事务。如果不是，就正常读取。是的话，就帮助当前事务创建一个X锁结构，is_waiting属性为false。然后也为自己创建一个锁结构，该锁结构的is_waiting属性为true。</p> <p>b). 对于二级索引记录来说，没有trx_id隐藏列。二级索引页面的Page Header中有PAGE_MAX_TRX_ID. 判断该值小于当前最小的活动事务id，说明对该页面的修改已经提交了。否则回表操作，再执行a)步骤。</p> <ol start="4"><li>InnoDB锁的内存结构</li></ol> <p>对一条记录加锁的本质就是创建一个所结构与之关联。</p> <p>而多次加锁的情况下，满足以下情况的：</p> <p>a). 再同一个事务中进行加锁操作</p> <p>b). 被加锁的记录再同一个页面中</p> <p>c). 加锁的类型是一样的</p> <p>d). 等待状态是一样的</p> <p>InnoDB存储引擎中的锁结构：</p> <p>a). 锁所在的事务信息：无论是表级锁还是行级锁，一个锁属于一个事务，这里记载着该锁对应的事务信息。</p> <p>b). 索引信息：对于行级锁来说，需要记录下加锁的记录属于哪个索引</p> <p>c). 表锁/行锁信息：表级锁结构和行级锁结构在这个位置的内容是不同的，具体表现为表级锁记载着这是对哪个表加的锁，还有其他一些信息：</p> <p>SpaceID：记录所在的表空间。 Page Number：记录所在的页号。 n_bits： 对于行级锁来说，一条记录对应一个比特，一个页面包含很多条记录，用不同的比特来区分到底是为了哪条记录加了锁。</p> <p>d). type_mode: 这是一个32比特的数。被分为lock_mode, lock_type 和 rec_lock_type这三个部分。</p> <p>lock_mode(锁模式)占用低4比特：</p> <div class="language- extra-class"><pre class="language-text"><code>LOCK_IS (0), 表示共享意向锁。

LOCK_IX (1), 表示独占意向锁。

LOCK_S (2), 表示共享锁。

LOCK_X (3), 表示独占锁。

LOCK_AUTO_INC (4), 表示AUTO-INC锁。
</code></pre></div><p>lock_type(锁类型)占用第5~8位，不过现阶段只用到5，6位。</p> <div class="language- extra-class"><pre class="language-text"><code>LOCK_TABLE (16), 第5位为1时，表示表级锁。

LOCK_REC (32), 第6位为1时，表示行级锁。
</code></pre></div><p>rec_lock_type (行锁的具体类型)使用其余的位来表示。只有在lock_type的值为LCOK_REC时，也就是只有在该锁为行锁时才会细分：</p> <div class="language- extra-class"><pre class="language-text"><code>LOCK_ORDINARY (0), 表示next-key锁。

LOCK_GAP (512), 10比特为1时，表示gap锁

LOCK_REC_NOT_GAP (1024), 11比特位1时，表示正经记录锁。

LOCK_INSERT_INTENTION (2048), 12比特为1时，表示插入意向锁。
</code></pre></div><p>e). 其他信息: 为了更好地管理系统运行过程中生成的各种锁结构，而设计了各种哈希表和链表。</p> <p>f). 一堆比特位：行级锁结构，设置了一堆比特位，用于记录哪些被锁住了。</p> <h4 id="语句加锁分析"><a href="#语句加锁分析" class="header-anchor">#</a> 语句加锁分析</h4> <ol><li>普通的Select语句</li></ol> <p>a). 在READ UNCOMMITTED 隔离级别下，不加锁，直接读取记录的最新版本</p> <p>b). 在READ COMMITTED 隔离级别下，不加锁，每次生成一个ReadView。</p> <p>c). 在REPEATABLE READ隔离级别下，不加锁，只在第一次执行普通的SELECT语句时生成一个ReadView。</p> <ol start="2"><li>锁定读的语句</li></ol> <p>锁定读的执行看成是依次读取若干个扫描区间总的记录。一般情况下，读取某个扫描区间中记录的过程如下所示：</p> <p>a). 首先快速地在B+树叶子节点中定位到该扫描区间中地第一条记录，作为当前记录。</p> <p>b). 对当前记录加锁。</p> <p>c). 判断索引条件下推地条件是否成立。</p> <p>d). 执行回表</p> <p>e). 判断边界条件是否成立</p> <p>f). server层判断其余搜索条件是否成立。</p> <p>g). 获取当前记录所在单向链表地下一条记录，并将其作为新的当前记录，并跳回步骤b).</p> <ol start="3"><li>半一致性读地语句</li></ol> <p>是一种夹在一致性读和锁定读之间地读取方式。当隔离级别不大于READ COMMITED且执行UPDATE语句时将会使用半一致性读。</p> <p>当UPDATE语句读取到已经被其他事务加了X锁的记录时，InnoDB会将该记录的最新提交版本读出来，然后判断该版本是否与UPDATE语句中的搜索条件相匹配。如果不匹配，则不进行加锁，从而跳到下一条记录。如果匹配，则再次古曲该记录并对其进行加锁。</p> <ol start="4"><li>insert语句</li></ol> <p>主要是隐式锁和gap锁。</p> <h4 id="查看事务加锁情况"><a href="#查看事务加锁情况" class="header-anchor">#</a> 查看事务加锁情况</h4> <ol><li>使用 information_schema 数据库中的表获取锁信息</li></ol> <p>INNODB_TRX: 表存储了InnoDB存储引擎当前正在执行的事务信息，包括事务id，事务状态等。</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> information_schema<span class="token punctuation">.</span>INNODB_TRX
</code></pre></div><p>INNODB_LOCKS: 记录了一些锁的信息，如果一个事务想要获取锁但未获取到，记录该锁信息。如果一个事务获取到了某个锁，但是这个锁阻塞了别的事务，则记录该锁信息。</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> information_schema<span class="token punctuation">.</span>INNODB_LOCKS
</code></pre></div><p>INNODB_LOCK_WAITS: 表明每个阻塞的事务是因为获取不到哪个事务持有的锁而阻塞。</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> information_schema<span class="token punctuation">.</span>INNODB_LOCK_WAITS
</code></pre></div><ol start="2"><li>使用SHOW ENINGE INNODE STATUS获取锁信息</li></ol> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">SHOW</span> ENINGE INNODE <span class="token keyword">STATUS</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="死锁"><a href="#死锁" class="header-anchor">#</a> 死锁</h4> <p>多个事务出现锁冲突，且各自等待其他事务将锁进行释放。</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">SHOW</span> <span class="token keyword">ENGINE</span> <span class="token keyword">INNODB</span> <span class="token keyword">STATUS</span><span class="token punctuation">;</span>
</code></pre></div><p>使用上述语句来检查最近发生的一次死锁信息。</p> <h3 id="mysql常用函数"><a href="#mysql常用函数" class="header-anchor">#</a> MySQL常用函数</h3> <ol><li>聚集函数</li></ol> <p>a). avg</p> <p>b). count</p> <p>c). max</p> <p>d). min</p> <p>e). sum</p> <ol start="2"><li>处理字符串函数</li></ol> <p>a). 合并字符串函数：concat(str1, str2, str3...)</p> <p>b). 比较字符串大小函数：strcmp(str1, str2)</p> <p>c). 获取字符串字节数函数：length(str)</p> <p>d). 获取字符串字符数函数：char_length(str)</p> <p>e). 字母大小写转换函数： upper(x), ucase(x), lower(x), lcase(x)</p> <p>f). 字符串查找函数：find_in_set(str1, str2), field(str, str1,str2,str3), locate(str1, str2), position(str1 in str2), instr(str1, str2)</p> <p>g). 获取指定位置的子串: elt(index, str1, str2, str3..), left(str, n), right(str, n), substring(str, index, len)</p> <p>h). 字符串去空函数：ltrim(str),rtrim(str), trim()</p> <p>i). 字符串替换函数: insert(str1, index len, str2), replace(str, str1, str2)</p> <ol start="3"><li>处理数值的函数</li></ol> <p>a). 绝对值函数：abs(x)</p> <p>b). 向上取整函数：ceil(x)</p> <p>c). 向下取整函数：floor(x)</p> <p>d). 取模函数：mod(x, y)</p> <p>e). 随机数函数：rand()</p> <p>f). 四舍五入函数：round(x, y)</p> <p>g). 数值截取函数：truncate(x, y)</p> <ol start="4"><li>用于处理时间日期的函数</li></ol> <p>a). 获取当前日期：curdate(), current_date()</p> <p>b). 获取当前时间：curtime(), current_time()</p> <p>c). 获取当前日期时间： now()</p> <p>d). 从日期中选择出月份数：month(date), monthname(date)</p> <p>e). 从日期中选择出周数: week(date)</p> <p>f). 从日期中选出周数：year(date)</p> <p>g). 从时间中选择出小时数：hour(time)</p> <p>h). 从时间中选择出分钟数：minute(time)</p> <p>i). 从时间中选择出今天是周几：weekday(date), dayname(date)</p> <p>j). 时间转字符串：DATE_FORMAT</p> <p>k). 从日期中选出当天: day(time)</p> <ol start="5"><li>控制流程函数</li></ol> <p>a). case value when [compare-value] then result end;</p> <p>b). if(expr1, expr2, expr3)</p></div> <footer class="page-edit" style="display:none;"><!----> <div class="last-updated"><span class="prefix">Last Updated: </span> <span class="time">2021-09-18 22:56:42</span></div></footer> <!----> <!----> <!----></main> <!----></div></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div></div></div>
    <script src="/assets/js/app.e5db9849.js" defer></script><script src="/assets/js/3.ed8c06e7.js" defer></script><script src="/assets/js/1.9e75a2be.js" defer></script><script src="/assets/js/38.64581f9c.js" defer></script>
  </body>
</html>
