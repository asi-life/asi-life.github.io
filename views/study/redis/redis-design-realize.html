<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>【书籍】 redis设计与实现 | 差不多的贝壳</title>
    <meta name="generator" content="VuePress 1.7.1">
    <link rel="icon" href="/logo.ico">
    <script language="javascript" type="text/javascript" src="https://cdn.bootcdn.net/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
    <script language="javascript" type="text/javascript" src="/js/MouseClickEffect.js"></script>
    <script language="javascript" type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>
    <meta name="description" content="【书籍】 redis设计与实现">
    <meta name="redis设计与实现" content="redis设计与实现">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    
    <link rel="preload" href="/assets/css/0.styles.98698290.css" as="style"><link rel="preload" href="/assets/js/app.e5db9849.js" as="script"><link rel="preload" href="/assets/js/3.ed8c06e7.js" as="script"><link rel="preload" href="/assets/js/1.9e75a2be.js" as="script"><link rel="preload" href="/assets/js/41.1b147abb.js" as="script"><link rel="prefetch" href="/assets/js/10.dcd742d7.js"><link rel="prefetch" href="/assets/js/11.9e8caa91.js"><link rel="prefetch" href="/assets/js/12.5acc7bfe.js"><link rel="prefetch" href="/assets/js/13.64c27640.js"><link rel="prefetch" href="/assets/js/14.d7c2c7ad.js"><link rel="prefetch" href="/assets/js/15.57c5ac2c.js"><link rel="prefetch" href="/assets/js/16.378ffe0f.js"><link rel="prefetch" href="/assets/js/17.89b3d75d.js"><link rel="prefetch" href="/assets/js/18.08a58208.js"><link rel="prefetch" href="/assets/js/19.0b8c12f8.js"><link rel="prefetch" href="/assets/js/20.438d1ec1.js"><link rel="prefetch" href="/assets/js/21.360c7dad.js"><link rel="prefetch" href="/assets/js/22.886d59ab.js"><link rel="prefetch" href="/assets/js/23.36693c07.js"><link rel="prefetch" href="/assets/js/24.c203effa.js"><link rel="prefetch" href="/assets/js/25.d0b49f35.js"><link rel="prefetch" href="/assets/js/26.0bd0b751.js"><link rel="prefetch" href="/assets/js/27.1ead41b5.js"><link rel="prefetch" href="/assets/js/28.8c71231e.js"><link rel="prefetch" href="/assets/js/29.0e91ba17.js"><link rel="prefetch" href="/assets/js/30.ba3f7ee4.js"><link rel="prefetch" href="/assets/js/31.a5aa6b4a.js"><link rel="prefetch" href="/assets/js/32.0180d8a3.js"><link rel="prefetch" href="/assets/js/33.1689da57.js"><link rel="prefetch" href="/assets/js/34.40068ec9.js"><link rel="prefetch" href="/assets/js/35.d45fa313.js"><link rel="prefetch" href="/assets/js/36.116b7de3.js"><link rel="prefetch" href="/assets/js/37.9156b580.js"><link rel="prefetch" href="/assets/js/38.64581f9c.js"><link rel="prefetch" href="/assets/js/39.e9338707.js"><link rel="prefetch" href="/assets/js/4.c3d42842.js"><link rel="prefetch" href="/assets/js/40.73109616.js"><link rel="prefetch" href="/assets/js/42.05bdc65e.js"><link rel="prefetch" href="/assets/js/43.8854147b.js"><link rel="prefetch" href="/assets/js/44.170947a8.js"><link rel="prefetch" href="/assets/js/45.47f74164.js"><link rel="prefetch" href="/assets/js/5.d57156ee.js"><link rel="prefetch" href="/assets/js/6.bd4ca3cb.js"><link rel="prefetch" href="/assets/js/7.fadd64b2.js"><link rel="prefetch" href="/assets/js/8.edf6ba42.js"><link rel="prefetch" href="/assets/js/9.9cbd478f.js">
    <link rel="stylesheet" href="/assets/css/0.styles.98698290.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar" data-v-2d5f533b><div data-v-2d5f533b><div id="loader-wrapper" class="loading-wrapper" data-v-d48f4d20 data-v-2d5f533b data-v-2d5f533b><div class="loader-main" data-v-d48f4d20><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div></div> <!----> <!----></div> <div class="password-shadow password-wrapper-out" style="display:none;" data-v-64685f0e data-v-2d5f533b data-v-2d5f533b><h3 class="title" style="display:none;" data-v-64685f0e data-v-64685f0e>差不多的贝壳</h3> <!----> <label id="box" class="inputBox" style="display:none;" data-v-64685f0e data-v-64685f0e><input type="password" value="" data-v-64685f0e> <span data-v-64685f0e>Konck! Knock!</span> <button data-v-64685f0e>OK</button></label> <div class="footer" style="display:none;" data-v-64685f0e data-v-64685f0e><span data-v-64685f0e><i class="iconfont reco-theme" data-v-64685f0e></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-64685f0e>vuePress-theme-reco</a></span> <span data-v-64685f0e><i class="iconfont reco-copyright" data-v-64685f0e></i> <a data-v-64685f0e><span data-v-64685f0e>差不多的贝壳</span>
            
          <span data-v-64685f0e>2021 - </span>
          2024
        </a></span></div></div> <div class="hide" data-v-2d5f533b><header class="navbar" data-v-2d5f533b><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/logo.jpg" alt="差不多的贝壳" class="logo"> <span class="site-name">差不多的贝壳</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      分类
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/人生第一次/" class="nav-link"><i class="iconfont undefined"></i>
  人生第一次
</a></li><li class="dropdown-item"><!----> <a href="/categories/书籍/" class="nav-link"><i class="iconfont undefined"></i>
  书籍
</a></li><li class="dropdown-item"><!----> <a href="/categories/生活/" class="nav-link"><i class="iconfont undefined"></i>
  生活
</a></li><li class="dropdown-item"><!----> <a href="/categories/电影/" class="nav-link"><i class="iconfont undefined"></i>
  电影
</a></li><li class="dropdown-item"><!----> <a href="/categories/宫崎骏/" class="nav-link"><i class="iconfont undefined"></i>
  宫崎骏
</a></li><li class="dropdown-item"><!----> <a href="/categories/电视剧/" class="nav-link"><i class="iconfont undefined"></i>
  电视剧
</a></li><li class="dropdown-item"><!----> <a href="/categories/日剧/" class="nav-link"><i class="iconfont undefined"></i>
  日剧
</a></li><li class="dropdown-item"><!----> <a href="/categories/生活剧/" class="nav-link"><i class="iconfont undefined"></i>
  生活剧
</a></li><li class="dropdown-item"><!----> <a href="/categories/袁隆平/" class="nav-link"><i class="iconfont undefined"></i>
  袁隆平
</a></li><li class="dropdown-item"><!----> <a href="/categories/国士无双/" class="nav-link"><i class="iconfont undefined"></i>
  国士无双
</a></li><li class="dropdown-item"><!----> <a href="/categories/学习/" class="nav-link"><i class="iconfont undefined"></i>
  学习
</a></li><li class="dropdown-item"><!----> <a href="/categories/操作系统/" class="nav-link"><i class="iconfont undefined"></i>
  操作系统
</a></li><li class="dropdown-item"><!----> <a href="/categories/动漫/" class="nav-link"><i class="iconfont undefined"></i>
  动漫
</a></li><li class="dropdown-item"><!----> <a href="/categories/故事/" class="nav-link"><i class="iconfont undefined"></i>
  故事
</a></li><li class="dropdown-item"><!----> <a href="/categories/婚姻/" class="nav-link"><i class="iconfont undefined"></i>
  婚姻
</a></li><li class="dropdown-item"><!----> <a href="/categories/java/" class="nav-link"><i class="iconfont undefined"></i>
  java
</a></li><li class="dropdown-item"><!----> <a href="/categories/面试题/" class="nav-link"><i class="iconfont undefined"></i>
  面试题
</a></li><li class="dropdown-item"><!----> <a href="/categories/Java/" class="nav-link"><i class="iconfont undefined"></i>
  Java
</a></li><li class="dropdown-item"><!----> <a href="/categories/中间件/" class="nav-link"><i class="iconfont undefined"></i>
  中间件
</a></li><li class="dropdown-item"><!----> <a href="/categories/消息队列/" class="nav-link"><i class="iconfont undefined"></i>
  消息队列
</a></li><li class="dropdown-item"><!----> <a href="/categories/Photoshop/" class="nav-link"><i class="iconfont undefined"></i>
  Photoshop
</a></li><li class="dropdown-item"><!----> <a href="/categories/网络编程/" class="nav-link"><i class="iconfont undefined"></i>
  网络编程
</a></li><li class="dropdown-item"><!----> <a href="/categories/数据库/" class="nav-link"><i class="iconfont undefined"></i>
  数据库
</a></li><li class="dropdown-item"><!----> <a href="/categories/框架/" class="nav-link"><i class="iconfont undefined"></i>
  框架
</a></li><li class="dropdown-item"><!----> <a href="/categories/redis/" class="nav-link"><i class="iconfont undefined"></i>
  redis
</a></li><li class="dropdown-item"><!----> <a href="/categories/近日总结/" class="nav-link"><i class="iconfont undefined"></i>
  近日总结
</a></li><li class="dropdown-item"><!----> <a href="/categories/Zookeeper/" class="nav-link"><i class="iconfont undefined"></i>
  Zookeeper
</a></li></ul></div></div><div class="nav-item"><a href="/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  标签
</a></div><div class="nav-item"><a href="/" class="nav-link"><i class="iconfont reco-home"></i>
  首页
</a></div><div class="nav-item"><a href="/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  时间轴
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-message"></i>
      关于
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/views/message-board.html" class="nav-link"><i class="iconfont reco-suggestion"></i>
  留言板
</a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-2d5f533b></div> <aside class="sidebar" data-v-2d5f533b><div class="personal-info-wrapper" data-v-ca798c94 data-v-2d5f533b><img src="/logo.jpg" alt="author-avatar" class="personal-img" data-v-ca798c94> <h3 class="name" data-v-ca798c94>
    差不多的贝壳
  </h3> <div class="num" data-v-ca798c94><div data-v-ca798c94><h3 data-v-ca798c94>34</h3> <h6 data-v-ca798c94>文章</h6></div> <div data-v-ca798c94><h3 data-v-ca798c94>38</h3> <h6 data-v-ca798c94>标签</h6></div></div> <hr data-v-ca798c94></div> <nav class="nav-links"><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      分类
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/人生第一次/" class="nav-link"><i class="iconfont undefined"></i>
  人生第一次
</a></li><li class="dropdown-item"><!----> <a href="/categories/书籍/" class="nav-link"><i class="iconfont undefined"></i>
  书籍
</a></li><li class="dropdown-item"><!----> <a href="/categories/生活/" class="nav-link"><i class="iconfont undefined"></i>
  生活
</a></li><li class="dropdown-item"><!----> <a href="/categories/电影/" class="nav-link"><i class="iconfont undefined"></i>
  电影
</a></li><li class="dropdown-item"><!----> <a href="/categories/宫崎骏/" class="nav-link"><i class="iconfont undefined"></i>
  宫崎骏
</a></li><li class="dropdown-item"><!----> <a href="/categories/电视剧/" class="nav-link"><i class="iconfont undefined"></i>
  电视剧
</a></li><li class="dropdown-item"><!----> <a href="/categories/日剧/" class="nav-link"><i class="iconfont undefined"></i>
  日剧
</a></li><li class="dropdown-item"><!----> <a href="/categories/生活剧/" class="nav-link"><i class="iconfont undefined"></i>
  生活剧
</a></li><li class="dropdown-item"><!----> <a href="/categories/袁隆平/" class="nav-link"><i class="iconfont undefined"></i>
  袁隆平
</a></li><li class="dropdown-item"><!----> <a href="/categories/国士无双/" class="nav-link"><i class="iconfont undefined"></i>
  国士无双
</a></li><li class="dropdown-item"><!----> <a href="/categories/学习/" class="nav-link"><i class="iconfont undefined"></i>
  学习
</a></li><li class="dropdown-item"><!----> <a href="/categories/操作系统/" class="nav-link"><i class="iconfont undefined"></i>
  操作系统
</a></li><li class="dropdown-item"><!----> <a href="/categories/动漫/" class="nav-link"><i class="iconfont undefined"></i>
  动漫
</a></li><li class="dropdown-item"><!----> <a href="/categories/故事/" class="nav-link"><i class="iconfont undefined"></i>
  故事
</a></li><li class="dropdown-item"><!----> <a href="/categories/婚姻/" class="nav-link"><i class="iconfont undefined"></i>
  婚姻
</a></li><li class="dropdown-item"><!----> <a href="/categories/java/" class="nav-link"><i class="iconfont undefined"></i>
  java
</a></li><li class="dropdown-item"><!----> <a href="/categories/面试题/" class="nav-link"><i class="iconfont undefined"></i>
  面试题
</a></li><li class="dropdown-item"><!----> <a href="/categories/Java/" class="nav-link"><i class="iconfont undefined"></i>
  Java
</a></li><li class="dropdown-item"><!----> <a href="/categories/中间件/" class="nav-link"><i class="iconfont undefined"></i>
  中间件
</a></li><li class="dropdown-item"><!----> <a href="/categories/消息队列/" class="nav-link"><i class="iconfont undefined"></i>
  消息队列
</a></li><li class="dropdown-item"><!----> <a href="/categories/Photoshop/" class="nav-link"><i class="iconfont undefined"></i>
  Photoshop
</a></li><li class="dropdown-item"><!----> <a href="/categories/网络编程/" class="nav-link"><i class="iconfont undefined"></i>
  网络编程
</a></li><li class="dropdown-item"><!----> <a href="/categories/数据库/" class="nav-link"><i class="iconfont undefined"></i>
  数据库
</a></li><li class="dropdown-item"><!----> <a href="/categories/框架/" class="nav-link"><i class="iconfont undefined"></i>
  框架
</a></li><li class="dropdown-item"><!----> <a href="/categories/redis/" class="nav-link"><i class="iconfont undefined"></i>
  redis
</a></li><li class="dropdown-item"><!----> <a href="/categories/近日总结/" class="nav-link"><i class="iconfont undefined"></i>
  近日总结
</a></li><li class="dropdown-item"><!----> <a href="/categories/Zookeeper/" class="nav-link"><i class="iconfont undefined"></i>
  Zookeeper
</a></li></ul></div></div><div class="nav-item"><a href="/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  标签
</a></div><div class="nav-item"><a href="/" class="nav-link"><i class="iconfont reco-home"></i>
  首页
</a></div><div class="nav-item"><a href="/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  时间轴
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-message"></i>
      关于
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/views/message-board.html" class="nav-link"><i class="iconfont reco-suggestion"></i>
  留言板
</a></li></ul></div></div> <!----></nav> <!----> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-64685f0e data-v-2d5f533b><h3 class="title" style="display:none;" data-v-64685f0e data-v-64685f0e>【书籍】 redis设计与实现</h3> <!----> <label id="box" class="inputBox" style="display:none;" data-v-64685f0e data-v-64685f0e><input type="password" value="" data-v-64685f0e> <span data-v-64685f0e>Konck! Knock!</span> <button data-v-64685f0e>OK</button></label> <div class="footer" style="display:none;" data-v-64685f0e data-v-64685f0e><span data-v-64685f0e><i class="iconfont reco-theme" data-v-64685f0e></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-64685f0e>vuePress-theme-reco</a></span> <span data-v-64685f0e><i class="iconfont reco-copyright" data-v-64685f0e></i> <a data-v-64685f0e><span data-v-64685f0e>差不多的贝壳</span>
            
          <span data-v-64685f0e>2021 - </span>
          2024
        </a></span></div></div> <div data-v-2d5f533b><main class="page"><div class="page-title" style="display:none;"><h1 class="title">【书籍】 redis设计与实现</h1> <div data-v-3b7f5bdf><i class="iconfont reco-account" data-v-3b7f5bdf><span data-v-3b7f5bdf>差不多的贝壳</span></i> <i class="iconfont reco-date" data-v-3b7f5bdf><span data-v-3b7f5bdf>2021-07-13</span></i> <i class="iconfont reco-eye" data-v-3b7f5bdf><span id="/views/study/redis/redis-design-realize.html" data-flag-title="Your Article Title" class="leancloud-visitors" data-v-3b7f5bdf><a class="leancloud-visitors-count" style="font-size:.9rem;font-weight:normal;color:#999;"></a></span></i> <i class="iconfont reco-tag tags" data-v-3b7f5bdf><span class="tag-item" data-v-3b7f5bdf>redis</span></i></div></div> <div class="theme-reco-content content__default" style="display:none;"><p>配套网站：redisbook.com</p> <p>redis3.0的代码注释：https://github.com/asi-life/redis-3.0-annotated</p> <h2 id="redis类型"><a href="#redis类型" class="header-anchor">#</a> redis类型</h2> <h3 id="简单动态字符串"><a href="#简单动态字符串" class="header-anchor">#</a> 简单动态字符串</h3> <p>简单动态字符串：SDS</p> <p>而redis使用sds.h中的sdshdr结构表示一个SDS值。</p> <p>其结构如下：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">sdshdr</span> <span class="token punctuation">{</span>
    <span class="token comment">// 记录buf数组中已使用字节的数量</span>
    <span class="token comment">// 等于SDS所保存字符串的长度</span>
    <span class="token keyword">int</span> len<span class="token punctuation">;</span>
    <span class="token comment">// 记录buf数组中未使用字节的数量</span>
    <span class="token keyword">int</span> free<span class="token punctuation">;</span>
    <span class="token comment">// 字节数组，用于保存字符串</span>
    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><ol><li><p>SDS遵循C语言字符串以空字符结尾的惯例，保存空字符的1字节空间不计算在SDS的len属性里面。空字符分配额外的1空字节空间，以及添加空字符到字符串末尾等操作都是由SDS函数自动完成的。</p></li> <li><p>C字符串与SDS之间的区别</p></li></ol> <table><thead><tr><th style="text-align:center;">C字符串</th> <th style="text-align:center;">SDS</th></tr></thead> <tbody><tr><td style="text-align:center;">获取字符串长度的复杂度为O(N)</td> <td style="text-align:center;">获取字符串长度的复杂度为O(1)</td></tr> <tr><td style="text-align:center;">API是不安全的，可能会造成缓冲区溢出，不会做溢出判断</td> <td style="text-align:center;">API是安全的，不会造成缓冲区溢出</td></tr> <tr><td style="text-align:center;">修改字符串长度N次必然需要执行N次内存重新分配</td> <td style="text-align:center;">修改字符串长度N次最多需要执行N次内存重分配</td></tr> <tr><td style="text-align:center;">只能保存文本数据</td> <td style="text-align:center;">可以保存文本或二进制数据</td></tr> <tr><td style="text-align:center;">可以使用所有&lt;string.h&gt;库中的函数</td> <td style="text-align:center;">可以使用一部分&lt;string.h&gt;库中的函数</td></tr></tbody></table> <ol start="3"><li>SDS中的核心api</li></ol> <table><thead><tr><th style="text-align:center;">函数</th> <th style="text-align:center;">作用</th> <th style="text-align:center;">时间复杂度</th></tr></thead> <tbody><tr><td style="text-align:center;">sdsnew</td> <td style="text-align:center;">创建一个包含给定C字符串的SDS，并返回长度</td> <td style="text-align:center;">O(N)，N为给定字符串的长度</td></tr> <tr><td style="text-align:center;">sdsempty</td> <td style="text-align:center;">创建一个不包含任何内容的空SDS</td> <td style="text-align:center;">O(1)</td></tr> <tr><td style="text-align:center;">sdsfree</td> <td style="text-align:center;">释放给定的SDS</td> <td style="text-align:center;">O(N) N为释放SDS的长度</td></tr> <tr><td style="text-align:center;">sdslen</td> <td style="text-align:center;">返回SDS的已使用空间字节数</td> <td style="text-align:center;">O(1)</td></tr> <tr><td style="text-align:center;">sdsavail</td> <td style="text-align:center;">返回SDS的未使用空间字节数</td> <td style="text-align:center;">O(1)</td></tr> <tr><td style="text-align:center;">sdsdup</td> <td style="text-align:center;">创建一个给定SDS的副本(copy)</td> <td style="text-align:center;">O(N),N为给定SDS的长度</td></tr> <tr><td style="text-align:center;">sdsclear</td> <td style="text-align:center;">清空SDS保存的字符串内容</td> <td style="text-align:center;">因为惰性空间释放策略，复杂度为O(1)</td></tr> <tr><td style="text-align:center;">sdscat</td> <td style="text-align:center;">讲给定C字符串拼接到SDS字符串的末尾</td> <td style="text-align:center;">O(N),N为被拼接C字符串的长度</td></tr> <tr><td style="text-align:center;">sdscatsds</td> <td style="text-align:center;">给定SDS字符串拼接到另一个SDS字符串的末尾</td> <td style="text-align:center;">O(N),N为被拼接SDS字符串的长度</td></tr> <tr><td style="text-align:center;">sdscpy</td> <td style="text-align:center;">讲给定的C字符串复制到SDS里面，覆盖SDS原有的字符串</td> <td style="text-align:center;">O(N),N为被复制C字符串的长度</td></tr> <tr><td style="text-align:center;">sdsgrowzero</td> <td style="text-align:center;">用空字符讲SDS扩展至给定长度</td> <td style="text-align:center;">O(N), N为扩展新增的字节数</td></tr> <tr><td style="text-align:center;">sdsrange</td> <td style="text-align:center;">保留SDS给定区间内的数据，不在区间内的数据会被覆盖或清除</td> <td style="text-align:center;">O(N),N为被保留数据的字节数</td></tr> <tr><td style="text-align:center;">sdstrim</td> <td style="text-align:center;">接受一个SDS和一个C字符串作为参数，从SDS中移除所有在C字符串中出现过的字符</td> <td style="text-align:center;">O(N), N为给定C字符串的长度</td></tr> <tr><td style="text-align:center;">sdscmp</td> <td style="text-align:center;">对比两个SDS字符串是否相同</td> <td style="text-align:center;">O(N), N为两个SDS中较短的那个SDS的长度</td></tr></tbody></table> <ol start="4"><li>sds比c字符串的优点</li></ol> <p>a) 常数复杂度获取字符串的长度
b) 杜绝缓冲区溢出
c) 减少修改字符串长度时所需的内存重分配次数
d) 二进制安全
e) 兼容部分C字符串函数</p> <h3 id="链表"><a href="#链表" class="header-anchor">#</a> 链表</h3> <p>链表提供了高效的节点重排能力，以及顺序性的节点访问方式，并且可以通过增删节点来灵活地调整链表地长度。</p> <p>列表键地底层实现之一就是链表。当一个列表键包含了数量比较多的元素，又或者列表中包含元素都是比较长的字符串时，redis就会使用链表作为列表键的底层实现。</p> <p>出了链表键之外，发布与订阅，慢查询，监视器等功能也用到了链表，redis服务器本身还是用链表来保存多个客户端的状态信息，以及使用链表来构建客户端输出缓冲区(output buffer)。</p> <ol><li>链表和链表节点的实现</li></ol> <p>链表节点使用 adlist.h/ listNode结构表示：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">listNode</span> <span class="token punctuation">{</span>
  <span class="token comment">// 前置节点</span>
  <span class="token keyword">struct</span>  <span class="token class-name">listNode</span> <span class="token operator">*</span> prev<span class="token punctuation">;</span>
  <span class="token comment">// 后置节点</span>
  <span class="token keyword">struct</span>  <span class="token class-name">listNode</span> <span class="token operator">*</span> next<span class="token punctuation">;</span>
  <span class="token comment">// 节点的值</span>
  <span class="token keyword">void</span> <span class="token operator">*</span> value<span class="token punctuation">;</span>
<span class="token punctuation">}</span>listNode<span class="token punctuation">;</span>
</code></pre></div><p>仅仅使用多个listNode结构可以组成链表。</p> <p>使用adlist.h/list来持有链表的话，操作起来会更方便：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">list</span> <span class="token punctuation">{</span>
  <span class="token comment">// 表头节点</span>
  listNode <span class="token operator">*</span> head<span class="token punctuation">;</span>
  <span class="token comment">// 表尾节点</span>
  listNode <span class="token operator">*</span> tail<span class="token punctuation">;</span>
  <span class="token comment">// 链表所包含的节点数量</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> len<span class="token punctuation">;</span>
  <span class="token comment">// 节点值复制函数</span>
  <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>dup<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 节点值释放函数</span>
  <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>free<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">//  节点值对比函数</span>
  <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>match<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>list<span class="token punctuation">;</span>
</code></pre></div><ol start="2"><li>链表和链表节点的api</li></ol> <table><thead><tr><th style="text-align:center;">函数</th> <th style="text-align:center;">作用</th> <th style="text-align:center;">时间复杂度</th></tr></thead> <tbody><tr><td style="text-align:center;">listSetDupMethod</td> <td style="text-align:center;">将给定的函数设置为链表的节点值复制函数</td> <td style="text-align:center;">复制函数可以通过链表的dup属性直接获得，O(1)</td></tr> <tr><td style="text-align:center;">listGetDupMethod</td> <td style="text-align:center;">返回链表当前正在使用的节点值复制函数</td> <td style="text-align:center;">O(1)</td></tr> <tr><td style="text-align:center;">listSetFreeMethod</td> <td style="text-align:center;">将给定的函数设置为链表的节点释放函数</td> <td style="text-align:center;">释放函数可以通过链表的free属性直接获得，O(1)</td></tr> <tr><td style="text-align:center;">listGetFree</td> <td style="text-align:center;">返回链表当前正在使用的节点值释放函数</td> <td style="text-align:center;">O(1)</td></tr> <tr><td style="text-align:center;">listSetMatchMethod</td> <td style="text-align:center;">将给定的函数设置为链表的节点值对比函数</td> <td style="text-align:center;">对比函数可以通过链表的match属性直接获得，O(1)</td></tr> <tr><td style="text-align:center;">listGetMatchMethod</td> <td style="text-align:center;">返回链表当前正在使用的节点值对比函数</td> <td style="text-align:center;">O(1)</td></tr> <tr><td style="text-align:center;">listLength</td> <td style="text-align:center;">返回链表的长度(包含了多少个节点)</td> <td style="text-align:center;">链表长度可以通过链表的len属性直接获得，O(1)</td></tr> <tr><td style="text-align:center;">listFirst</td> <td style="text-align:center;">返回链表的表头节点</td> <td style="text-align:center;">表头结点可以通过链表的head属性直接获得，O(1)</td></tr> <tr><td style="text-align:center;">listLast</td> <td style="text-align:center;">返回链表的表尾节点</td> <td style="text-align:center;">表尾结点可以通过链表的tail属性直接获得，O(1)</td></tr> <tr><td style="text-align:center;">listPrevNode</td> <td style="text-align:center;">返回给定节点的前置节点</td> <td style="text-align:center;">前置节点可以通过节点的prev属性直接获得，O(1)</td></tr> <tr><td style="text-align:center;">listNextNode</td> <td style="text-align:center;">返回给定节点的后置节点</td> <td style="text-align:center;">后置节点可以通过节点的next属性直接获得，O(1)</td></tr> <tr><td style="text-align:center;">listNextValue</td> <td style="text-align:center;">返回给定节点目前正在保存的值</td> <td style="text-align:center;">节点值可以通过节点的value属性直接获得，O(1)</td></tr> <tr><td style="text-align:center;">listCreate</td> <td style="text-align:center;">创建一个不包含任何节点的新链表</td> <td style="text-align:center;">O(1)</td></tr> <tr><td style="text-align:center;">listAddNodeHead</td> <td style="text-align:center;">将一个包含给定值的新节点添加到给定链表的表头</td> <td style="text-align:center;">O(1)</td></tr> <tr><td style="text-align:center;">listAddNodeTail</td> <td style="text-align:center;">将一个包含给定值的新节点添加到给定链表的表尾</td> <td style="text-align:center;">O(1)</td></tr> <tr><td style="text-align:center;">listInsertNode</td> <td style="text-align:center;">将一个包含给定值的新节点添加到给定链表的表头</td> <td style="text-align:center;">O(1)</td></tr> <tr><td style="text-align:center;">listSearchKey</td> <td style="text-align:center;">查找并返回链表中包含给定值的节点</td> <td style="text-align:center;">O(N)，N为链表长度</td></tr> <tr><td style="text-align:center;">listIndex</td> <td style="text-align:center;">返回链表在给定索引上的节点</td> <td style="text-align:center;">O(N)，N为链表长度</td></tr> <tr><td style="text-align:center;">listDelNode</td> <td style="text-align:center;">从链表中删除给定节点</td> <td style="text-align:center;">O(N)，N为链表长度</td></tr> <tr><td style="text-align:center;">listRotate</td> <td style="text-align:center;">将链表的表尾节点弹出，然后将被弹出的节点插入到链表的表头，称为新的表头节点</td> <td style="text-align:center;">O(1)</td></tr> <tr><td style="text-align:center;">listDup</td> <td style="text-align:center;">复制一个给定链表的副本</td> <td style="text-align:center;">O(N)，N为链表长度</td></tr> <tr><td style="text-align:center;">listRelease</td> <td style="text-align:center;">释放给定链表，以及链表中的所有节点</td> <td style="text-align:center;">O(N)，N为链表长度</td></tr></tbody></table> <h3 id="字典"><a href="#字典" class="header-anchor">#</a> 字典</h3> <p>字典，又称为符号表(symbol table)，关联数组(associative array)或映射(map),是一种用于保存键值对(key-value pair)的抽象数据结构。</p> <p>字典中的每个键都是独一无二的，程序可以在字典中根据键查找与之关联的值，或通过键来更新值，又或者根据键来删除整个键值对。</p> <p>字典使用哈希表作为底层实现，一个哈希表里面可以有多个哈希表节点，而每个哈希表节点就保存了字典中的一个键值对。</p> <ol><li>哈希表由dict.h/dictht节点定义：</li></ol> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">dictht</span> <span class="token punctuation">{</span>
  <span class="token comment">// 哈希表数组</span>
  dictEntry <span class="token operator">*</span><span class="token operator">*</span>table<span class="token punctuation">;</span>
  <span class="token comment">// 哈希表大小</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> size<span class="token punctuation">;</span>
  <span class="token comment">// 哈希表大小掩码，用于计算索引值</span>
  <span class="token comment">// 总是等于size-1</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> sizemask<span class="token punctuation">;</span>
  <span class="token comment">// 该哈希表已有节点的数量</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> used<span class="token punctuation">;</span>
<span class="token punctuation">}</span>dictht<span class="token punctuation">;</span>
</code></pre></div><p>table属性是一个数组，数组中的每个元素都是一个指向dict.h/dictEntry结构的指针，每个dictEntry结构保存着一个键值对。size属性记录了哈希表的大小，也即table数组的大小，而used属性则记录了哈希表目前已有节点(键值对)的数量。sizemask属性的值总是等于size-1，这个属性和哈希表一起决定一个键应该被放到table数组的哪个索引上面。</p> <p>哈希表节点使用dict.h/dictEntry结构表示，每个dictEntry结构都保存着一个键值对：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">dictEntry</span> <span class="token punctuation">{</span>
  <span class="token comment">// 键</span>
  <span class="token keyword">void</span> <span class="token operator">*</span> key
  <span class="token comment">// 值</span>
  <span class="token keyword">union</span> <span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>val<span class="token punctuation">;</span>
    <span class="token keyword">uint64_t</span> u64<span class="token punctuation">;</span>
    <span class="token keyword">int64_t</span> s64<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>v<span class="token punctuation">;</span>
  <span class="token comment">// 指向下个哈希表节点，形成链表</span>
  <span class="token keyword">struct</span> <span class="token class-name">dicEntry</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>
<span class="token punctuation">}</span>dictEntry<span class="token punctuation">;</span>
</code></pre></div><p>key属性保存着键值对中的键，而v属性则保存着键值对中的值，其中键值对的值可以是一个指针，或者是一个uint64_t整数，又或者是一个int64_t整数。</p> <p>next属性是指向另一个哈希表节点的指针，这个指针可以多个哈希值相同的键值对连接在一次，以此来解决键冲突的问题。</p> <p>而字典的结构为：dict.h/dict结构如下：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">dict</span> <span class="token punctuation">{</span>
  <span class="token comment">// 类型特定函数</span>
  dictType <span class="token operator">*</span>type<span class="token punctuation">;</span>
  <span class="token comment">// 私有数据</span>
  <span class="token keyword">void</span> <span class="token operator">*</span> privdata<span class="token punctuation">;</span>
  <span class="token comment">// 哈希表</span>
  dictht ht<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token comment">// rehash 索引</span>
  <span class="token comment">// 当rehash不在进行时，值为-1</span>
  <span class="token keyword">int</span> rehashidx<span class="token punctuation">;</span>
<span class="token punctuation">}</span>dict<span class="token punctuation">;</span>
</code></pre></div><p>type属性和privdata属性是针对不同类型的键值对，为创建多态字典而设置：</p> <p>type属性是一个指向dictType结构的指针，每个dictType结构保存了一簇用于操作特定类型键值对的函数，redis会为用途不同的字典设置不同的类型特定函数。</p> <p>privdata属性则保存了需要传给那些类型特定函数的可选参数。</p> <p>dictType:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">dictType</span> <span class="token punctuation">{</span>
  <span class="token comment">// 计算哈希值的函数</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>hashFunction<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 复制键的函数</span>
  <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>keyDup<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>privdata<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 复制值的函数</span>
  <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>valDup<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>privdata<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 对比键的函数</span>
  <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>keyCompare<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>privdata<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>key1<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>key2<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 销毁键的函数</span>
  <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>keyDestructor<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>privdata<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 销毁值的函数</span>
  <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>valDestructor<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>privdata<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>dictType<span class="token punctuation">;</span>
</code></pre></div><p>ht属性是一个包含两个项的数组，数组中的每个项都是一个dictht哈希表，一般情况下，字典只使用ht[0]哈希表，ht[1]哈希表只会在对ht[0]哈希表进行rehash时使用。</p> <p>出了ht[1]之外，另一个和rehash有关的属性就是rehashidx，它记录了rehash目前的进度，如果没有进行rehash，那么它的值为-1;</p> <ol start="2"><li>哈希算法</li></ol> <p>redis计算哈希值和索引值的方法如下：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">//  使用字典设置的哈希函数，计算键key的哈希值</span>
hash <span class="token operator">=</span> dict<span class="token operator">-&gt;</span>type<span class="token operator">-&gt;</span><span class="token function">hashFunction</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 使用哈希表的sizemask属性和哈希值，计算出索引值</span>
<span class="token comment">// 根据情况的不同，ht[x]可以是ht[0]或者ht[1]</span>
index <span class="token operator">=</span> hash <span class="token operator">&amp;</span> dict<span class="token operator">-&gt;</span>ht<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">.</span>sizemask<span class="token punctuation">;</span>
</code></pre></div><p>当字典被用作数据库的底层实现，或者哈希键的底层实现时，redis使用MurmurHash2算法来计算键的哈希值。</p> <ol start="3"><li>解决键冲突</li></ol> <p>当key值一样时，使用链地址法来解决hash冲突。使用next指针，且程序总是将新的节点添加到链表的表头位置。</p> <ol start="4"><li>rehash</li></ol> <p>随着操作不断执行，哈希表保存的键值对会逐渐地增加或者减少，为了让哈希表地负载因子维持在一个合理地范围之内。当数量太多或者太少时，会进行相应地扩展或者收缩。</p> <p>rehash步骤：</p> <p>a). 为字典地ht[1]哈希表分配空间，这个哈希表地空间大小取决于要执行的操作，以及ht[0]当前包含的键值对数量(即ht[0].used属性的值)。</p> <p>如果为扩展操作，ht[1]的大小为第一个大于等于ht[0].used*2的2^n。
如果为收缩操作，ht[1]的大小为第一个大于等于ht[0].used的2^n.</p> <p>b). 将保存在ht[0]中的所有键值对rehash到ht[1]上面：rehash指的是重新计算键的哈希值和索引值，然后将键值对放置到ht[1]哈希表的指定位置上。</p> <p>c). 当ht[0]包含的所有键值对都迁移到了ht[1]之后，释放ht[0]，将ht[1]设置为ht[0],并在ht[1]新创建一个空白哈希表，为下一次rehash做准备。</p> <p>满足条件会进行操作：</p> <p>a). 服务器目前没有在执行bgsave命令或者bgrewriteaof命令，并且哈希表的负载因子大于等于1.</p> <p>b). 服务器目前正在执行bgsave命令或者bgrewriteaof命令，并且哈希表的负载因子大于等于5.</p> <p>其中哈希表的负载因子可以通过公式：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>load_factor <span class="token operator">=</span> ht<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>used <span class="token operator">/</span> ht<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>size<span class="token punctuation">;</span>
</code></pre></div><p>渐进式rehash：rehash动作并不是一次性，集中式地完成，而是分多次，渐进式地完成。</p> <p>避免了rehash对服务器性能造成影响，服务器不是以此将ht[0]里面所有地所有键值对全部rehash到ht[1],而是分多次，渐进式地将ht[0]里面地键值对慢慢地rehash到ht[1];</p> <ol start="5"><li>字典api</li></ol> <table><thead><tr><th style="text-align:center;">函数</th> <th style="text-align:center;">作用</th> <th style="text-align:center;">时间复杂度</th></tr></thead> <tbody><tr><td style="text-align:center;">dictCreate</td> <td style="text-align:center;">创建一个新的字典</td> <td style="text-align:center;">O(1)</td></tr> <tr><td style="text-align:center;">dictAdd</td> <td style="text-align:center;">将给定地键值对添加到字典里面</td> <td style="text-align:center;">O(1)</td></tr> <tr><td style="text-align:center;">dictReplace</td> <td style="text-align:center;">将给定地键值对添加到字典里面，如果键已经存在于字典，那么用新值取代原有地值</td> <td style="text-align:center;">O(1)</td></tr> <tr><td style="text-align:center;">dictFetchValue</td> <td style="text-align:center;">返回给定键地值</td> <td style="text-align:center;">O(1)</td></tr> <tr><td style="text-align:center;">dictGetRandomKey</td> <td style="text-align:center;">从字典中随机返回一个键值对</td> <td style="text-align:center;">O(1)</td></tr> <tr><td style="text-align:center;">dictDelete</td> <td style="text-align:center;">从字典中删除给定键值对应地键值对</td> <td style="text-align:center;">O(1)</td></tr> <tr><td style="text-align:center;">dictRelease</td> <td style="text-align:center;">释放给定字典，以及字典中包含地所有键值对</td> <td style="text-align:center;">O(N)</td></tr></tbody></table> <ol start="6"><li>总结</li></ol> <p>a). 字典被广泛用于实现redis地各种功能，其中包括数据库和哈希键</p> <p>b). redis中地字典使用哈希表作为底层实现，每个字典带有两个哈希表，一个平时使用，另一个仅在进行rehash时候使用</p> <p>c). 当字典被用作数据库底层实现，或者哈希键地底层实现时，redis使用MurmurHash2算法来计算键地哈希值。</p> <p>d). 哈希表使用链地址法来解决键冲突，被分配到同一个索引上的多个键值对会连接成一个单向链表。</p> <p>e). 在对哈希表进行扩展或收缩操作时，程序需要将现有哈希表包含的所有键值对rehash到新哈希表里面，并且这个rehash过程并不是一次性地完成，而是渐进式完成地。</p> <h3 id="跳跃表"><a href="#跳跃表" class="header-anchor">#</a> 跳跃表</h3> <p>跳跃表是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。</p> <p>跳跃表支持平均O(logN),最坏O(N)复杂度的节点查找，还可以通过顺序性操作来批量处理节点。</p> <p>redis使用跳跃表作为有序集合键的底层实现之一，如果一个有序包含的元素数量比较多，又或者有序集合中元素的成员是比较长的字符串时，redis就会使用跳跃表来作为有序集合键的底层实现。</p> <p>redis只在两个地方用到了跳跃表，一个是实现有序集合键，另一个是在集群节点中用作内部数据结构。</p> <p>跳跃表由redis.h/zskiplistNode和redis.h/zskiplist两个结构定义，其中zskiplistNode结构用于表示跳跃表节点，</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">/*
 * 跳跃表节点
 */</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">zskiplistNode</span> <span class="token punctuation">{</span>

    <span class="token comment">// 成员对象</span>
    robj <span class="token operator">*</span>obj<span class="token punctuation">;</span>

    <span class="token comment">// 分值</span>
    <span class="token keyword">double</span> score<span class="token punctuation">;</span>

    <span class="token comment">// 后退指针</span>
    <span class="token keyword">struct</span> <span class="token class-name">zskiplistNode</span> <span class="token operator">*</span>backward<span class="token punctuation">;</span>

    <span class="token comment">// 层</span>
    <span class="token keyword">struct</span> <span class="token class-name">zskiplistLevel</span> <span class="token punctuation">{</span>

        <span class="token comment">// 前进指针</span>
        <span class="token keyword">struct</span> <span class="token class-name">zskiplistNode</span> <span class="token operator">*</span>forward<span class="token punctuation">;</span>

        <span class="token comment">// 跨度</span>
        <span class="token keyword">unsigned</span> <span class="token keyword">int</span> span<span class="token punctuation">;</span>

    <span class="token punctuation">}</span> level<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span> zskiplistNode<span class="token punctuation">;</span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">zskiplist</span> <span class="token punctuation">{</span>

    <span class="token comment">// 表头节点和表尾节点</span>
    <span class="token keyword">struct</span> <span class="token class-name">zskiplistNode</span> <span class="token operator">*</span>header<span class="token punctuation">,</span> <span class="token operator">*</span>tail<span class="token punctuation">;</span>

    <span class="token comment">// 表中节点的数量</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> length<span class="token punctuation">;</span>

    <span class="token comment">// 表中层数最大的节点的层数，记录目前跳跃表内，层数最大的那个节点的层数(表头节点的层数不计算在内)</span>
    <span class="token keyword">int</span> level<span class="token punctuation">;</span>

<span class="token punctuation">}</span> zskiplist<span class="token punctuation">;</span>

</code></pre></div><p>zskiplist结构则用于保存跳跃表节点的相关信息，比如节点的数量，以及指向表头节点和表尾节点的指针。</p> <p>zskiplistNode结构，该结构包含以下属性：</p> <p>层(level)：节点中用L1，L2，L3等字样标记节点的各个层，L1代表第一层，L2代表第二层，以此类推。每个层都带有两个属性：前进指针和跨度。前进指针用于访问位于表尾方向的其他节点，而跨度则记录了前进指针所指向节点和当前节点的距离。</p> <p>后退(backward)指针：节点中用BW字样标记节点的后退指针，它指向位于当前节点的前一个节点。后退指针在程序从表尾向表头遍历时使用。</p> <p>分值(score): 保存分值，节点按各自所保存的分值从小到大排列。</p> <p>成员对象(obj):节点所保存的成员对象。</p> <p>每一个元素都包含一个指向其他节点的指针，程序可以通过这些层来加快访问其他节点的速度，一般来说，层的数量越多，访问其他节点的速度就越快。</p> <ol><li>跳跃表api</li></ol> <table><thead><tr><th style="text-align:center;">函数</th> <th style="text-align:center;">作用</th> <th style="text-align:center;">时间复杂度</th></tr></thead> <tbody><tr><td style="text-align:center;">zslCreate</td> <td style="text-align:center;">创建一个新的跳跃表</td> <td style="text-align:center;">O(1)</td></tr> <tr><td style="text-align:center;">zslFree</td> <td style="text-align:center;">释放给跳跃表，以及表中包含的所有节点</td> <td style="text-align:center;">O(N)，N为跳跃表的长度</td></tr> <tr><td style="text-align:center;">zslInsert</td> <td style="text-align:center;">将包含给定成员和分值的新节点添加到跳跃表中</td> <td style="text-align:center;">平均O(logN),最坏为O(N),N为跳跃表长度</td></tr> <tr><td style="text-align:center;">zslDelete</td> <td style="text-align:center;">删除跳跃表中包含给定成员和分值的节点</td> <td style="text-align:center;">平均O(logN),最坏为O(N),N为跳跃表长度</td></tr> <tr><td style="text-align:center;">zslGetRank</td> <td style="text-align:center;">返回包含给定成员和分值的节点在跳跃表中的排位</td> <td style="text-align:center;">平均O(logN),最坏为O(N),N为跳跃表长度</td></tr> <tr><td style="text-align:center;">zslGetElementByRank</td> <td style="text-align:center;">返回跳跃表在给定排位上的节点</td> <td style="text-align:center;">平均O(logN),最坏为O(N),N为跳跃表长度</td></tr> <tr><td style="text-align:center;">zslIsInRnage</td> <td style="text-align:center;">给定一个分值范围，比如0到15，20到28，诸如此类，如果跳跃表中有至少一个节点的分值在这个范围之内，那么返回1，否则返回0</td> <td style="text-align:center;">通过跳跃表的表头节点和表尾节点，这个检测可以用O(1)复杂度完成</td></tr> <tr><td style="text-align:center;">zslFirstInRange</td> <td style="text-align:center;">给定一个分值范围，返回跳跃表中第一个符合这个范围的节点</td> <td style="text-align:center;">平均O(logN),最坏为O(N),N为跳跃表长度</td></tr> <tr><td style="text-align:center;">zslLastInRnage</td> <td style="text-align:center;">给定一个分值范围，返回跳跃表中第一个符合这个范围的节点</td> <td style="text-align:center;">平均O(logN),最坏为O(N),N为跳跃表长度</td></tr> <tr><td style="text-align:center;">zslDeleteRangeByScore</td> <td style="text-align:center;">给定一个分值范围，删除跳跃表中所有在这个范围之内的节点</td> <td style="text-align:center;">O(N),N为被删除的节点</td></tr> <tr><td style="text-align:center;">zslDeleteRangeByRank</td> <td style="text-align:center;">给定一个排位范围，返回跳跃表中第一个符合这个范围的节点</td> <td style="text-align:center;">O(N),N为被删除的节点</td></tr></tbody></table> <ol start="2"><li>重点回顾</li></ol> <p>a). 跳跃表时有序集合的底层实现之一</p> <p>b). redis的跳跃表实现由zskip和zskiplistNode两个结构组成，其中zskiplist用于保存跳跃表信息(比如表头节点，表尾节点，长度)，而zskiplistNode则用于表示跳跃表节点。</p> <p>c). 在同一个跳跃表中，多个节点可以包含相同的分值，但每个节点的成员对象必须是唯一的。</p> <p>d). 跳跃表中的节点按照分值大小进行排序，当分支相同时，节点按照成员对象的大小进行排序。</p> <h3 id="整数集合"><a href="#整数集合" class="header-anchor">#</a> 整数集合</h3> <p>整数集合(intset) 是集合键的底层实现之一，当一个集合只包含整数值元素，并且这个集合的元素数量不多时，redis就会使用整数集合作为集合键的底层实现。</p> <p>整数集合(intset)是redis用于保存整数值的集合抽象数据结构，它可以保存类型为int16_t,int32_t或者int64_t的整数值，并且保证集合中不会出现重复元素。</p> <ol><li>每个intset.h/intset结构表示一个整数集合</li></ol> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">intset</span> <span class="token punctuation">{</span>
  <span class="token comment">// 编码方式</span>
  <span class="token keyword">uint32_t</span> encoding<span class="token punctuation">;</span>
  <span class="token comment">// 集合包含的元素数量</span>
  <span class="token keyword">uint32_t</span> length<span class="token punctuation">;</span>
  <span class="token comment">// 保存元素的数组；</span>
  <span class="token keyword">int8_t</span> contents<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>intset<span class="token punctuation">;</span>
</code></pre></div><p>contents数组是整数集合的底层实现：整数集合的每个元素都是contents数组的一个数组项(item),各个项在数组中按值的大小从小到大有序地排列，并且数组中不包含任何重复项。</p> <p>length属性记录了整数集合包含地元素数量，也即是contents数组的长度。</p> <p>虽然intset结构将contents属性声明为int8_t类型的数组，但实际上contents数组并不保存任何int8_t类型的值，contents数组的真正类型取决于encoding属性的值：</p> <p>a). 如果encoding属性的值为INTSET_ENC_INT16,那么contents就是一个int16_t类型的数组，数组里的每个项都是一个int16_t类型的整数值(最小值为-32768，最大值为32767)</p> <p>b). 如果encoding属性的值为INTSET_ENC_INT32,那么contents就是一个int32_t类型的数组，数组里的每个项都是一个int32_t类型的整数值(最小值为-2147483648，最大值为2147483647)</p> <p>c). 如果encoding属性的值为INTSET_ENC_INT64,那么contents就是一个int64_t类型的数组，数组里的每个项都是一个int64_t类型的整数值(最小值为-9223372036854775808，最大值为9223372036854775807)</p> <ol start="2"><li>升级</li></ol> <p>每当我们将一个新的元素添加到整数集合里面，并且新元素的类型比整数集合现有所有元素的类型都要长时，整数集合需要先进行升级(upgrade),然后才能将新元素添加到整数集合里面。</p> <p>升级步骤分为三步：</p> <p>a). 根据新元素的类型，扩展整数集合底层数组的空间大小，并为新元素分配空间。</p> <p>b). 将底层数组现有的所有元素都转换成与新元素相同的类型，并将类型转换后的元素放置到正确的位上，而且在放置元素的过程中，需要继续维持底层数组的有序性质不同。</p> <p>c). 将新元素添加到底层数组里面。</p> <ol start="3"><li>升级之后新元素的摆放位置</li></ol> <p>因为引发升级的新元素的长度总是比整数集合现有所有元素的长度都大，所以这个新元素的值要么就大于所有现有元素，要么就小于所有现有元素：</p> <p>在新元素小于所有现有元素的情况下，新元素就会放置在底层数组的最开头。</p> <p>在新元素大于所有现有元素的情况下，新元素会被放置在底层数组的最末尾。</p> <ol start="4"><li>升级的好处</li></ol> <p>a). 一个是提升整数集合的灵活性。</p> <p>b). 另一个是尽可能地节约内存(是指在没有64时，不需要用64位的大小)。</p> <ol start="5"><li>降级</li></ol> <p>整数集合不支持降级操作，一旦对数组进行了升级，编码就会一直保持升级后的状态。</p> <ol start="6"><li>intset的api</li></ol> <table><thead><tr><th style="text-align:center;">函数</th> <th style="text-align:center;">作用</th> <th style="text-align:center;">时间复杂度</th></tr></thead> <tbody><tr><td style="text-align:center;">intsetNew</td> <td style="text-align:center;">创建一个新的压缩列表</td> <td style="text-align:center;">O(1)</td></tr> <tr><td style="text-align:center;">intsetAdd</td> <td style="text-align:center;">将给定元素添加到整数集合里面</td> <td style="text-align:center;">O(N)</td></tr> <tr><td style="text-align:center;">intsetRemove</td> <td style="text-align:center;">从整数集合中移除给定元素</td> <td style="text-align:center;">O(N)</td></tr> <tr><td style="text-align:center;">intsetFind</td> <td style="text-align:center;">检查给定值是否存在于集合</td> <td style="text-align:center;">因为底层数组有序，查找可以通过二分查找法进行，所以复杂度为O(logN)</td></tr> <tr><td style="text-align:center;">intsetRandom</td> <td style="text-align:center;">从整数集合中随机返回一个元素</td> <td style="text-align:center;">O(1)</td></tr> <tr><td style="text-align:center;">intsetGet</td> <td style="text-align:center;">取出底层数组在给定索引上的元素</td> <td style="text-align:center;">O(1)</td></tr> <tr><td style="text-align:center;">intsetLen</td> <td style="text-align:center;">返回整数集合包含的元素个数</td> <td style="text-align:center;">O(1)</td></tr> <tr><td style="text-align:center;">intsetBlobLen</td> <td style="text-align:center;">返回整数集合占用的内存字节数</td> <td style="text-align:center;">O(1)</td></tr></tbody></table> <ol start="7"><li>总结</li></ol> <p>a). 整数集合是集合键的底层实现之一</p> <p>b). 整数集合的底层实现为数组，这个数组以有序，无重复的方式保存集合元素，在有需要时，程序会根据新添加元素的类型，改变这个数组的类型。</p> <p>c). 升级操作为整数集合带来了操作上的灵活性，并且尽可能地节约了内存。</p> <p>d). 整数集合只支持升级操作，不支持降级操作。</p> <h3 id="压缩列表"><a href="#压缩列表" class="header-anchor">#</a> 压缩列表</h3> <p>压缩列表(ziplist)是列表键和哈希键的底层实现之一。当一个列表键只包含少量列表项，并且每个列表项要么就是小整数值，要么就是长度比较短的字符串，那么redis就会使用压缩列表来做列表键的底层实现。</p> <ol><li>压缩列表是redis为了节约内存而开发的，是由一系列特殊编码的连续内存块组成的顺序型数据构成。一个压缩列表可以包含任意多个节点，每个节点可以保存一个字节数组或者一个整数值。</li></ol> <p>压缩列表没有结构体，各个组成部分如下：</p> <table><thead><tr><th style="text-align:center;">属性</th> <th style="text-align:center;">类型</th> <th style="text-align:center;">长度</th> <th style="text-align:center;">用途</th></tr></thead> <tbody><tr><td style="text-align:center;">zlbytes</td> <td style="text-align:center;">uint32_t</td> <td style="text-align:center;">4字节</td> <td style="text-align:center;">记录整个压缩列表占用的内存字节数：在对压缩列表进行内存重分配，或者计算zlend的位置时使用</td></tr> <tr><td style="text-align:center;">zltail</td> <td style="text-align:center;">uint32_t</td> <td style="text-align:center;">4字节</td> <td style="text-align:center;">记录压缩列表表尾节点距离压缩列表的起始地址有多少字节：通过这个偏移量，程序无须遍历整个压缩列表就可以确定表尾节点的地址</td></tr> <tr><td style="text-align:center;">zllen</td> <td style="text-align:center;">uint16_t</td> <td style="text-align:center;">2字节</td> <td style="text-align:center;">记录了压缩列表包含的节点数量：当这个额属性的值小于UINT16_MAX(65535)时，这个属性的值就是压缩列表包含节点的数量；当这个值等于uint16_max时，节点的真实数量需要遍历整个压缩列表才能计算得出</td></tr> <tr><td style="text-align:center;">entryX</td> <td style="text-align:center;">列表节点</td> <td style="text-align:center;">不定</td> <td style="text-align:center;">压缩列表包含的各种节点，节点的长度由节点保存的内容决定</td></tr> <tr><td style="text-align:center;">zlend</td> <td style="text-align:center;">uint8_t</td> <td style="text-align:center;">1字节</td> <td style="text-align:center;">特殊值0xFF(255)，用于标记压缩列表的末端</td></tr></tbody></table> <p>每个压缩列表节点可以保存一个字节数组或者一个整数值，其中字节数组可以是以下三种长度的其中一种：</p> <p>a). 长度小于等于63字节的字节数组</p> <p>b). 长度小于等于16383字节的字节数组</p> <p>c). 长度小于等于4294967295字节的字节数组</p> <ol start="2"><li>压缩列表节点的结构</li></ol> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">/*
 * 保存 ziplist 节点信息的结构
 */</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">zlentry</span> <span class="token punctuation">{</span>

    <span class="token comment">// prevrawlen ：前置节点的长度</span>
    <span class="token comment">// prevrawlensize ：编码 prevrawlen 所需的字节大小</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> prevrawlensize<span class="token punctuation">,</span> prevrawlen<span class="token punctuation">;</span>

    <span class="token comment">// len ：当前节点值的长度</span>
    <span class="token comment">// lensize ：编码 len 所需的字节大小</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> lensize<span class="token punctuation">,</span> len<span class="token punctuation">;</span>

    <span class="token comment">// 当前节点 header 的大小</span>
    <span class="token comment">// 等于 prevrawlensize + lensize</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> headersize<span class="token punctuation">;</span>

    <span class="token comment">// 当前节点值所使用的编码类型</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> encoding<span class="token punctuation">;</span>

    <span class="token comment">// 指向当前节点的指针</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>

<span class="token punctuation">}</span> zlentry<span class="token punctuation">;</span>
</code></pre></div><p>redis3的压缩列表节点如上。</p> <p>通过prevrawlensize，prevrawlen和当前节点的指针可以获取计算出前一个节点。所以可以通过尾节点遍历到头节点。</p> <ol start="3"><li>压缩列表的api</li></ol> <table><thead><tr><th style="text-align:center;">函数</th> <th style="text-align:center;">作用</th> <th style="text-align:center;">算法复杂度</th></tr></thead> <tbody><tr><td style="text-align:center;">ziplistNew</td> <td style="text-align:center;">创建一个新的压缩列表</td> <td style="text-align:center;">O(1)</td></tr> <tr><td style="text-align:center;">ziplistPush</td> <td style="text-align:center;">创建一个包含给定值的新节点，并将这个新节点添加到压缩列表的表头或表尾</td> <td style="text-align:center;">平均O(N), 最坏O(N^2)</td></tr> <tr><td style="text-align:center;">ziplistInsert</td> <td style="text-align:center;">将包含给定值的新节点插入到给定节点之后</td> <td style="text-align:center;">平均O(N), 最坏O(N^2),可能会发生连锁更新</td></tr> <tr><td style="text-align:center;">ziplistIndex</td> <td style="text-align:center;">返回压缩列表给定索引上的节点</td> <td style="text-align:center;">O(N)</td></tr> <tr><td style="text-align:center;">ziplistFind</td> <td style="text-align:center;">在压缩列表中查找并返回包含了给定值的节点</td> <td style="text-align:center;">因为节点的值可能是一个字节数组，所以检查节点值和给定值是否相同的复杂度为O(N), 而查找整个列表的复杂度为O(N^2)</td></tr> <tr><td style="text-align:center;">ziplistNext</td> <td style="text-align:center;">返回给定节点的下一个节点</td> <td style="text-align:center;">O(1)</td></tr> <tr><td style="text-align:center;">ziplistPrev</td> <td style="text-align:center;">返回给定节点的前一个节点</td> <td style="text-align:center;">O(1)</td></tr> <tr><td style="text-align:center;">ziplistGet</td> <td style="text-align:center;">获取给定节点所保存的值</td> <td style="text-align:center;">O(1)</td></tr> <tr><td style="text-align:center;">ziplistDetale</td> <td style="text-align:center;">从压缩列表中删除给定的节点</td> <td style="text-align:center;">平均O(N), 最坏O(N^2)</td></tr> <tr><td style="text-align:center;">ziplistDeleteRange</td> <td style="text-align:center;">删除压缩列表在给定索引上的连续多个节点</td> <td style="text-align:center;">平均O(N), 最坏O(N^2)</td></tr> <tr><td style="text-align:center;">ziplistBlobLen</td> <td style="text-align:center;">返回压缩列表目前占用的内存字节数</td> <td style="text-align:center;">O(1)</td></tr> <tr><td style="text-align:center;">ziplistLen</td> <td style="text-align:center;">返回压缩列表目前保存的节点数量</td> <td style="text-align:center;">节点数量小于65535时为O(1), 大于65535时为O(N)</td></tr></tbody></table> <ol start="4"><li>总结</li></ol> <p>a). 压缩列表时一种为节约内存而开发的顺序型数据结构</p> <p>b). 压缩列表被用作列表键和哈希键的底层实现之一</p> <p>c). 压缩列表可以包含多个节点，每个节点可以保存一个字节数组或者整数值。</p> <p>d). 添加新节点到压缩列表，或者从压缩列表中删除节点，可能会引发连锁更新操作，但这种操作出现的机率并不高</p> <h3 id="结构总结"><a href="#结构总结" class="header-anchor">#</a> 结构总结</h3> <p>使用场景：</p> <table><thead><tr><th style="text-align:center;">数据结构</th> <th style="text-align:center;">内部编码</th> <th style="text-align:center;">条件</th></tr></thead> <tbody><tr><td style="text-align:center;">string</td> <td style="text-align:center;">int</td> <td style="text-align:center;">8个字节的长整型</td></tr> <tr><td style="text-align:center;">string</td> <td style="text-align:center;">embstr</td> <td style="text-align:center;">小于等于39个字节的字符串</td></tr> <tr><td style="text-align:center;">string</td> <td style="text-align:center;">raw</td> <td style="text-align:center;">大于39个字节的字符串</td></tr> <tr><td style="text-align:center;">hash</td> <td style="text-align:center;">ziplist</td> <td style="text-align:center;">当哈希类型元素个数小于hash-max-ziplist-entries配置(默认512个)，同时所有值小于hash-max-ziplist-value配置(默认64个字节)</td></tr> <tr><td style="text-align:center;">hash</td> <td style="text-align:center;">hashtable</td> <td style="text-align:center;">当哈希类型无法满足ziplist的条件</td></tr> <tr><td style="text-align:center;">list</td> <td style="text-align:center;">ziplist</td> <td style="text-align:center;">当类型元素个数小于list-max-ziplist-entries配置(默认512个)，同时所有值小于list-max-ziplist-value配置(默认64个字节)</td></tr> <tr><td style="text-align:center;">list</td> <td style="text-align:center;">linkedlist</td> <td style="text-align:center;">当列表无法满足ziplist的条件</td></tr> <tr><td style="text-align:center;">set</td> <td style="text-align:center;">intset</td> <td style="text-align:center;">当集合中元素都是整数且元素个数小于set-max-intset-entries配置(默认512个)</td></tr> <tr><td style="text-align:center;">set</td> <td style="text-align:center;">hashtable</td> <td style="text-align:center;">当不满足intset的条件</td></tr> <tr><td style="text-align:center;">sort set(zset)</td> <td style="text-align:center;">ziplist</td> <td style="text-align:center;">当有序集合的元素个数小于zset-max-ziplist-entries配置(默认128个)，同时每个元素的值小于zset-max-ziplist-value配置(默认64个字节)</td></tr> <tr><td style="text-align:center;">skiplist</td> <td style="text-align:center;">当不满足ziplist条件时</td> <td style="text-align:center;"></td></tr></tbody></table> <h3 id="对象"><a href="#对象" class="header-anchor">#</a> 对象</h3> <p>介绍了redis用到的所有主要数据结构，比如简单动态字符串(SDS),双端链表,字典,压缩列表,整数集合等等。</p> <p>redis使用对象来表示数据库中的键和值，每次当我们在redis的数据库中新创建一个键值对时，我们至少需要创建两个对象，一个对象用作键值对的键(键对象)，另一个对象用作键值对的值(值对象)。</p> <ol><li>redis中的每个对象都由一个redisObject结构表示，该结构中和保存数据有关的三个属性分别为type属性，encoding属性和ptr属性：</li></ol> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">redisObject</span> <span class="token punctuation">{</span>

    <span class="token comment">// 类型</span>
    <span class="token keyword">unsigned</span> type<span class="token operator">:</span><span class="token number">4</span><span class="token punctuation">;</span>

    <span class="token comment">// 编码</span>
    <span class="token keyword">unsigned</span> encoding<span class="token operator">:</span><span class="token number">4</span><span class="token punctuation">;</span>

    <span class="token comment">// 对象最后一次被访问的时间</span>
    <span class="token keyword">unsigned</span> lru<span class="token operator">:</span>REDIS_LRU_BITS<span class="token punctuation">;</span> <span class="token comment">/* lru time (relative to server.lruclock) */</span>

    <span class="token comment">// 引用计数</span>
    <span class="token keyword">int</span> refcount<span class="token punctuation">;</span>

    <span class="token comment">// 指向实际值的指针</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span>

<span class="token punctuation">}</span> robj<span class="token punctuation">;</span>
</code></pre></div><p>type属性记录了对象的类型，这个属性的值可以如下：</p> <table><thead><tr><th style="text-align:center;">类型常量</th> <th style="text-align:center;">对象的名称</th></tr></thead> <tbody><tr><td style="text-align:center;">REDIS_STRING</td> <td style="text-align:center;">字符串对象</td></tr> <tr><td style="text-align:center;">REDIS_LIST</td> <td style="text-align:center;">列表对象</td></tr> <tr><td style="text-align:center;">REDIS_HASH</td> <td style="text-align:center;">哈希对象</td></tr> <tr><td style="text-align:center;">REDIS_SET</td> <td style="text-align:center;">集合对象</td></tr> <tr><td style="text-align:center;">REDIS_ZSET</td> <td style="text-align:center;">有序集合对象</td></tr></tbody></table> <p>type命令的实现方式，当我们对一个数据库键执行type命令时，命令返回的结果为数据库键对应的值对应的类型，而不是键对象的类型。</p> <table><thead><tr><th style="text-align:center;">对象</th> <th style="text-align:center;">对象type属性的值</th> <th style="text-align:center;">TYPE命令的输出</th></tr></thead> <tbody><tr><td style="text-align:center;">字符串对象</td> <td style="text-align:center;">REDIS_STRING</td> <td style="text-align:center;">&quot;string&quot;</td></tr> <tr><td style="text-align:center;">列表对象</td> <td style="text-align:center;">REDIS_LIST</td> <td style="text-align:center;">&quot;list&quot;</td></tr> <tr><td style="text-align:center;">哈希对象</td> <td style="text-align:center;">REDIS_HASH</td> <td style="text-align:center;">&quot;hash&quot;</td></tr> <tr><td style="text-align:center;">集合对象</td> <td style="text-align:center;">REDIS_SET</td> <td style="text-align:center;">&quot;set&quot;</td></tr> <tr><td style="text-align:center;">有序集合对象</td> <td style="text-align:center;">REDIS_ZSET</td> <td style="text-align:center;">&quot;zset&quot;</td></tr></tbody></table> <p>对象的ptr指针指向对象的底层实现数据结构，而这些数据结构由对象的encoding属性决定。</p> <p>encoding属性记录了对象所使用的编码，也即是说这个对象使用了什么数据结构作为对象的底层实现。</p> <table><thead><tr><th style="text-align:center;">编码常量</th> <th style="text-align:center;">编码所对应的底层数据结构</th></tr></thead> <tbody><tr><td style="text-align:center;">REDIS_ENCODING_INT</td> <td style="text-align:center;">long类型的整数</td></tr> <tr><td style="text-align:center;">REDIS_ENCODING_EMBSTR</td> <td style="text-align:center;">embstr编码的简单动态字符串</td></tr> <tr><td style="text-align:center;">REDIS_ENCODING_RAW</td> <td style="text-align:center;">简单动态字符串</td></tr> <tr><td style="text-align:center;">REDIS_ENCODING_HT</td> <td style="text-align:center;">字典</td></tr> <tr><td style="text-align:center;">REDIS_ENCODING_LINKEDLIST</td> <td style="text-align:center;">双端链表</td></tr> <tr><td style="text-align:center;">REDIS_ENCODING_ZIPLIST</td> <td style="text-align:center;">压缩列表</td></tr> <tr><td style="text-align:center;">REDIS_ENCODING_INTSET</td> <td style="text-align:center;">整数集合</td></tr> <tr><td style="text-align:center;">REDIS_ENCODING_SKIPLIST</td> <td style="text-align:center;">跳跃表和字典</td></tr></tbody></table> <p>每种类型的对象都至少使用了两种不同的编码，如下每种类型的对象可以使用的编码：</p> <table><thead><tr><th style="text-align:center;">类型</th> <th style="text-align:center;">编码</th> <th style="text-align:center;">对象</th></tr></thead> <tbody><tr><td style="text-align:center;">REDIS_STRING</td> <td style="text-align:center;">REDIS_ENCODING_INT</td> <td style="text-align:center;">使用整数值实现的字符串对象</td></tr> <tr><td style="text-align:center;">REDIS_STRING</td> <td style="text-align:center;">REDIS_ENCODING_EMBSTR</td> <td style="text-align:center;">使用embstr编码的简单动态字符串实现的字符串对象</td></tr> <tr><td style="text-align:center;">REDIS_STRING</td> <td style="text-align:center;">REDIS_ENCODING_RAW</td> <td style="text-align:center;">使用简单动态字符串实现的字符串对象</td></tr> <tr><td style="text-align:center;">REDIS_LIST</td> <td style="text-align:center;">REDIS_ENCODING_ZIPLIST</td> <td style="text-align:center;">使用压缩列表实现的列表对象</td></tr> <tr><td style="text-align:center;">REDIS_LIST</td> <td style="text-align:center;">REDIS_ENCODING_LINKEDLIST</td> <td style="text-align:center;">使用双端链表实现的列表对象</td></tr> <tr><td style="text-align:center;">REDIS_HASH</td> <td style="text-align:center;">REDIS_ENCODING_ZIPLIST</td> <td style="text-align:center;">使用压缩列表实现的哈希对象</td></tr> <tr><td style="text-align:center;">REDIS_HASH</td> <td style="text-align:center;">REDIS_ENCODING_HT</td> <td style="text-align:center;">使用字典实现的哈希对象</td></tr> <tr><td style="text-align:center;">REDIS_SET</td> <td style="text-align:center;">REDIS_ENCODING_INTSET</td> <td style="text-align:center;">使用整数集合实现的集合对象</td></tr> <tr><td style="text-align:center;">REDIS_SET</td> <td style="text-align:center;">REDIS_ENCODING_HT</td> <td style="text-align:center;">使用字典实现的集合对象</td></tr> <tr><td style="text-align:center;">REDIS_ZSET</td> <td style="text-align:center;">REDIS_ENCODING_ZIPLIST</td> <td style="text-align:center;">使用压缩列表实现的有序集合对象</td></tr> <tr><td style="text-align:center;">REDIS_ZSET</td> <td style="text-align:center;">REDIS_ENCODING_SKIPLIST</td> <td style="text-align:center;">使用跳跃表和字典实现的有序集合对象</td></tr></tbody></table> <p>使用OBJECT ENCODING命令可以查看一个数据库键的值对象的编码</p> <table><thead><tr><th style="text-align:center;">对象所使用的底层数据结构</th> <th style="text-align:center;">编码常量</th> <th style="text-align:center;">OBJECT ENCODING命令输出</th></tr></thead> <tbody><tr><td style="text-align:center;">整数</td> <td style="text-align:center;">REDIS_ENCODING_INT</td> <td style="text-align:center;">&quot;int&quot;</td></tr> <tr><td style="text-align:center;">embstr编码的简单动态字符串(SDS)</td> <td style="text-align:center;">REDIS_ENCODING_EMBSTR</td> <td style="text-align:center;">&quot;embstr&quot;</td></tr> <tr><td style="text-align:center;">简单动态字符串</td> <td style="text-align:center;">REDIS_ENCODING_RAW</td> <td style="text-align:center;">&quot;raw&quot;</td></tr> <tr><td style="text-align:center;">字典</td> <td style="text-align:center;">REDIS_ENCODING_ZIPLIST</td> <td style="text-align:center;">&quot;hashtable&quot;</td></tr> <tr><td style="text-align:center;">双端链表</td> <td style="text-align:center;">REDIS_ENCODING_LINKEDLIST</td> <td style="text-align:center;">&quot;linkedlist&quot;</td></tr> <tr><td style="text-align:center;">压缩列表</td> <td style="text-align:center;">REDIS_ENCODING_ZIPLIST</td> <td style="text-align:center;">&quot;ziplist&quot;</td></tr> <tr><td style="text-align:center;">整数集合</td> <td style="text-align:center;">REDIS_ENCODING_HT</td> <td style="text-align:center;">&quot;intset&quot;</td></tr> <tr><td style="text-align:center;">跳跃表和字典</td> <td style="text-align:center;">REDIS_ENCODING_INTSET</td> <td style="text-align:center;">&quot;skiplist&quot;</td></tr></tbody></table> <p>通过encoding属性来设定对象所使用的编码，而不是为特定类型的对象关联一种固定的编码，极大地提升了redis地灵活性和效率。</p> <ol start="2"><li>字符串对象地编码可以是int，raw或者embstr。</li></ol> <p>使用embstr编码地字符串对象来保存短字符串值有以下好处：</p> <p>a). embstr编码将创建字符串对象所需地内存分配次数从raw编码地两次降低为1次</p> <p>b). 释放embstr编码地字符串对象只需要调用以此内存释放函数，而释放raw编码地字符串独享需要调用两次内存释放函数。</p> <p>c). 因为embstr编码地字符串对象地所有数据都保存再一块连续地内存里面，所以这种编码地字符串对象比起raw编码地字符串对象能够更好地利用缓存带来地优势</p> <ol start="3"><li>列表对象</li></ol> <p>列表对象地编码可以是ziplist或者linkedlist.</p> <ol start="4"><li>哈希对象</li></ol> <p>哈希对象的编码可以是ziplist或者hashtable</p> <ol start="5"><li>集合对象</li></ol> <p>集合对象的编码可以是intset或者hashtable</p> <ol start="6"><li>有序集合对象</li></ol> <p>有序集合的编码可以是ziplist或者skiplist</p> <ol start="7"><li>类型检查</li></ol> <p>redis中用于操作键的命令基本上可以分为两种类型。</p> <p>其中一种命令可以对任何类型的键执行，比如说del命令，expire命令，rename命令，type命令，object命令。</p> <p>而另一种命令只能对特定类型的键执行，比如：</p> <p>a). set, get, append, strlen等命令只能对字符串键执行</p> <p>b). hdel, hset, hget, hlen等命令只能对哈希键执行</p> <p>c). rpush，lpop，linsert，llen等命令只能对列表键执行</p> <p>d). sadd，spop，sinter，scard等命令只能对集合键执行</p> <p>e). zadd，zcard，zrank，zscore等命令只能对有序集合键执行</p> <p>类型检查的实现</p> <p>类型特定命令所进行的类型检查是通过redisObject结构的type属性来实现的：</p> <p>a). 再执行一个类型特定命令之前，服务器会先检查输入数据库键的值对象是否为执行命令所需的类型，如果是的话，服务器就对键执行指定的命令。</p> <p>b). 否则，服务器将拒绝执行命令，并向客户端返回一个类型错误。</p> <ol start="8"><li>多态命令的实现</li></ol> <p>redis出了会根据值对象的类型来判断键是否能够执行指定命令之外，还会根据值对象的编码方式，选择正确的命令实现代码来执行命令。</p> <ol start="9"><li>内存回收</li></ol> <p>C语言并不具备自动内存回收功能，所以redis再自己的对象系统中构建了一个引用计数技术实现的内存回收机制。通过这一机制，程序可以通过跟踪对象的引用技术信息，再适当的时候自动释放对象并进行内存回收。</p> <p>每个对象的引用计数信息由redisObject结构的refcount属性记录。</p> <p>对象的引用计数信息会随着对象的使用状态而不断变化：</p> <p>a). 在创建一个新对象时，引用计数的值会被初始化为1；</p> <p>b). 当对象被一个新程序使用时，它的引用计数值会被增1；</p> <p>c). 当对象不再被一个程序使用时，它的引用计数值会被减1；</p> <p>d). 当对象的引用计数值变为0时，对象所占用的内存会被释放；</p> <p>修改对象引用计数的API</p> <table><thead><tr><th style="text-align:center;">函数</th> <th style="text-align:center;">作用</th></tr></thead> <tbody><tr><td style="text-align:center;">incrRefCount</td> <td style="text-align:center;">将对象的引用计数值增1</td></tr> <tr><td style="text-align:center;">decrRefCount</td> <td style="text-align:center;">将对象的引用计数值减1，当对象的引用计数值等于0时，释放对象</td></tr> <tr><td style="text-align:center;">resetRefCount</td> <td style="text-align:center;">将对象的引用计数值设置为0，但并不释放对象，这个函数通常在需要重新设置对象的引用计数值时使用</td></tr></tbody></table> <ol start="10"><li>对象共享</li></ol> <p>出了用于实现引用计数内存回收机制外，对象的引用计数属性还带有对象共享的作用。</p> <p>让多个键共享同一个值对象需要执行以下两个步骤：</p> <p>a). 将数据库键的值指针指向同一个现有的值对象</p> <p>b). 将被共享的值对象的引用计数增1</p> <ol start="11"><li>对象的空转时长</li></ol> <p>redisObject结构包含的最后一个属性为lru实行，该属性记录了对象最后一次被命令程序访问的时间。</p> <p>OBJECT IDLETIME 命令可以打印出给定键的空转时长，这一空转时长就是通过当前时间减去键的值对象的lru时间计算得出的。</p> <p>注意：</p> <p>OBJECT IDLETIME命令的实现是特殊的，这个命令在访问键的值对象时，不会修改值对象的lru属性。</p> <p>除了可以被OBJECT IDLETIME 命令打印出来之外，键的空转时长还有另外一项作用：如果服务器打开了maxmemory选项，并且服务器用于回收内存的算法为volatile-lru或者allkeys-lru，那么当服务器占用的内存数超过了maxmemory选项所设置的上限值时，空转时长较高的那部分键会优化被服务器释放，从而回收内存。</p> <ol start="12"><li>总结</li></ol> <p>a). redis数据库中的每个键值对的键和值都是一个对象</p> <p>b). redis共有字符串，列表，哈希，集合，有序集合五种类型的对象，每种类型的对象至少都有两种或以上的编码方式，不同的编码可以在不同的使用场景上优化对象的使用效率。</p> <p>c). 服务器在执行某些命令之前，会先检查给定键的类型是否执行指定命令，而检查一个键的类型就是检查键的值对象的类型。</p> <p>d). redis的对象系统带有引用计数实现的内存回收机制，当一个对象不再被使用时，该对象所占用的内存就会被自动释放。</p> <p>e). redis会共享值到0到9999的字符串对象</p> <p>f). 对象会记录自己的最后一次被访问的时间，这个时间可以用于计算对象的空转时间。</p> <h2 id="单机数据库的实现"><a href="#单机数据库的实现" class="header-anchor">#</a> 单机数据库的实现</h2> <h3 id="数据库"><a href="#数据库" class="header-anchor">#</a> 数据库</h3> <p>Redis服务器将所有数据库都保存在服务器状态redis.h/redisServer结构的db数组中，db数组的每个项都是一个redis.h/redisDb结构，每个redisDb结构代表一个数据库：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">redisServer</span> <span class="token punctuation">{</span>

    <span class="token comment">/* General */</span>

    <span class="token comment">// 配置文件的绝对路径</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>configfile<span class="token punctuation">;</span>           <span class="token comment">/* Absolute config file path, or NULL */</span>

    <span class="token comment">// serverCron() 每秒调用的次数</span>
    <span class="token keyword">int</span> hz<span class="token punctuation">;</span>                     <span class="token comment">/* serverCron() calls frequency in hertz */</span>

    <span class="token comment">// 数据库</span>
    redisDb <span class="token operator">*</span>db<span class="token punctuation">;</span>

    <span class="token comment">// 命令表（受到 rename 配置选项的作用）</span>
    dict <span class="token operator">*</span>commands<span class="token punctuation">;</span>             <span class="token comment">/* Command table */</span>
    <span class="token comment">// 命令表（无 rename 配置选项的作用）</span>
    dict <span class="token operator">*</span>orig_commands<span class="token punctuation">;</span>        <span class="token comment">/* Command table before command renaming. */</span>

    <span class="token comment">// 事件状态</span>
    aeEventLoop <span class="token operator">*</span>el<span class="token punctuation">;</span>

    <span class="token comment">// 最近一次使用时钟</span>
    <span class="token keyword">unsigned</span> lruclock<span class="token operator">:</span>REDIS_LRU_BITS<span class="token punctuation">;</span> <span class="token comment">/* Clock for LRU eviction */</span>

    <span class="token comment">// 关闭服务器的标识</span>
    <span class="token keyword">int</span> shutdown_asap<span class="token punctuation">;</span>          <span class="token comment">/* SHUTDOWN needed ASAP */</span>

    <span class="token comment">// 在执行 serverCron() 时进行渐进式 rehash</span>
    <span class="token keyword">int</span> activerehashing<span class="token punctuation">;</span>        <span class="token comment">/* Incremental rehash in serverCron() */</span>

    <span class="token comment">// 是否设置了密码</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>requirepass<span class="token punctuation">;</span>          <span class="token comment">/* Pass for AUTH command, or NULL */</span>

    <span class="token comment">// PID 文件</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>pidfile<span class="token punctuation">;</span>              <span class="token comment">/* PID file path */</span>

    <span class="token comment">// 架构类型</span>
    <span class="token keyword">int</span> arch_bits<span class="token punctuation">;</span>              <span class="token comment">/* 32 or 64 depending on sizeof(long) */</span>

    <span class="token comment">// serverCron() 函数的运行次数计数器</span>
    <span class="token keyword">int</span> cronloops<span class="token punctuation">;</span>              <span class="token comment">/* Number of times the cron function run */</span>

    <span class="token comment">// 本服务器的 RUN ID</span>
    <span class="token keyword">char</span> runid<span class="token punctuation">[</span>REDIS_RUN_ID_SIZE<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">/* ID always different at every exec. */</span>

    <span class="token comment">// 服务器是否运行在 SENTINEL 模式</span>
    <span class="token keyword">int</span> sentinel_mode<span class="token punctuation">;</span>          <span class="token comment">/* True if this instance is a Sentinel. */</span>


    <span class="token comment">/* Networking */</span>

    <span class="token comment">// TCP 监听端口</span>
    <span class="token keyword">int</span> port<span class="token punctuation">;</span>                   <span class="token comment">/* TCP listening port */</span>

    <span class="token keyword">int</span> tcp_backlog<span class="token punctuation">;</span>            <span class="token comment">/* TCP listen() backlog */</span>

    <span class="token comment">// 地址</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>bindaddr<span class="token punctuation">[</span>REDIS_BINDADDR_MAX<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">/* Addresses we should bind to */</span>
    <span class="token comment">// 地址数量</span>
    <span class="token keyword">int</span> bindaddr_count<span class="token punctuation">;</span>         <span class="token comment">/* Number of addresses in server.bindaddr[] */</span>

    <span class="token comment">// UNIX 套接字</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>unixsocket<span class="token punctuation">;</span>           <span class="token comment">/* UNIX socket path */</span>
    mode_t unixsocketperm<span class="token punctuation">;</span>      <span class="token comment">/* UNIX socket permission */</span>

    <span class="token comment">// 描述符</span>
    <span class="token keyword">int</span> ipfd<span class="token punctuation">[</span>REDIS_BINDADDR_MAX<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">/* TCP socket file descriptors */</span>
    <span class="token comment">// 描述符数量</span>
    <span class="token keyword">int</span> ipfd_count<span class="token punctuation">;</span>             <span class="token comment">/* Used slots in ipfd[] */</span>

    <span class="token comment">// UNIX 套接字文件描述符</span>
    <span class="token keyword">int</span> sofd<span class="token punctuation">;</span>                   <span class="token comment">/* Unix socket file descriptor */</span>

    <span class="token keyword">int</span> cfd<span class="token punctuation">[</span>REDIS_BINDADDR_MAX<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">/* Cluster bus listening socket */</span>
    <span class="token keyword">int</span> cfd_count<span class="token punctuation">;</span>              <span class="token comment">/* Used slots in cfd[] */</span>

    <span class="token comment">// 一个链表，保存了所有客户端状态结构</span>
    list <span class="token operator">*</span>clients<span class="token punctuation">;</span>              <span class="token comment">/* List of active clients */</span>
    <span class="token comment">// 链表，保存了所有待关闭的客户端</span>
    list <span class="token operator">*</span>clients_to_close<span class="token punctuation">;</span>     <span class="token comment">/* Clients to close asynchronously */</span>

    <span class="token comment">// 链表，保存了所有从服务器，以及所有监视器</span>
    list <span class="token operator">*</span>slaves<span class="token punctuation">,</span> <span class="token operator">*</span>monitors<span class="token punctuation">;</span>    <span class="token comment">/* List of slaves and MONITORs */</span>

    <span class="token comment">// 服务器的当前客户端，仅用于崩溃报告</span>
    redisClient <span class="token operator">*</span>current_client<span class="token punctuation">;</span> <span class="token comment">/* Current client, only used on crash report */</span>

    <span class="token keyword">int</span> clients_paused<span class="token punctuation">;</span>         <span class="token comment">/* True if clients are currently paused */</span>
    mstime_t clients_pause_end_time<span class="token punctuation">;</span> <span class="token comment">/* Time when we undo clients_paused */</span>

    <span class="token comment">// 网络错误</span>
    <span class="token keyword">char</span> neterr<span class="token punctuation">[</span>ANET_ERR_LEN<span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment">/* Error buffer for anet.c */</span>

    <span class="token comment">// MIGRATE 缓存</span>
    dict <span class="token operator">*</span>migrate_cached_sockets<span class="token punctuation">;</span><span class="token comment">/* MIGRATE cached sockets */</span>


    <span class="token comment">/* RDB / AOF loading information */</span>

    <span class="token comment">// 这个值为真时，表示服务器正在进行载入</span>
    <span class="token keyword">int</span> loading<span class="token punctuation">;</span>                <span class="token comment">/* We are loading data from disk if true */</span>

    <span class="token comment">// 正在载入的数据的大小</span>
    off_t loading_total_bytes<span class="token punctuation">;</span>

    <span class="token comment">// 已载入数据的大小</span>
    off_t loading_loaded_bytes<span class="token punctuation">;</span>

    <span class="token comment">// 开始进行载入的时间</span>
    time_t loading_start_time<span class="token punctuation">;</span>
    off_t loading_process_events_interval_bytes<span class="token punctuation">;</span>

    <span class="token comment">/* Fast pointers to often looked up command */</span>
    <span class="token comment">// 常用命令的快捷连接</span>
    <span class="token keyword">struct</span> <span class="token class-name">redisCommand</span> <span class="token operator">*</span>delCommand<span class="token punctuation">,</span> <span class="token operator">*</span>multiCommand<span class="token punctuation">,</span> <span class="token operator">*</span>lpushCommand<span class="token punctuation">,</span> <span class="token operator">*</span>lpopCommand<span class="token punctuation">,</span>
                        <span class="token operator">*</span>rpopCommand<span class="token punctuation">;</span>


    <span class="token comment">/* Fields used only for stats */</span>

    <span class="token comment">// 服务器启动时间</span>
    time_t stat_starttime<span class="token punctuation">;</span>          <span class="token comment">/* Server start time */</span>

    <span class="token comment">// 已处理命令的数量</span>
    <span class="token keyword">long</span> <span class="token keyword">long</span> stat_numcommands<span class="token punctuation">;</span>     <span class="token comment">/* Number of processed commands */</span>

    <span class="token comment">// 服务器接到的连接请求数量</span>
    <span class="token keyword">long</span> <span class="token keyword">long</span> stat_numconnections<span class="token punctuation">;</span>  <span class="token comment">/* Number of connections received */</span>

    <span class="token comment">// 已过期的键数量</span>
    <span class="token keyword">long</span> <span class="token keyword">long</span> stat_expiredkeys<span class="token punctuation">;</span>     <span class="token comment">/* Number of expired keys */</span>

    <span class="token comment">// 因为回收内存而被释放的过期键的数量</span>
    <span class="token keyword">long</span> <span class="token keyword">long</span> stat_evictedkeys<span class="token punctuation">;</span>     <span class="token comment">/* Number of evicted keys (maxmemory) */</span>

    <span class="token comment">// 成功查找键的次数</span>
    <span class="token keyword">long</span> <span class="token keyword">long</span> stat_keyspace_hits<span class="token punctuation">;</span>   <span class="token comment">/* Number of successful lookups of keys */</span>

    <span class="token comment">// 查找键失败的次数</span>
    <span class="token keyword">long</span> <span class="token keyword">long</span> stat_keyspace_misses<span class="token punctuation">;</span> <span class="token comment">/* Number of failed lookups of keys */</span>

    <span class="token comment">// 已使用内存峰值</span>
    size_t stat_peak_memory<span class="token punctuation">;</span>        <span class="token comment">/* Max used memory record */</span>

    <span class="token comment">// 最后一次执行 fork() 时消耗的时间</span>
    <span class="token keyword">long</span> <span class="token keyword">long</span> stat_fork_time<span class="token punctuation">;</span>       <span class="token comment">/* Time needed to perform latest fork() */</span>

    <span class="token comment">// 服务器因为客户端数量过多而拒绝客户端连接的次数</span>
    <span class="token keyword">long</span> <span class="token keyword">long</span> stat_rejected_conn<span class="token punctuation">;</span>   <span class="token comment">/* Clients rejected because of maxclients */</span>

    <span class="token comment">// 执行 full sync 的次数</span>
    <span class="token keyword">long</span> <span class="token keyword">long</span> stat_sync_full<span class="token punctuation">;</span>       <span class="token comment">/* Number of full resyncs with slaves. */</span>

    <span class="token comment">// PSYNC 成功执行的次数</span>
    <span class="token keyword">long</span> <span class="token keyword">long</span> stat_sync_partial_ok<span class="token punctuation">;</span> <span class="token comment">/* Number of accepted PSYNC requests. */</span>

    <span class="token comment">// PSYNC 执行失败的次数</span>
    <span class="token keyword">long</span> <span class="token keyword">long</span> stat_sync_partial_err<span class="token punctuation">;</span><span class="token comment">/* Number of unaccepted PSYNC requests. */</span>


    <span class="token comment">/* slowlog */</span>

    <span class="token comment">// 保存了所有慢查询日志的链表</span>
    list <span class="token operator">*</span>slowlog<span class="token punctuation">;</span>                  <span class="token comment">/* SLOWLOG list of commands */</span>

    <span class="token comment">// 下一条慢查询日志的 ID</span>
    <span class="token keyword">long</span> <span class="token keyword">long</span> slowlog_entry_id<span class="token punctuation">;</span>     <span class="token comment">/* SLOWLOG current entry ID */</span>

    <span class="token comment">// 服务器配置 slowlog-log-slower-than 选项的值</span>
    <span class="token keyword">long</span> <span class="token keyword">long</span> slowlog_log_slower_than<span class="token punctuation">;</span> <span class="token comment">/* SLOWLOG time limit (to get logged) */</span>

    <span class="token comment">// 服务器配置 slowlog-max-len 选项的值</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> slowlog_max_len<span class="token punctuation">;</span>     <span class="token comment">/* SLOWLOG max number of items logged */</span>
    size_t resident_set_size<span class="token punctuation">;</span>       <span class="token comment">/* RSS sampled in serverCron(). */</span>
    <span class="token comment">/* The following two are used to track instantaneous &quot;load&quot; in terms
     * of operations per second. */</span>
    <span class="token comment">// 最后一次进行抽样的时间</span>
    <span class="token keyword">long</span> <span class="token keyword">long</span> ops_sec_last_sample_time<span class="token punctuation">;</span> <span class="token comment">/* Timestamp of last sample (in ms) */</span>
    <span class="token comment">// 最后一次抽样时，服务器已执行命令的数量</span>
    <span class="token keyword">long</span> <span class="token keyword">long</span> ops_sec_last_sample_ops<span class="token punctuation">;</span>  <span class="token comment">/* numcommands in last sample */</span>
    <span class="token comment">// 抽样结果</span>
    <span class="token keyword">long</span> <span class="token keyword">long</span> ops_sec_samples<span class="token punctuation">[</span>REDIS_OPS_SEC_SAMPLES<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment">// 数组索引，用于保存抽样结果，并在需要时回绕到 0</span>
    <span class="token keyword">int</span> ops_sec_idx<span class="token punctuation">;</span>


    <span class="token comment">/* Configuration */</span>

    <span class="token comment">// 日志可见性</span>
    <span class="token keyword">int</span> verbosity<span class="token punctuation">;</span>                  <span class="token comment">/* Loglevel in redis.conf */</span>

    <span class="token comment">// 客户端最大空转时间</span>
    <span class="token keyword">int</span> maxidletime<span class="token punctuation">;</span>                <span class="token comment">/* Client timeout in seconds */</span>

    <span class="token comment">// 是否开启 SO_KEEPALIVE 选项</span>
    <span class="token keyword">int</span> tcpkeepalive<span class="token punctuation">;</span>               <span class="token comment">/* Set SO_KEEPALIVE if non-zero. */</span>
    <span class="token keyword">int</span> active_expire_enabled<span class="token punctuation">;</span>      <span class="token comment">/* Can be disabled for testing purposes. */</span>
    size_t client_max_querybuf_len<span class="token punctuation">;</span> <span class="token comment">/* Limit for client query buffer length */</span>
    <span class="token keyword">int</span> dbnum<span class="token punctuation">;</span>                      <span class="token comment">/* Total number of configured DBs */</span>
    <span class="token keyword">int</span> daemonize<span class="token punctuation">;</span>                  <span class="token comment">/* True if running as a daemon */</span>
    <span class="token comment">// 客户端输出缓冲区大小限制</span>
    <span class="token comment">// 数组的元素有 REDIS_CLIENT_LIMIT_NUM_CLASSES 个</span>
    <span class="token comment">// 每个代表一类客户端：普通、从服务器、pubsub，诸如此类</span>
    clientBufferLimitsConfig client_obuf_limits<span class="token punctuation">[</span>REDIS_CLIENT_LIMIT_NUM_CLASSES<span class="token punctuation">]</span><span class="token punctuation">;</span>


    <span class="token comment">/* AOF persistence */</span>

    <span class="token comment">// AOF 状态（开启/关闭/可写）</span>
    <span class="token keyword">int</span> aof_state<span class="token punctuation">;</span>                  <span class="token comment">/* REDIS_AOF_(ON|OFF|WAIT_REWRITE) */</span>

    <span class="token comment">// 所使用的 fsync 策略（每个写入/每秒/从不）</span>
    <span class="token keyword">int</span> aof_fsync<span class="token punctuation">;</span>                  <span class="token comment">/* Kind of fsync() policy */</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>aof_filename<span class="token punctuation">;</span>             <span class="token comment">/* Name of the AOF file */</span>
    <span class="token keyword">int</span> aof_no_fsync_on_rewrite<span class="token punctuation">;</span>    <span class="token comment">/* Don't fsync if a rewrite is in prog. */</span>
    <span class="token keyword">int</span> aof_rewrite_perc<span class="token punctuation">;</span>           <span class="token comment">/* Rewrite AOF if % growth is &gt; M and... */</span>
    off_t aof_rewrite_min_size<span class="token punctuation">;</span>     <span class="token comment">/* the AOF file is at least N bytes. */</span>

    <span class="token comment">// 最后一次执行 BGREWRITEAOF 时， AOF 文件的大小</span>
    off_t aof_rewrite_base_size<span class="token punctuation">;</span>    <span class="token comment">/* AOF size on latest startup or rewrite. */</span>

    <span class="token comment">// AOF 文件的当前字节大小</span>
    off_t aof_current_size<span class="token punctuation">;</span>         <span class="token comment">/* AOF current size. */</span>
    <span class="token keyword">int</span> aof_rewrite_scheduled<span class="token punctuation">;</span>      <span class="token comment">/* Rewrite once BGSAVE terminates. */</span>

    <span class="token comment">// 负责进行 AOF 重写的子进程 ID</span>
    pid_t aof_child_pid<span class="token punctuation">;</span>            <span class="token comment">/* PID if rewriting process */</span>

    <span class="token comment">// AOF 重写缓存链表，链接着多个缓存块</span>
    list <span class="token operator">*</span>aof_rewrite_buf_blocks<span class="token punctuation">;</span>   <span class="token comment">/* Hold changes during an AOF rewrite. */</span>

    <span class="token comment">// AOF 缓冲区</span>
    sds aof_buf<span class="token punctuation">;</span>      <span class="token comment">/* AOF buffer, written before entering the event loop */</span>

    <span class="token comment">// AOF 文件的描述符</span>
    <span class="token keyword">int</span> aof_fd<span class="token punctuation">;</span>       <span class="token comment">/* File descriptor of currently selected AOF file */</span>

    <span class="token comment">// AOF 的当前目标数据库</span>
    <span class="token keyword">int</span> aof_selected_db<span class="token punctuation">;</span> <span class="token comment">/* Currently selected DB in AOF */</span>

    <span class="token comment">// 推迟 write 操作的时间</span>
    time_t aof_flush_postponed_start<span class="token punctuation">;</span> <span class="token comment">/* UNIX time of postponed AOF flush */</span>

    <span class="token comment">// 最后一直执行 fsync 的时间</span>
    time_t aof_last_fsync<span class="token punctuation">;</span>            <span class="token comment">/* UNIX time of last fsync() */</span>
    time_t aof_rewrite_time_last<span class="token punctuation">;</span>   <span class="token comment">/* Time used by last AOF rewrite run. */</span>

    <span class="token comment">// AOF 重写的开始时间</span>
    time_t aof_rewrite_time_start<span class="token punctuation">;</span>  <span class="token comment">/* Current AOF rewrite start time. */</span>

    <span class="token comment">// 最后一次执行 BGREWRITEAOF 的结果</span>
    <span class="token keyword">int</span> aof_lastbgrewrite_status<span class="token punctuation">;</span>   <span class="token comment">/* REDIS_OK or REDIS_ERR */</span>

    <span class="token comment">// 记录 AOF 的 write 操作被推迟了多少次</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> aof_delayed_fsync<span class="token punctuation">;</span>  <span class="token comment">/* delayed AOF fsync() counter */</span>

    <span class="token comment">// 指示是否需要每写入一定量的数据，就主动执行一次 fsync()</span>
    <span class="token keyword">int</span> aof_rewrite_incremental_fsync<span class="token punctuation">;</span><span class="token comment">/* fsync incrementally while rewriting? */</span>
    <span class="token keyword">int</span> aof_last_write_status<span class="token punctuation">;</span>      <span class="token comment">/* REDIS_OK or REDIS_ERR */</span>
    <span class="token keyword">int</span> aof_last_write_errno<span class="token punctuation">;</span>       <span class="token comment">/* Valid if aof_last_write_status is ERR */</span>
    <span class="token comment">/* RDB persistence */</span>

    <span class="token comment">// 自从上次 SAVE 执行以来，数据库被修改的次数</span>
    <span class="token keyword">long</span> <span class="token keyword">long</span> dirty<span class="token punctuation">;</span>                <span class="token comment">/* Changes to DB from the last save */</span>

    <span class="token comment">// BGSAVE 执行前的数据库被修改次数</span>
    <span class="token keyword">long</span> <span class="token keyword">long</span> dirty_before_bgsave<span class="token punctuation">;</span>  <span class="token comment">/* Used to restore dirty on failed BGSAVE */</span>

    <span class="token comment">// 负责执行 BGSAVE 的子进程的 ID</span>
    <span class="token comment">// 没在执行 BGSAVE 时，设为 -1</span>
    pid_t rdb_child_pid<span class="token punctuation">;</span>            <span class="token comment">/* PID of RDB saving child */</span>
    <span class="token keyword">struct</span> <span class="token class-name">saveparam</span> <span class="token operator">*</span>saveparams<span class="token punctuation">;</span>   <span class="token comment">/* Save points array for RDB */</span>
    <span class="token keyword">int</span> saveparamslen<span class="token punctuation">;</span>              <span class="token comment">/* Number of saving points */</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>rdb_filename<span class="token punctuation">;</span>             <span class="token comment">/* Name of RDB file */</span>
    <span class="token keyword">int</span> rdb_compression<span class="token punctuation">;</span>            <span class="token comment">/* Use compression in RDB? */</span>
    <span class="token keyword">int</span> rdb_checksum<span class="token punctuation">;</span>               <span class="token comment">/* Use RDB checksum? */</span>

    <span class="token comment">// 最后一次完成 SAVE 的时间</span>
    time_t lastsave<span class="token punctuation">;</span>                <span class="token comment">/* Unix time of last successful save */</span>

    <span class="token comment">// 最后一次尝试执行 BGSAVE 的时间</span>
    time_t lastbgsave_try<span class="token punctuation">;</span>          <span class="token comment">/* Unix time of last attempted bgsave */</span>

    <span class="token comment">// 最近一次 BGSAVE 执行耗费的时间</span>
    time_t rdb_save_time_last<span class="token punctuation">;</span>      <span class="token comment">/* Time used by last RDB save run. */</span>

    <span class="token comment">// 数据库最近一次开始执行 BGSAVE 的时间</span>
    time_t rdb_save_time_start<span class="token punctuation">;</span>     <span class="token comment">/* Current RDB save start time. */</span>

    <span class="token comment">// 最后一次执行 SAVE 的状态</span>
    <span class="token keyword">int</span> lastbgsave_status<span class="token punctuation">;</span>          <span class="token comment">/* REDIS_OK or REDIS_ERR */</span>
    <span class="token keyword">int</span> stop_writes_on_bgsave_err<span class="token punctuation">;</span>  <span class="token comment">/* Don't allow writes if can't BGSAVE */</span>


    <span class="token comment">/* Propagation of commands in AOF / replication */</span>
    redisOpArray also_propagate<span class="token punctuation">;</span>    <span class="token comment">/* Additional command to propagate. */</span>


    <span class="token comment">/* Logging */</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>logfile<span class="token punctuation">;</span>                  <span class="token comment">/* Path of log file */</span>
    <span class="token keyword">int</span> syslog_enabled<span class="token punctuation">;</span>             <span class="token comment">/* Is syslog enabled? */</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>syslog_ident<span class="token punctuation">;</span>             <span class="token comment">/* Syslog ident */</span>
    <span class="token keyword">int</span> syslog_facility<span class="token punctuation">;</span>            <span class="token comment">/* Syslog facility */</span>


    <span class="token comment">/* Replication (master) */</span>
    <span class="token keyword">int</span> slaveseldb<span class="token punctuation">;</span>                 <span class="token comment">/* Last SELECTed DB in replication output */</span>
    <span class="token comment">// 全局复制偏移量（一个累计值）</span>
    <span class="token keyword">long</span> <span class="token keyword">long</span> master_repl_offset<span class="token punctuation">;</span>   <span class="token comment">/* Global replication offset */</span>
    <span class="token comment">// 主服务器发送 PING 的频率</span>
    <span class="token keyword">int</span> repl_ping_slave_period<span class="token punctuation">;</span>     <span class="token comment">/* Master pings the slave every N seconds */</span>

    <span class="token comment">// backlog 本身</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>repl_backlog<span class="token punctuation">;</span>             <span class="token comment">/* Replication backlog for partial syncs */</span>
    <span class="token comment">// backlog 的长度</span>
    <span class="token keyword">long</span> <span class="token keyword">long</span> repl_backlog_size<span class="token punctuation">;</span>    <span class="token comment">/* Backlog circular buffer size */</span>
    <span class="token comment">// backlog 中数据的长度</span>
    <span class="token keyword">long</span> <span class="token keyword">long</span> repl_backlog_histlen<span class="token punctuation">;</span> <span class="token comment">/* Backlog actual data length */</span>
    <span class="token comment">// backlog 的当前索引</span>
    <span class="token keyword">long</span> <span class="token keyword">long</span> repl_backlog_idx<span class="token punctuation">;</span>     <span class="token comment">/* Backlog circular buffer current offset */</span>
    <span class="token comment">// backlog 中可以被还原的第一个字节的偏移量</span>
    <span class="token keyword">long</span> <span class="token keyword">long</span> repl_backlog_off<span class="token punctuation">;</span>     <span class="token comment">/* Replication offset of first byte in the
                                       backlog buffer. */</span>
    <span class="token comment">// backlog 的过期时间</span>
    time_t repl_backlog_time_limit<span class="token punctuation">;</span> <span class="token comment">/* Time without slaves after the backlog
                                       gets released. */</span>

    <span class="token comment">// 距离上一次有从服务器的时间</span>
    time_t repl_no_slaves_since<span class="token punctuation">;</span>    <span class="token comment">/* We have no slaves since that time.
                                       Only valid if server.slaves len is 0. */</span>

    <span class="token comment">// 是否开启最小数量从服务器写入功能</span>
    <span class="token keyword">int</span> repl_min_slaves_to_write<span class="token punctuation">;</span>   <span class="token comment">/* Min number of slaves to write. */</span>
    <span class="token comment">// 定义最小数量从服务器的最大延迟值</span>
    <span class="token keyword">int</span> repl_min_slaves_max_lag<span class="token punctuation">;</span>    <span class="token comment">/* Max lag of &lt;count&gt; slaves to write. */</span>
    <span class="token comment">// 延迟良好的从服务器的数量</span>
    <span class="token keyword">int</span> repl_good_slaves_count<span class="token punctuation">;</span>     <span class="token comment">/* Number of slaves with lag &lt;= max_lag. */</span>


    <span class="token comment">/* Replication (slave) */</span>
    <span class="token comment">// 主服务器的验证密码</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>masterauth<span class="token punctuation">;</span>               <span class="token comment">/* AUTH with this password with master */</span>
    <span class="token comment">// 主服务器的地址</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>masterhost<span class="token punctuation">;</span>               <span class="token comment">/* Hostname of master */</span>
    <span class="token comment">// 主服务器的端口</span>
    <span class="token keyword">int</span> masterport<span class="token punctuation">;</span>                 <span class="token comment">/* Port of master */</span>
    <span class="token comment">// 超时时间</span>
    <span class="token keyword">int</span> repl_timeout<span class="token punctuation">;</span>               <span class="token comment">/* Timeout after N seconds of master idle */</span>
    <span class="token comment">// 主服务器所对应的客户端</span>
    redisClient <span class="token operator">*</span>master<span class="token punctuation">;</span>     <span class="token comment">/* Client that is master for this slave */</span>
    <span class="token comment">// 被缓存的主服务器，PSYNC 时使用</span>
    redisClient <span class="token operator">*</span>cached_master<span class="token punctuation">;</span> <span class="token comment">/* Cached master to be reused for PSYNC. */</span>
    <span class="token keyword">int</span> repl_syncio_timeout<span class="token punctuation">;</span> <span class="token comment">/* Timeout for synchronous I/O calls */</span>
    <span class="token comment">// 复制的状态（服务器是从服务器时使用）</span>
    <span class="token keyword">int</span> repl_state<span class="token punctuation">;</span>          <span class="token comment">/* Replication status if the instance is a slave */</span>
    <span class="token comment">// RDB 文件的大小</span>
    off_t repl_transfer_size<span class="token punctuation">;</span> <span class="token comment">/* Size of RDB to read from master during sync. */</span>
    <span class="token comment">// 已读 RDB 文件内容的字节数</span>
    off_t repl_transfer_read<span class="token punctuation">;</span> <span class="token comment">/* Amount of RDB read from master during sync. */</span>
    <span class="token comment">// 最近一次执行 fsync 时的偏移量</span>
    <span class="token comment">// 用于 sync_file_range 函数</span>
    off_t repl_transfer_last_fsync_off<span class="token punctuation">;</span> <span class="token comment">/* Offset when we fsync-ed last time. */</span>
    <span class="token comment">// 主服务器的套接字</span>
    <span class="token keyword">int</span> repl_transfer_s<span class="token punctuation">;</span>     <span class="token comment">/* Slave -&gt; Master SYNC socket */</span>
    <span class="token comment">// 保存 RDB 文件的临时文件的描述符</span>
    <span class="token keyword">int</span> repl_transfer_fd<span class="token punctuation">;</span>    <span class="token comment">/* Slave -&gt; Master SYNC temp file descriptor */</span>
    <span class="token comment">// 保存 RDB 文件的临时文件名字</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>repl_transfer_tmpfile<span class="token punctuation">;</span> <span class="token comment">/* Slave-&gt; master SYNC temp file name */</span>
    <span class="token comment">// 最近一次读入 RDB 内容的时间</span>
    time_t repl_transfer_lastio<span class="token punctuation">;</span> <span class="token comment">/* Unix time of the latest read, for timeout */</span>
    <span class="token keyword">int</span> repl_serve_stale_data<span class="token punctuation">;</span> <span class="token comment">/* Serve stale data when link is down? */</span>
    <span class="token comment">// 是否只读从服务器？</span>
    <span class="token keyword">int</span> repl_slave_ro<span class="token punctuation">;</span>          <span class="token comment">/* Slave is read only? */</span>
    <span class="token comment">// 连接断开的时长</span>
    time_t repl_down_since<span class="token punctuation">;</span> <span class="token comment">/* Unix time at which link with master went down */</span>
    <span class="token comment">// 是否要在 SYNC 之后关闭 NODELAY ？</span>
    <span class="token keyword">int</span> repl_disable_tcp_nodelay<span class="token punctuation">;</span>   <span class="token comment">/* Disable TCP_NODELAY after SYNC? */</span>
    <span class="token comment">// 从服务器优先级</span>
    <span class="token keyword">int</span> slave_priority<span class="token punctuation">;</span>             <span class="token comment">/* Reported in INFO and used by Sentinel. */</span>
    <span class="token comment">// 本服务器（从服务器）当前主服务器的 RUN ID</span>
    <span class="token keyword">char</span> repl_master_runid<span class="token punctuation">[</span>REDIS_RUN_ID_SIZE<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">/* Master run id for PSYNC. */</span>
    <span class="token comment">// 初始化偏移量</span>
    <span class="token keyword">long</span> <span class="token keyword">long</span> repl_master_initial_offset<span class="token punctuation">;</span>         <span class="token comment">/* Master PSYNC offset. */</span>


    <span class="token comment">/* Replication script cache. */</span>
    <span class="token comment">// 复制脚本缓存</span>
    <span class="token comment">// 字典</span>
    dict <span class="token operator">*</span>repl_scriptcache_dict<span class="token punctuation">;</span>        <span class="token comment">/* SHA1 all slaves are aware of. */</span>
    <span class="token comment">// FIFO 队列</span>
    list <span class="token operator">*</span>repl_scriptcache_fifo<span class="token punctuation">;</span>        <span class="token comment">/* First in, first out LRU eviction. */</span>
    <span class="token comment">// 缓存的大小</span>
    <span class="token keyword">int</span> repl_scriptcache_size<span class="token punctuation">;</span>          <span class="token comment">/* Max number of elements. */</span>

    <span class="token comment">/* Synchronous replication. */</span>
    list <span class="token operator">*</span>clients_waiting_acks<span class="token punctuation">;</span>         <span class="token comment">/* Clients waiting in WAIT command. */</span>
    <span class="token keyword">int</span> get_ack_from_slaves<span class="token punctuation">;</span>            <span class="token comment">/* If true we send REPLCONF GETACK. */</span>
    <span class="token comment">/* Limits */</span>
    <span class="token keyword">int</span> maxclients<span class="token punctuation">;</span>                 <span class="token comment">/* Max number of simultaneous clients */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span> maxmemory<span class="token punctuation">;</span>   <span class="token comment">/* Max number of memory bytes to use */</span>
    <span class="token keyword">int</span> maxmemory_policy<span class="token punctuation">;</span>           <span class="token comment">/* Policy for key eviction */</span>
    <span class="token keyword">int</span> maxmemory_samples<span class="token punctuation">;</span>          <span class="token comment">/* Pricision of random sampling */</span>


    <span class="token comment">/* Blocked clients */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> bpop_blocked_clients<span class="token punctuation">;</span> <span class="token comment">/* Number of clients blocked by lists */</span>
    list <span class="token operator">*</span>unblocked_clients<span class="token punctuation">;</span> <span class="token comment">/* list of clients to unblock before next loop */</span>
    list <span class="token operator">*</span>ready_keys<span class="token punctuation">;</span>        <span class="token comment">/* List of readyList structures for BLPOP &amp; co */</span>


    <span class="token comment">/* Sort parameters - qsort_r() is only available under BSD so we
     * have to take this state global, in order to pass it to sortCompare() */</span>
    <span class="token keyword">int</span> sort_desc<span class="token punctuation">;</span>
    <span class="token keyword">int</span> sort_alpha<span class="token punctuation">;</span>
    <span class="token keyword">int</span> sort_bypattern<span class="token punctuation">;</span>
    <span class="token keyword">int</span> sort_store<span class="token punctuation">;</span>


    <span class="token comment">/* Zip structure config, see redis.conf for more information  */</span>
    size_t hash_max_ziplist_entries<span class="token punctuation">;</span>
    size_t hash_max_ziplist_value<span class="token punctuation">;</span>
    size_t list_max_ziplist_entries<span class="token punctuation">;</span>
    size_t list_max_ziplist_value<span class="token punctuation">;</span>
    size_t set_max_intset_entries<span class="token punctuation">;</span>
    size_t zset_max_ziplist_entries<span class="token punctuation">;</span>
    size_t zset_max_ziplist_value<span class="token punctuation">;</span>
    size_t hll_sparse_max_bytes<span class="token punctuation">;</span>
    time_t unixtime<span class="token punctuation">;</span>        <span class="token comment">/* Unix time sampled every cron cycle. */</span>
    <span class="token keyword">long</span> <span class="token keyword">long</span> mstime<span class="token punctuation">;</span>       <span class="token comment">/* Like 'unixtime' but with milliseconds resolution. */</span>


    <span class="token comment">/* Pubsub */</span>
    <span class="token comment">// 字典，键为频道，值为链表</span>
    <span class="token comment">// 链表中保存了所有订阅某个频道的客户端</span>
    <span class="token comment">// 新客户端总是被添加到链表的表尾</span>
    dict <span class="token operator">*</span>pubsub_channels<span class="token punctuation">;</span>  <span class="token comment">/* Map channels to list of subscribed clients */</span>

    <span class="token comment">// 这个链表记录了客户端订阅的所有模式的名字</span>
    list <span class="token operator">*</span>pubsub_patterns<span class="token punctuation">;</span>  <span class="token comment">/* A list of pubsub_patterns */</span>

    <span class="token keyword">int</span> notify_keyspace_events<span class="token punctuation">;</span> <span class="token comment">/* Events to propagate via Pub/Sub. This is an
                                   xor of REDIS_NOTIFY... flags. */</span>


    <span class="token comment">/* Cluster */</span>

    <span class="token keyword">int</span> cluster_enabled<span class="token punctuation">;</span>      <span class="token comment">/* Is cluster enabled? */</span>
    mstime_t cluster_node_timeout<span class="token punctuation">;</span> <span class="token comment">/* Cluster node timeout. */</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>cluster_configfile<span class="token punctuation">;</span> <span class="token comment">/* Cluster auto-generated config file name. */</span>
    <span class="token keyword">struct</span> <span class="token class-name">clusterState</span> <span class="token operator">*</span>cluster<span class="token punctuation">;</span>  <span class="token comment">/* State of the cluster */</span>

    <span class="token keyword">int</span> cluster_migration_barrier<span class="token punctuation">;</span> <span class="token comment">/* Cluster replicas migration barrier. */</span>
    <span class="token comment">/* Scripting */</span>

    <span class="token comment">// Lua 环境</span>
    lua_State <span class="token operator">*</span>lua<span class="token punctuation">;</span> <span class="token comment">/* The Lua interpreter. We use just one for all clients */</span>
    
    <span class="token comment">// 复制执行 Lua 脚本中的 Redis 命令的伪客户端</span>
    redisClient <span class="token operator">*</span>lua_client<span class="token punctuation">;</span>   <span class="token comment">/* The &quot;fake client&quot; to query Redis from Lua */</span>

    <span class="token comment">// 当前正在执行 EVAL 命令的客户端，如果没有就是 NULL</span>
    redisClient <span class="token operator">*</span>lua_caller<span class="token punctuation">;</span>   <span class="token comment">/* The client running EVAL right now, or NULL */</span>

    <span class="token comment">// 一个字典，值为 Lua 脚本，键为脚本的 SHA1 校验和</span>
    dict <span class="token operator">*</span>lua_scripts<span class="token punctuation">;</span>         <span class="token comment">/* A dictionary of SHA1 -&gt; Lua scripts */</span>
    <span class="token comment">// Lua 脚本的执行时限</span>
    mstime_t lua_time_limit<span class="token punctuation">;</span>  <span class="token comment">/* Script timeout in milliseconds */</span>
    <span class="token comment">// 脚本开始执行的时间</span>
    mstime_t lua_time_start<span class="token punctuation">;</span>  <span class="token comment">/* Start time of script, milliseconds time */</span>

    <span class="token comment">// 脚本是否执行过写命令</span>
    <span class="token keyword">int</span> lua_write_dirty<span class="token punctuation">;</span>  <span class="token comment">/* True if a write command was called during the
                             execution of the current script. */</span>

    <span class="token comment">// 脚本是否执行过带有随机性质的命令</span>
    <span class="token keyword">int</span> lua_random_dirty<span class="token punctuation">;</span> <span class="token comment">/* True if a random command was called during the
                             execution of the current script. */</span>

    <span class="token comment">// 脚本是否超时</span>
    <span class="token keyword">int</span> lua_timedout<span class="token punctuation">;</span>     <span class="token comment">/* True if we reached the time limit for script
                             execution. */</span>

    <span class="token comment">// 是否要杀死脚本</span>
    <span class="token keyword">int</span> lua_kill<span class="token punctuation">;</span>         <span class="token comment">/* Kill the script if true. */</span>


    <span class="token comment">/* Assert &amp; bug reporting */</span>

    <span class="token keyword">char</span> <span class="token operator">*</span>assert_failed<span class="token punctuation">;</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>assert_file<span class="token punctuation">;</span>
    <span class="token keyword">int</span> assert_line<span class="token punctuation">;</span>
    <span class="token keyword">int</span> bug_report_start<span class="token punctuation">;</span> <span class="token comment">/* True if bug report header was already logged. */</span>
    <span class="token keyword">int</span> watchdog_period<span class="token punctuation">;</span>  <span class="token comment">/* Software watchdog period in ms. 0 = off */</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>在初始化服务器时，程序会根据服务器状态的dbnum属性来决定应该创建多少个数据库;默认情况下，该选项的值为16，所以redis服务器默认会创建16个数据库。</p> <h3 id="切换数据库"><a href="#切换数据库" class="header-anchor">#</a> 切换数据库</h3> <p>每个redis客户端都由自己的目标数据库，每当客户端执行数据库写命令或者数据库读命令的时候，目标数据库就会成为这些命令的操作对象。</p> <p>默认情况下，redis客户端的目标数据库为0号数据库，但客户端可以通过执行select命令来切换目标数据库。</p> <p>通过修改redisClient.db指针，让它指向服务器中的不同数据库，从而实现切换目标数据库的功能。</p> <h3 id="数据库键空间"><a href="#数据库键空间" class="header-anchor">#</a> 数据库键空间</h3> <p>redis是一个键值对数据库服务器，服务器中的每个数据库都由一个redis.h/redisDb结构表示，其中，redisDb结构的dict字典保存了数据库中的所有键值对，我们将这个字典称为键空间。</p> <p>键空间的键也就是数据库的键，每个键都是一个字符串对象。</p> <p>键空间的值也就是数据库的值，每个值可以是字符串对象，列表对象，哈希表对象，集合对象和有序集合对象中的任意一种redis对象。</p> <p>读写键空间时的维护操作：</p> <p>服务器不仅会对键空间执行指定的读写操作，还会执行一些额外的维护操作。如下：</p> <p>a). 读取一个键之后，服务器会根据键是否存在来更新服务器的键空间命中(hit)次数或键空间不命中(miss)次数，这两个值可以在INFO stats命令的keyspace_hits属性和keyspace_misses属性中查看。</p> <p>b). 在读取一个键之后，服务器会更新键的LRU时间，这个值可以用于计算键的闲置时间，使用OBJECT idletime命令可以查看键key的闲置时间。</p> <p>c). 如果有客户端使用WATCH命令监视了某个键，那么服务器在对被监视的键进行修改之后，会将这个键标记为脏(dirty),从而让事务程序注意到这个键已经被修改过。</p> <p>d). 服务器每次修改了一个键之后，都会对脏(dirty)键计数器的值增1，这个计数器会触发服务器的持久化以及复制操作。</p> <p>e). 如果服务器开启了数据库通知功能，那么在对键进行修改后，服务器将按配置发送相应的数据库通知。</p> <h3 id="设置键的生存时间或过期时间"><a href="#设置键的生存时间或过期时间" class="header-anchor">#</a> 设置键的生存时间或过期时间</h3> <p>通过expire命令或者pexpire命令，客户端可以以秒或者毫秒精度为数据库中某个键设置生存时间(Time To Live,TTL),在经过指定的秒数或者毫秒数之后，服务器就会自动删除生存时间为0的键。</p> <p>SETEX命令可以在设置一个字符串键的同时为键设置过期时间，因为这个命令是一个类型限定的命令。</p> <p>设置过期时间：</p> <p>redis有四个不同的命令可以用于设置键的生存时间或过期时间</p> <p>a). expire <key><ttl> 命令用于将键key的生存时间设置为ttl秒</ttl></key></p> <p>b). pexpire <key><ttl> 命令用于将键key的生存时间设置为ttl毫秒</ttl></key></p> <p>c). expireat <key><timestamp> 命令用于将键key的过期时间设置为timestamp所指定的秒数时间戳。</timestamp></key></p> <p>d). pexpireat <key><timestamp> 命令用于将键key的过期时间设置为timestamp所指定的毫秒数时间戳</timestamp></key></p> <p>实际上,expire, pexpire, expireat三个命令都是使用pexpireat命令来实现的。</p> <p>expire命令可以转换成pexpire命令：</p> <div class="language-py extra-class"><pre class="language-py"><code><span class="token keyword">def</span> <span class="token function">expire</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> ttl_in_sec<span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token comment"># 将TTL从秒转换成毫秒</span>
  ttl_in_ms <span class="token operator">=</span> sec_to_ms<span class="token punctuation">(</span>ttl_in_sec<span class="token punctuation">)</span>
  PEXPIRE<span class="token punctuation">(</span>key<span class="token punctuation">,</span> ttl_in_ms<span class="token punctuation">)</span>
</code></pre></div><p>pexpire命令又可以转换成pexpireat命令：</p> <div class="language-py extra-class"><pre class="language-py"><code><span class="token keyword">def</span> <span class="token function">pexpire</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> ttl_in_ms<span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token comment"># 获取以毫秒计算的当前UNIX时间戳</span>
  now_ms <span class="token operator">=</span> get_current_unix_timestamp_in_ms<span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token comment"># 当前时间加上TTL, 得出毫秒格式的键过期时间</span>
  PEXPIREAT<span class="token punctuation">(</span>key<span class="token punctuation">,</span> now_ms <span class="token operator">+</span> ttl_in_ms<span class="token punctuation">)</span>
</code></pre></div><p>同时，expireat命令也可以转换成pexpireat命令：</p> <div class="language-py extra-class"><pre class="language-py"><code><span class="token keyword">def</span> <span class="token function">expireat</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> expire_time_in_sec<span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token comment"># 将过期时间从秒转换为毫秒</span>
  expire_time_in_ms <span class="token operator">=</span> sec_to_ms<span class="token punctuation">(</span>expire_time_in_sec<span class="token punctuation">)</span>
  PEXPIREAT<span class="token punctuation">(</span>key<span class="token punctuation">,</span> expire_time_in_ms<span class="token punctuation">)</span>
</code></pre></div><p>保存过期时间：</p> <p>redisDb结构的expires字典保存了数据库中所有键的过期时间，我们称这个字典为过期字典：</p> <p>a). 过期字典的键是一个指针，这个指针指向键空间中的某个键对象(也即是某个数据库键)</p> <p>b). 过期字典的值是一个long long类型的整数，这个整数保存了键所指向的数据库键的过期时间————一个毫秒精度的UNIX时间戳。</p> <p>移除过期时间: PERSIST命令可以移除一个键的过期时间。</p> <p>计算并返回剩余生存时间：TTL命令以秒为单位返回键的剩余生存时间，而PTTL命令则以毫秒为单位返回键的剩余生存时间。</p> <p>过期键的判定：</p> <p>a). 检查给定键是否存在于过期字典：如果存在，那么取得键的过期时间</p> <p>b). 检查当前UNIX时间戳是否大于键的过期时间，如果是的话，那么键已经过期，否则的话，键未过期。</p> <h3 id="过期键删除策略"><a href="#过期键删除策略" class="header-anchor">#</a> 过期键删除策略</h3> <ol><li>常用的过期键删除策略：</li></ol> <p>a). 定时删除：在设置键的过期时间的同时，创建一个定时器(timer)，让定时器在键的过期时间来临时，立即执行对键的删除操作。对内存友好，对CPU不友好。</p> <p>b). 惰性删除：放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键；如果没有过期，就返回改键。对CPU友好，对内存不友好。</p> <p>c). 定期删除：每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。至于要删除多少过期键，以及要检查多少个数据库，则由算法决定。CPU和友好的折中选择。</p> <ol start="2"><li>redis的过期键删除策略</li></ol> <p>redis服务器实际使用的是惰性删除和定期删除两种策略：通过配合使用这两种删除策略，服务器可以很好地在合理使用CPU时间和避免浪费内存空间之间取得平衡。</p> <ol start="3"><li>惰性删除策略的实现</li></ol> <p>过期键的惰性删除策略由db.c/expireIfNeeded函数实现，所有读写数据库的redis命令在执行之前都会调用expirelfNeeded函数对输入键进行检查：</p> <p>如果输入键已经过期，那么expireIfNeeded函数将输入键从数据库中删除。</p> <p>如果输入键未过期，那么expireIfNeeded函数不做动作。</p> <p>expireIfNeeded函数就像一个过滤器，它可以在命令真正执行之前，过期掉过期的输入键，从而避免命令接触到过期键。</p> <ol start="4"><li>定期删除策略的实现</li></ol> <p>过期键的定期删除策略由redis.c/activeExpireCycle函数实现，每当redis的服务器周期性操作redis.c/serverCron函数执行时，activeExpireCycle函数就会被调用，它在规定时间内，分多次遍历服务器中的各个数据库，从数据库的expires字典中随机检查一部分键的过期时间，并删除其中的过期键。</p> <p>activeExpireCycle函数的工作模式可以总结如下：</p> <p>a). 函数每次运行时，都从一定数量的数据库中取出一定数量的随机键进行检查，并删除其中的过期键。</p> <p>b). 全局变量current_db会记录当前activeExpireCycle函数检查的进度，并在下一次activeExpireCycle函数调用时，接着上一次的进度进行处理。</p> <p>c). 随着activeExpireCycle函数的不断执行，服务器中的所有数据库都会被检查一遍，这时函数将current_db变量重置为0，然后再次开始新一轮的检查工作。</p> <ol start="5"><li>AOF,RDB和复制功能对过期键的处理</li></ol> <p>a). RDB的复制功能对过期键处理</p> <p>执行save命令或者bgsave命令创建一个rdb文件时，程序会对数据库中的键进行检查，已过期的键不会被保存到新创建的RDB文件中。</p> <p>在启动redis服务器时，如果服务器开启了RDB功能，那么服务器将对RDB文件进行载入：</p> <p>如果服务器以主服务器模式运行，那么在载入RDB文件时，程序会对文件中保存的键进行检查，未过期的键会被载入到数据库中，而过期键则会被忽略，所以过期键对载入RDB文件的主服务器不会造成影响。</p> <p>如果服务器以从服务器模式运行，那么在载入RDB文件时，文件中保存的所有键，不论是否过期，都会被载入到数据库中。</p> <p>b). AOF功能对过期键的处理</p> <p>AOF写入：当服务器以AOF持久化模式运行时，如果数据库中的某个键已经过期，但它还没有被惰性删除或者定期删除，那么AOF文件不会因为这个过期键而产生任何影响。</p> <p>AOF重写：AOF重写的过程中，程序会对数据库中的键进行检查，已过期的键不会被保存到重写后的AOF文件中。</p> <p>c). 复制</p> <p>当服务器运行在复制模式下时，从服务器的过期键删除动作由主服务器控制：</p> <p>主服务器在删除一个过期键之后，会显式地向所有从服务器发送一个DEL命令，告知从服务器删除这个键。</p> <p>从服务器在执行客户端发送地命令时，即使碰到过期键也不会将过期键删除，而是继续像处理未过期地键一样来处理过期键。</p> <p>从服务器只有在接到主服务器发来地DEL命令之后，才会删除过期键。</p> <h3 id="数据库通知"><a href="#数据库通知" class="header-anchor">#</a> 数据库通知</h3> <ol><li>数据库通知是redis2.8版本新增加地功能，这个功能可以让客户端通过订阅给定地频道或者模式，来获知数据库中键的变化，以及数据库中命令的执行情况。</li></ol> <div class="language-shell extra-class"><pre class="language-shell"><code>subscribe __keyspace@0__:message
</code></pre></div><p>该命令对键message进行操作都会进行监听。</p> <p>关注&quot;某个键执行了什么命令&quot;的通知称为键空间通知。</p> <div class="language-shell extra-class"><pre class="language-shell"><code>subscribe __keyevent@0__:del
</code></pre></div><p>该命令任何执行del命令的键进行监听</p> <p>服务器配置的notify-keyspace-events选项决定了服务器所发送通知的类型：</p> <p>a). 想让服务器发送所有类型的键空间通知和键事件通知，可以将选项的值设置为AKE</p> <p>b). 想让服务器发送所有类型的键空间通知，可以将选项的值设置为AK</p> <p>c). 想让服务器发送所有类型的键事件通知，可以将选项的值设置为AE</p> <p>d). 想让服务器只发送和字符串键有关的键空间通知，可以将选项的值设置为K$</p> <p>e). 想让服务器只发送和列表键有关的键事件通知，可以将选项的值设置为EI.</p> <ol start="2"><li>发送通知</li></ol> <p>发送数据库通知的功能是由notify.c/notifyKeyspaceEvent函数实现的</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">notifyKeyspaceEvent</span><span class="token punctuation">(</span><span class="token keyword">int</span> type<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> event<span class="token punctuation">,</span> robj<span class="token operator">*</span> key<span class="token punctuation">,</span> <span class="token keyword">int</span> dbid<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>event,keys和dbid分别是事件的名称，产生事件的键，以及产生事件的数据库号码，函数会根据type参数以及这三个参数来构建事件通知的内容，以及接收通知的频道名</p> <p>notifyKeyspaceEvent函数实现的伪代码如下：</p> <div class="language-py extra-class"><pre class="language-py"><code><span class="token keyword">def</span> <span class="token function">notifyKeyspaceEvent</span><span class="token punctuation">(</span><span class="token builtin">type</span><span class="token punctuation">,</span> event<span class="token punctuation">,</span> key<span class="token punctuation">,</span> dbid<span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token comment"># 如果给定的通知不是服务器允许发送的通知，那么直接返回</span>
  <span class="token keyword">if</span> <span class="token keyword">not</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>notify_keyspace_events <span class="token operator">&amp;</span> <span class="token builtin">type</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span>
  <span class="token comment"># 发送键空间通知</span>
  <span class="token keyword">if</span> server<span class="token punctuation">.</span>notify_keyspace_events <span class="token operator">&amp;</span> REDIS_NOTIFY_KEYSPACE<span class="token punctuation">:</span>
    <span class="token comment"># 将通知发送给频道__keyspace@&lt;dbid&gt;__:&lt;key&gt;</span>
    <span class="token comment"># 内容为键所发生的事件&lt;event&gt;</span>
    <span class="token comment"># 构建频道名字</span>
    chan <span class="token operator">=</span> <span class="token string">&quot;__keyspace@{dbid}__:{key}&quot;</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>dbid<span class="token operator">=</span>dbid<span class="token punctuation">,</span> key<span class="token operator">=</span>key<span class="token punctuation">)</span>
    <span class="token comment"># 发送通知</span>
    pubsubPublishMessage<span class="token punctuation">(</span>chan<span class="token punctuation">,</span> event<span class="token punctuation">)</span>
  
  <span class="token keyword">if</span> server<span class="token punctuation">.</span>notify_keyspace_events <span class="token operator">&amp;</span> REDIS_NOTIFY_KEYEVENT<span class="token punctuation">:</span>
    <span class="token comment"># 将通知发送给频道 __keyevent@&lt;dbid&gt;__:&lt;event&gt;</span>
    <span class="token comment"># 内容为发生事件的键&lt;key&gt;</span>
    <span class="token comment"># 构建频道名称</span>
    chan <span class="token operator">=</span> <span class="token string">&quot;__keyevent@{dbid}__:{event}&quot;</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>dbid<span class="token operator">=</span>dbid<span class="token punctuation">,</span>event<span class="token operator">=</span>event<span class="token punctuation">)</span>
    <span class="token comment"># 发送通知</span>
    pubsubPublishMessage<span class="token punctuation">(</span>chan<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
</code></pre></div><p>notifyKeyspaceEvent函数执行以下操作：</p> <p>a). server.notify_keyspace_events属性就是服务器配置notify-keyspace-events选项所设置的值，如果给定的通知类型type不是服务器允许发送的通知类型，那么函数会直接返回，不做任何动作。</p> <p>b). 如果给定的通知是服务器允许发送的通知，那么下一步函数会检测服务器是否允许发送键空间通知，如果允许的话，程序就会构建并发送事件通知。</p> <p>c). 最后，函数检测服务器是否允许发送键事件通知，如果允许的话，程序就会构建并发送事件通知。</p> <p>pubsubPublishMessage函数是PUBLISH命令的实现函数，执行这个函数等同执行PUBLISH命令，订阅数据库通知的客户端收到的信号就是由这个函数发出的。</p> <h3 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h3> <p>a). redis服务器的所有数据库都保存在redisServer.db数组中，而数据库的数量则由redisServer.db中num属性保存。</p> <p>b). 客户端通过修改目标数据库指针，让它指向redisServer.db数组中的不同元素来切换不同的数据库。</p> <p>c). 数据库主要由dict和expires两个字典构成，其中dict字典负责保存键值对，而expires字典则负责保存键的过期时间。</p> <p>d). 因为数据库由字典构成，所以对数据库的操作都是建立在字典操作之上的。</p> <p>e). 数据库的键总是一个字符串对象，而值则可以是任何一种redis对象类型，包括字符串对象，哈希表对象，集合对象，列表对象和有序集合对象，分别对应字符串键，哈希表键，集合键，列表键和有序集合键。</p> <p>f). expires字典的键指向数据库中的某个键，而值则记录了数据库键的过期时间，过期时间是一个以毫秒为单位的UNIX时间戳</p> <p>g). redis使用惰性删除和定性删除两种策略来删除过期的键：惰性删除策略只在碰到过期键时才进行删除操作，定期删除策略则每隔一段时间主动查找并删除过期键。</p> <p>h). 执行SAVE命令或者BGSAVE命令所产生的新RDB文件不会包含已经过期的键</p> <p>i). 执行BGREWRITAOF命令所产生的重写AOF文件不会包含已经过期的键</p> <p>j). 当一个过期键被删除之后，服务器会追加一条DEL命令到现有AOF文件的末尾，显示地删除过期键。</p> <p>k). 当主服务器删除一个过期键之后，它会向所有从服务器发送一条DEL命令，显式地删除过期键</p> <p>l). 从服务器即使发现过期键也不会自作主张地删除它，而是等待主节点发来DEL命令，这种统一，中心化地过期键删除策略可以保证主从服务器数据地一致性。</p> <p>m). 当redis命令对数据库进行修改之后，服务器会根据配置向客户端发送数据库通知。</p> <h2 id="rdb文件的创建与载入"><a href="#rdb文件的创建与载入" class="header-anchor">#</a> RDB文件的创建与载入</h2> <ol><li>有两个Redis命令可以用于生成RDB文件，一个是SAVE，另一个是BGSAVE.</li></ol> <p>SAVE命令会阻塞redis服务器进程，直到RDB文件创建完毕为止，在服务器进程阻塞期间，服务器不能处理任何请求。</p> <p>BGSAVE命令会派生出一个子进程，然后由子进程负责创建RDB文件，服务器进程(父进程)继续处理命令请求。</p> <ol start="2"><li>RDB文件创建的工作由rdb.c/rdbSave函数完成，SAVE命令和BGSAVE命令会以不同的方式调用这个函数，以下为伪代码</li></ol> <div class="language-py extra-class"><pre class="language-py"><code><span class="token keyword">def</span> <span class="token function">SAVE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token comment"># 创建RDB文件</span>
  rdbSave<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">def</span> <span class="token function">BGSAVE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token comment"># 创建子进程</span>
  pid <span class="token operator">=</span> fork<span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">if</span> pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>
    <span class="token comment"># 子进程负责创建RDB文件</span>
    rdbSave<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment"># 完成之后向父进程发送信号</span>
    signal_parent<span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">elif</span> pid <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">:</span>
    <span class="token comment"># 父进程继续处理命令请求，并通过轮询等待子进程的信号</span>
    handle_request_and_wait_signal<span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">else</span><span class="token punctuation">:</span>
    <span class="token comment"># 处理出错情况</span>
    handle_fork_error<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><ol start="3"><li><p>RDB文件的载入工作是服务器启动时自动执行的，所以Redis并没有专门用于载入RDB文件的命令，只要redis服务器在启动时检测到RDB文件存在，它就会自动载入RDB文件。</p></li> <li><p>AOF文件的更新频率通常比RDB文件的更新频率高，所以：</p></li></ol> <p>a). 如果服务器开启了AOF持久化功能，那么服务器会优先使用AOF文件来还原数据库状态。</p> <p>b). 只有在AOF持久化功能处于关闭状态时，服务器才会使用RDB文件来还原数据库状态。</p> <p>载入RDB文件的实际工作由rdb.c/rdbLoad函数完成。</p> <ol start="5"><li>SAVE命令执行时的服务器状态</li></ol> <p>当SAVE命令执行时，Redis服务器会被阻塞，所以当SAVE命令正在执行时，客户端发送的所有命令请求都会被拒绝。</p> <p>只有在服务器执行完SAVE命令，重新开始接受命令请求之后，客户端发送的命令才会被处理。</p> <ol start="6"><li>BGSAVE命令执行时的服务器状态</li></ol> <p>BGSAVE命令的保存工作是由子进程执行的，在子进程创建RDB文件的过程中，Redis服务器仍然可以继续处理客户端的命令请求，但是，在BGSAVE命令执行期间，服务器处理SAVE,BGSAVE,BGREWRITEAOF三个命令的方式会和平时有所不同。</p> <p>在BGSAVE命令执行期间，客户端发送SAVE命令会被服务器拒绝，服务器禁止SAVE命令和BGSAVE命令同时执行是为了避免父进程和子进程同时执行两个rdbSave调用，防止产生竞争条件。</p> <p>在BGSAVE命令执行期间，客户端发送的BGSAVE命令会被服务器拒绝，同时两个BGSAVE命令也会产生竞争条件。</p> <p>在BGSAVE命令执行期间，BGREWRITEAOF和BGSAVE两个命令不能同时执行：a). 如果BGSAVE命令正在执行，那么客户端发送的BGREWRITEAOF命令会被延迟到BGSAVE命令执行完毕之后执行。b). 如果BGREWRITEAOF命令正在执行，那么客户端发送的BGSAVE命令会被服务器拒绝。</p> <p>因为BGREWRITEAOF和BGSAVE两个命令的实际工作都由子进程执行，所以这两个命令在操作方面并没有冲突的地方，不能同时执行它们只是一个性能方面的考虑————并发两个子进程，并且两个子进程都同时执行大量的磁盘写入操作，并不是一个好的方法。</p> <ol start="7"><li>RDB文件载入时的服务器状态</li></ol> <p>服务器在载入RDB文件期间，会一直处于阻塞状态，直到载入工作完成为止。</p> <ol start="8"><li>自动间隔性保存</li></ol> <p>用户可以通过设置服务器配置的save选项，让服务器每隔一段时间自动执行一次BGSAVE命令，用户可以通过save选项设置多个保存条件，但只要其中任意一个条件被满足，服务器就会执行BGSAVE命令。</p> <div class="language- extra-class"><pre class="language-text"><code>save 900 1
save 300 10
save 60 10000
</code></pre></div><p>上述三条命令(redis的默认条件)，只需要满足以下三个条件中的任意一个，BGSAVE命令就会被执行：</p> <p>a). 服务器在900秒之内，对数据库进行了至少1次修改</p> <p>b). 服务器在300秒之内，对数据库进行了至少10次修改</p> <p>c). 服务器在60秒之内，对数据库进行了至少10000次修改</p> <p>服务器程序会根据save选项所设置的保存条件，设置服务器状态redisServer结构的saveparams属性：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">redisServer</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  <span class="token comment">// 记录了保存条件的数组</span>
  <span class="token keyword">struct</span> <span class="token class-name">saveparam</span> <span class="token operator">*</span>saveparams<span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>saveparams属性时一个数组，数组中的每个元素都是一个saveparam结构，每个saveparam结构都保存了一个save选项设置的保存条件：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">saveparam</span> <span class="token punctuation">{</span>
  <span class="token comment">// 秒数</span>
  time_t seconds<span class="token punctuation">;</span>
  <span class="token comment">// 修改数</span>
  <span class="token keyword">int</span> changes<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><ol start="9"><li>dirty计数器和lastsave属性</li></ol> <p>除了saveparams数组之外，服务器状态还维持着一个dirty计数器，以及一个lastsave属性：</p> <p>a). dirty计数器记录距离上一次成功执行SAVE命令或者BGSAVE命令之后，服务器对数据库状态(服务器中的所有数据库)进行了多少次修改(包括写入，删除，更新等操作)。</p> <p>b). lastsave属性是一个UNIX时间戳，记录了服务器上一次成功执行SAVE命令或者BGSAVE命令的时间。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">redisServer</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  <span class="token comment">// 修改计数器</span>
  <span class="token keyword">long</span> <span class="token keyword">long</span> dirty<span class="token punctuation">;</span>
  <span class="token comment">// 上一次执行保存的时间</span>
  time_t lastsave<span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>当服务器成功执行一次数据库修改命令之后，程序就会对dirty计数器进行更新：命令修改了多少次数据库，dirty计数器的值就增加多少。</p> <ol start="10"><li>检查保存条件是否满足</li></ol> <p>redis的服务器周期性操作函数serverCron默认每隔100毫秒就会执行一次，该函数用于对正在运行的服务器进行维护，它的其中一项工作就是检查save选项所设置的保存条件是否已经满足，如果满足的话，就执行BGSAVE命令。</p> <p>serverCron函数检查保存条件的过程：</p> <div class="language-py extra-class"><pre class="language-py"><code><span class="token keyword">def</span> <span class="token function">serverCron</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token comment">#... </span>
  <span class="token comment"># 遍历所有保存条件</span>
  <span class="token keyword">for</span> saveparam <span class="token keyword">in</span> server<span class="token punctuation">.</span>saveparams<span class="token punctuation">:</span>
    <span class="token comment"># 计算距离上次执行保存操作有多少秒</span>
    save_interval <span class="token operator">=</span> unixtime_now<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> server<span class="token punctuation">.</span>lastsave
    <span class="token comment"># 如果数据库状态的修改次数超过条件所设置的次数</span>
    <span class="token comment"># 并且距离上次保存的时间超过条件所设置的时间</span>
    <span class="token comment"># 那么执行保存操作</span>
    <span class="token keyword">if</span> server<span class="token punctuation">.</span>dirty <span class="token operator">&gt;=</span> saveparam<span class="token punctuation">.</span>changes <span class="token keyword">and</span> save_interval <span class="token operator">&gt;</span> saveparam<span class="token punctuation">.</span>seconds<span class="token punctuation">:</span>
      BGSAVE<span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token comment"># ...</span>
</code></pre></div><p>程序会遍历并检查saveparams数组中的所有保存条件，只要有任何一个条件被满足，那么服务器就会执行BGSAVE命令。</p> <h3 id="rdb文件结构"><a href="#rdb文件结构" class="header-anchor">#</a> RDB文件结构</h3> <ol><li>RDB文件主要由以下几个部分组成：</li></ol> <p>REDIS, db_version, databases, EOF, check_sum</p> <p>注：用全大写单词标示常量，用全小写单词标示变量和数据。</p> <p>a). RDB文件的最开头是REDIS部分，这个部分的长度为5字节，保存着&quot;REDIS&quot;五个字符。</p> <p>通过这五个字符，程序可以在载入文件时，快速检查所载入的文件是否RDB文件。</p> <p>RDB文件保存着的是二进制数据，而不是C字符串，所以REDIS为五个字符，而不是C语言字符串。</p> <p>b). db_version长度为4个字节，它的值是一个字符串表示的整数，记录了RDB文件的版本号。</p> <p>databases部分包含着零个或任意多个数据库，以及各个数据库中的键值对数据：</p> <p>如果服务器的数据库状态为空(所有数据库都为空)，那么这个部分也为空，长度为0字节。</p> <p>如果服务器的数据库状态为非空(有至少一个数据库非空)，那么这个部分也为非空，根据数据库所保存键值对的数量，类型和内容不同，这个部分的长度也会有所不同。</p> <p>c). EOF常量的长度为1字节，标志着RDB文件正文内容的结束，当读入程序遇到这个值时，所有数据库的所有键值对都已经载入完毕了。</p> <p>d). check_num是一个8字节长的无符号整数，保存着一个校验和，这个校验和是程序通过对REDIS, db_version, databases, EOF四个部分的内容进行计算得出的。服务器在载入RDB文件时，会将载入数据所计算出的校验和与check_sum所记录的校验和进行比对，以此来检查RDB文件是否有出错或者损坏的情况出现。</p> <ol start="2"><li>databases部分介绍</li></ol> <p>一个RDB文件的databases部分可以保存任意多个非空数据库。</p> <p>每个非空数据库在RDB文件中都可以保存为SELECTDB, db_number, key_value_pairs三个部分。</p> <p>SELECTDB常量的长度为1字节，当读入程序遇到这个值的时候，将读入一个数据库号码。</p> <p>db_number保存着一个数据库号码，根据号码的大小不同，这个部分的长度可以是1字节，2字节或者5字节。当程序读入db_number部分之后，服务器会调用SELECT命令，根据读入的数据库号码进行数据库切换，使得之后读入的键值对可以载入到正确的数据库中。</p> <p>key_value_pairs部分保存了数据库中的所有键值对数据。</p> <ol start="3"><li>key_value_pairs部分</li></ol> <p>如果键值对带有过期时间，那么过期时间也会和键值对保存在一起，根据键值对的数量，类型，内容以及是否有过期时间等条件的不同，key_value_pairs部分的长度也会有所不同。</p> <p>不带过期时间的键值对在RDB文件中由TYPE, key, value三部分组成。</p> <p>TYPE记录了value的类型，长度为1字节，值可以是以下常量的其中一个：</p> <p>a). REDIS_RDB_TYPE_STRING</p> <p>b). REDIS_RDB_TYPE_LIST</p> <p>c). REDIS_RDB_TYPE_SET</p> <p>d). REDIS_RDB_TYPE_ZSET</p> <p>e). REDIS_RDB_TYPE_HASH</p> <p>f). REDIS_RDB_TYPE_LIST_ZIPLIST</p> <p>g). REDIS_RDB_TYPE_SET_INTSET</p> <p>h). REDIS_RDB_TYPE_ZSET_ZIPLIST</p> <p>i). REDIS_RDB_TYPE_HASH_ZIPLIST</p> <p>程序会根据type的值来决定如何读入和解释value的数据。key和value分别保存了键值对的键对象和值对象：</p> <p>a). 其中key总是一个字符串对象，它的编码方式和REDIS_RDB_TYPE_STRING类型的value一样。根据内容长度的不同，key的长度也会有所不同。</p> <p>b). 根据TYPE类型的不同，以及保存内容长度的不同，保存value的结构和长度也会有所不同。</p> <p>带有过期时间的键值对在RDB文件中的结构由EXPIRETIME_MS, ms, TYPE, key, value 五个部分组成。</p> <p>其中TYPE， key， value三个部分和不带有过期时间的三个部分完全相同。</p> <p>EXPIRETIME_MS 和 ms意义如下：</p> <p>a). EXPIRETIME_MS常量的长度为1字节，它告知读入程序，接下来要读入的将是一个以毫秒的单位的过期时间</p> <p>b). ms是一个8字节长的带符号整数，记录着一个以毫秒为单位的UNIX时间戳，这个时间就是键值对的过期时间。</p> <ol start="4"><li>value的编码</li></ol> <p>RDB文件中的每个value部分都保存了一个值对象，每个值对象的类型都由与之对应的TYPE记录，根据类型的不同，value部分的结构，长度也会有所不同。</p> <p>a). 字符串对象</p> <p>如果TYPE的值为REDIS_RDB_TYPE_STRING，那么value保存的就是一个字符串对象，字符串对象的编码可以是REDIS_ENCODING_INT 或者 REDIS_ENCODING_RAW.</p> <p>如果字符串对象的编码为REDIS_ENCODING_INT，那么说明对象中保存的是长度不超过32位的整数，这种编码的对象将以 ENCODING, integer的结构保存。</p> <p>其中ENCODING的值可以是REDIS_RDB_ENC_INT8, REDIS_RDB_ENC_INT16 或者 REDIS_RDB_ENC_INT32三个常量的其中一个，分别代表RDB文件使用8位，16位或者32位来保存整数值integer。</p> <p>如果字符串对象的编码为 REDIS_ENCODING_RAW, 那么说明对象所保存的是一个字符串值，根据字符串长度的不同，有压缩和不压缩两种方法来保存这个字符串：如果字符串的长度小于等于20字节，那么字符串会直接原样保存；如果字符串的长度大于20字节，那么字符串会被压缩之后再保存(需要打开RDB文件压缩功能)。</p> <p>b). 列表对象</p> <p>如果TYPE的值为REDIS_RDB_TYPE_LIST, 那么value保存的就是一个REDIS_ENCODING_LINKEDLIST 编码的列表对象。</p> <p>RDB的结构为：</p> <p>list_length, item1, item2, ... itemN</p> <p>list_length记录了列表的长度，它记录列表保存了多个项(item), 读入程序可以通过这个长度知道应该读入多少个列表项。</p> <p>c). 集合对象</p> <p>如果TYPE的值为REDIS_RDB_TYPE_SET, 那么value保存的就是一个REDIS_ENCODING_HT编码的集合对象。</p> <p>RDB的结构为：</p> <p>set_size,  elem1,  elem2, ... elemN</p> <p>其中，set_size是集合的大小，它记录集合保存了多少个元素，读入程序可以通过这个大小知道自己应该读入多少个集合元素。</p> <p>d). 哈希表对象</p> <p>如果TYPE的值为 REDIS_RDB_TYPE_HASH, 那么value保存的就是一个REDIS_ENCODING_HT编码的集合对象。</p> <p>RDB的结构为：</p> <p>hash_size,  key_value_pair 1, key_value_pair 2, ... key_value_pair N</p> <p>其中hash_size记录了哈希表的大小，也即是这个哈希表保存了多少键值对，读入程序可以通过这个大小知道自己应该读入多少个键值对。</p> <p>以key_value_pair开头的部分代表哈希表中的键值对，键值对的键和值都是字符串对象，所以程序会以处理字符串对象的方式来保存和读入键值对。</p> <p>RDB更详细的结构为：</p> <p>hash_size, key1, value1, key2, value2, ... keyN, valueN</p> <p>e). 有序集合对象</p> <p>如果TYPE的值为REDIS_RDB_TYPE_ZSET, 那么value保存的就是一个REDIS_ENCODING_SKIPLIST 编码的有序集合对象。</p> <p>RDB的结构为：</p> <p>sorted_set_size,  element1, element2, ... elementN</p> <p>sorted_set_size记录了有序集合的大小，也即是这个有序集合保存了多少元素，读入程序需要根据这个值来决定应该读入多少个有序集合元素。</p> <p>RDB更详细的结构为：</p> <p>sorted_set_size, member1, score1, member2, score2, ... memberN, scoreN</p> <p>f). INTSET编码的集合</p> <p>如果TYPE的值为REDIS_RDB_TYPE_SET_INTSET, 那么value保存的就是一个整数集合对象，RDB文件保存这种对象的方法是，先将整数集合转换为字符串对象，然后将这个字符串对象保存到RDB文件里面。</p> <p>g). ZIPLIST编码的列表，哈希表或者有序集合</p> <p>如果TYPE的值为REDIS_RDB_TYPE_LIST_ZIPLIST, REDIS_RDB_TYPE_ZSET_ZIPLIST 或者 REDIS_RDB_TYPE_HASH_ZIPLIST，那么value保存的就是一个压缩列表对象，RDB文件保存这种对象的方法是：</p> <p>将压缩列表转换成一个字符串对象。</p> <p>将转换所得的字符串对象保存到RDB文件。</p> <h3 id="分析rdb文件"><a href="#分析rdb文件" class="header-anchor">#</a> 分析RDB文件</h3> <ol><li>可以使用od命令分析RDB文件，可以使用-c参数可以以ASCII编码的方式打印输入文件，给定-x参数可以以十六进制的方式打印输入文件。</li></ol> <p>在redis的安装路径，执行</p> <div class="language-shell extra-class"><pre class="language-shell"><code>od -c dump.rdb
<span class="token comment">## 或者</span>
od -x dump.rdb
</code></pre></div><p>可以通过打印的信息与上节中五个部分相对应(五个字节的&quot;REDIS&quot;字符串，版本号，databases信息，一个字节的EOF常量，八个字节的校验和)。</p> <ol start="2"><li>redis本身带有RDB文件检查工具redis-check-dump, 网上也能找到很多处理的工具。</li></ol> <h3 id="总结-2"><a href="#总结-2" class="header-anchor">#</a> 总结</h3> <p>a). RDB文件用于保存和还原Redis服务器所有数据库中的所有键值对数据。</p> <p>b). SAVE命令由服务器进程直接执行保存操作，所以该命令会阻塞服务器。</p> <p>c). BGSAVE令由子进程执行保存操作，所以该命令不会阻塞服务器。</p> <p>d). 服务器状态中会保存所有用save选项设置的保存条件，当任意一个保存条件被满足时，服务器会自动执行BGSAVE命令。</p> <p>e). RDB文件是一个经过压缩的二进制文件，由多个部分组成</p> <p>f). 对于不同类型的键值对，RDB文件会使用不同的方式来保存它们。</p> <h2 id="aof持久化"><a href="#aof持久化" class="header-anchor">#</a> AOF持久化</h2> <p>AOF持久化是通过保存Redis服务器所执行的写命令来记录数据库状态的。</p> <p>RDB为将键值对保存到RDB文件中，而AOF持久化是将每个命令保存到AOF文件中。</p> <p>被写入AOF文件的所有命令都是以Redis的命令请求协议格式保存的。</p> <h3 id="aof持久化的实现"><a href="#aof持久化的实现" class="header-anchor">#</a> AOF持久化的实现</h3> <p>AOF持久化功能的实现可以分为命令追加(append), 文件写入，文件同步(sync)三个步骤。</p> <ol><li>命令追加</li></ol> <p>当AOF持久化功能处于打开状态时，服务器在执行完一个写命令之后，会以协议格式将被执行的写命令追加到服务器状态的aof_buf缓冲区的末尾。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">redisServer</span> <span class="token punctuation">{</span>
  <span class="token comment">// ..</span>
  <span class="token comment">// AOF缓冲区</span>
  sds aof_buf<span class="token punctuation">;</span>
  <span class="token comment">// ..</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><ol start="2"><li>AOF文件的写入与同步</li></ol> <p>redis的服务器进程就是一个事件循环(loop),这个循环中的文件事件负责接收客户端的命令请求，以及向客户端发送命令回复，而时间事件则负责执行像serverCron函数这样需要定时运行的函数。</p> <p>因为服务器在处理文件事件时可能会执行写命令，使得一些内容被追加到aof_buf缓冲区里面，所以在服务器每次结束一个事件循环之前，它都会调用flushAppendOnlyFile函数，考虑是否需要将aof_bug缓冲区中的内容写入和保存到AOF文件里面。</p> <p>伪代码如下：</p> <div class="language-py extra-class"><pre class="language-py"><code><span class="token keyword">def</span> <span class="token function">eventLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
    <span class="token comment"># 处理文件事件，接收命令请求以及发送命令回复</span>
    <span class="token comment"># 处理命令请求时可能会有新内容被追加到aof_buf缓冲区中</span>
    processFileEvent<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment"># 处理时间事件</span>
    processTimeEvents<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment"># 考虑是否要将 aof_buf中的内容写入和保存到AOF文件里面</span>
    flushAppendOnlyFile<span class="token punctuation">(</span><span class="token punctuation">)</span>

</code></pre></div><p>flushAppendOnlyFile函数的行为由服务器配置的appendfsync选项的值来决定。</p> <table><thead><tr><th style="text-align:center;">appendfsync选项的值</th> <th style="text-align:center;">flushAppendOnlyFile函数的行为</th></tr></thead> <tbody><tr><td style="text-align:center;">always</td> <td style="text-align:center;">将aof_buf缓冲区中所有内容写入并同步到AOF文件</td></tr> <tr><td style="text-align:center;">everysec</td> <td style="text-align:center;">将aof_buf缓冲区中的所有内容写入到AOF文件，如果上次同步AOF文件的时间距离现在超过一秒钟，那么再次对AOF文件进行同步，并且这个同步操作是由一个线程专门负责执行的</td></tr> <tr><td style="text-align:center;">no</td> <td style="text-align:center;">将aof_buf缓冲区中的所有内容写入到AOF文件，但并不对AOF文件进行同步，何时同步由操作系统来决定</td></tr></tbody></table> <p>默认选项为everysec。</p> <ol start="3"><li>文件的写入和同步</li></ol> <p>为了提高文件的写入效率，在现代操作系统中，当用户调用write函数，将一些数据写入到文件的时候，操作系统通常会将写入数据暂时保存在一个内存缓冲区里面，等到缓冲区的空间被填满，或者超过了指定的时限之后，才真正地将缓冲区中地数据写入到磁盘里面。</p> <p>做法虽然提供了效率，但也为写入数据带来了安全问题，因为如果计算机发生停机，那么保存在内存缓冲区里面地写入数据将会丢失。</p> <p>因此，系统提供了fsync和sdatasync两个同步方法函数，它们可以强制让操作系统立即将缓冲区中地数据写入到硬盘里面，从而保证写入数据地安全性。</p> <p>假设服务器当前appendsync选项的值为everysec，并且距离上次同步AOF文件已经超过一秒钟，那么服务器会先将aof_buf中的内容写入到AOF文件中，然后再对AOF文件进行同步。</p> <ol start="4"><li>AOF持久化的效率和安全性</li></ol> <p>服务器配置appendfsync选项的值直接决定AOF持久化功能的效率和安全性。</p> <p>a). 当appendfsync的值为always时，服务器再每个事件循环都要讲aof_buf缓冲区中的所有文件写入到aof文件，并且同步aof文件，所以always的效率是appendfsync选项三个值当中最慢的一个，但从安全性来说，always也是最安全的，因为即使出现故障停机，aof持久化也只是丢失一个事件循环中所产生的命令数据。</p> <p>b). 当appendfsync的值为everysec时，服务器再每个事件循环都要将aof_bug缓冲区中的所有内容写入到aof文件，并且每隔一秒就要再子线程中对aof文件进行以此同步。从效率上来讲，everysec模式足够快，并且就算出现故障停机，数据库也只丢失一秒钟的命令数据。</p> <p>c). 当appendfsync的值为no时，服务器再每隔事件循环都要将aof_buf缓冲区中的所有内容写入到aof文件，至于何时对aof文件进行同步，则由操作系统控制。当出现故障停机时，使用no模式的服务器将丢失上次同步AOF文件之后的所有写命令数据。</p> <h3 id="aof文件的载入与数据还原"><a href="#aof文件的载入与数据还原" class="header-anchor">#</a> AOF文件的载入与数据还原</h3> <p>AOF文件里面包含了重建数据库状态所需的所有写命令，所以服务器只要读入并重新执行一遍AOF文件里面保存的写命令，就可以还原服务器关闭前的数据库状态。</p> <ol><li>redis读取aof文件并还原数据库状态的详细步骤</li></ol> <p>a). 创建一个不带网络连接的伪客户端(fake client): 因为redis的命令只能在客户端上下文执行，而载入aof文件时所使用的命令直接来源于aof文件而不是网络连接，所以服务器使用了一个没有网络连接的伪客户端来执行aof文件保存的写命令，伪客户端执行命令的效果和带网络连接的客户端执行命令的效果完全一样。</p> <p>b). 从aof文件中分析并读取出一条写命令</p> <p>c). 使用伪客户端执行被读出的写命令</p> <p>d). 一直执行步骤2和步骤3，直到AOF文件中的所有写命令都被处理完毕为止。</p> <h3 id="aof重写"><a href="#aof重写" class="header-anchor">#</a> AOF重写</h3> <p>因为AOF持久化时通过保存被执行的写命令来记录数据库状态的，所以随着服务器运行时间的流逝，AOF文件中的内容会越来越多，文件的体积也会越来越大，如果不加以控制的话，体积过大的AOF文件很可能对redis服务器，甚至整个宿主计算机造成影响，并且AOF文件的体积越大，使用AOF文件来进行数据还原所需的时间就越多。</p> <p>为了解决AOF文件体积膨胀的问题，redis提供了aof文件重写(rewriter)功能。</p> <ol><li>aof文件重写的实现</li></ol> <p>AOF文件重写并不需要对现有的AOF文件进行任何读取，分析或者写入操作，这个功能是通过读取服务器当前的数据库状态来实现的。</p> <p>通过读取数据库的键值，用一条相关的push命令执行。</p> <p>重写的伪代码如下：</p> <div class="language-py extra-class"><pre class="language-py"><code><span class="token keyword">def</span> <span class="token function">aof_rewrite</span><span class="token punctuation">(</span>new_aof_file_name<span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token comment"># 创建新AOF文件</span>
  f <span class="token operator">=</span> create_file<span class="token punctuation">(</span>new_aof_file_name<span class="token punctuation">)</span>
  <span class="token comment"># 遍历数据库</span>
  <span class="token keyword">for</span> db <span class="token keyword">in</span> redisServer<span class="token punctuation">.</span>db<span class="token punctuation">:</span>
    <span class="token comment"># 忽略空数据库</span>
    <span class="token keyword">if</span> db<span class="token punctuation">.</span>is_empty<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
      <span class="token keyword">continue</span>
    <span class="token comment"># 写入select命令，指定数据库号码</span>
    f<span class="token punctuation">.</span>write_command<span class="token punctuation">(</span><span class="token string">&quot;SELECT&quot;</span> <span class="token operator">+</span> db<span class="token punctuation">.</span><span class="token builtin">id</span><span class="token punctuation">)</span>
    <span class="token comment"># 遍历数据库中的所有键</span>
    <span class="token keyword">for</span> key <span class="token keyword">in</span> db<span class="token punctuation">:</span>
      <span class="token comment"># 忽略已过期的键</span>
      <span class="token keyword">if</span> key<span class="token punctuation">.</span>is_expire<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">continue</span>
      <span class="token comment"># 根据键的类型对键进行重写</span>
      <span class="token keyword">if</span> key<span class="token punctuation">.</span><span class="token builtin">type</span> <span class="token operator">==</span> String<span class="token punctuation">:</span>
        rewrite_string<span class="token punctuation">(</span>key<span class="token punctuation">)</span>
      <span class="token keyword">elif</span> key<span class="token punctuation">.</span><span class="token builtin">type</span> <span class="token operator">==</span> List<span class="token punctuation">:</span>
        rewrite_list<span class="token punctuation">(</span>key<span class="token punctuation">)</span>
      <span class="token keyword">elif</span> key<span class="token punctuation">.</span><span class="token builtin">type</span> <span class="token operator">==</span> Hash<span class="token punctuation">:</span>
        rewrite_hash<span class="token punctuation">(</span>key<span class="token punctuation">)</span>
      <span class="token keyword">elif</span> key<span class="token punctuation">.</span><span class="token builtin">type</span> <span class="token operator">==</span> Set<span class="token punctuation">:</span>
        rewrite_set<span class="token punctuation">(</span>key<span class="token punctuation">)</span>
      <span class="token keyword">elif</span> key<span class="token punctuation">.</span><span class="token builtin">type</span> <span class="token operator">==</span> SortedSet<span class="token punctuation">:</span>
        rewrite_sorted_set<span class="token punctuation">(</span>key<span class="token punctuation">)</span>
      <span class="token comment"># 如果键带有过期时间，那么过期时间也要被重写</span>
      <span class="token keyword">if</span> key<span class="token punctuation">.</span>have_expire_time<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        rewrite_expire_time<span class="token punctuation">(</span>key<span class="token punctuation">)</span>
    <span class="token comment"># 写入完毕，关闭文件</span>
    f<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">def</span> <span class="token function">rewrite_string</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment"># 使用GET命令获取字符串键的值</span>
    value <span class="token operator">=</span> GET<span class="token punctuation">(</span>key<span class="token punctuation">)</span>
    <span class="token comment"># 使用 SET命令重写字符串键</span>
    f<span class="token punctuation">.</span>write_command<span class="token punctuation">(</span>SET<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span>
  <span class="token keyword">def</span> <span class="token function">rewrite_list</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment"># 使用LRANGE命令获取列表键的包含的所有元素</span>
    item1<span class="token punctuation">,</span> item2<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> itemN <span class="token operator">=</span> LRANGE<span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token comment"># 使用 RPUSH 命令重写列表键</span>
    f<span class="token punctuation">.</span>write_command<span class="token punctuation">(</span>RPUSH<span class="token punctuation">,</span> key<span class="token punctuation">,</span> item1<span class="token punctuation">,</span> item2<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> itemN<span class="token punctuation">)</span>
  <span class="token keyword">def</span> <span class="token function">rewrite_hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment"># 使用 HGETALL 命令获取哈希键的包含的所有键值对</span>
    field1<span class="token punctuation">,</span> value1<span class="token punctuation">,</span> field2<span class="token punctuation">,</span> value2<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> fieldN<span class="token punctuation">,</span> valueN <span class="token operator">=</span> HGETALL<span class="token punctuation">(</span>key<span class="token punctuation">)</span>
    <span class="token comment"># 使用 HMSET 命令重写哈希键</span>
    f<span class="token punctuation">.</span>write_command<span class="token punctuation">(</span>HMSET<span class="token punctuation">,</span> key<span class="token punctuation">,</span> field1<span class="token punctuation">,</span> value1<span class="token punctuation">,</span> field2<span class="token punctuation">,</span> value2<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> fieldN<span class="token punctuation">,</span> valueN<span class="token punctuation">)</span>
  <span class="token keyword">def</span> <span class="token function">rewrite_set</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment"># 使用 SMEMBERS 命令获取集合键的包含的所有元素</span>
    elem1<span class="token punctuation">,</span> elem2<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> elemN <span class="token operator">=</span> SMEMBERS<span class="token punctuation">(</span>key<span class="token punctuation">)</span>
    <span class="token comment"># 使用 SADD 命令重写集合键</span>
    f<span class="token punctuation">.</span>write_command<span class="token punctuation">(</span>SADD<span class="token punctuation">,</span> key<span class="token punctuation">,</span> elem1<span class="token punctuation">,</span> elem2<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> elemN<span class="token punctuation">)</span>
  <span class="token keyword">def</span> <span class="token function">rewrite_sorted_set</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment"># 使用 ZRANGE 命令获取有序集合键的包含的所有元素</span>
    member1<span class="token punctuation">,</span> score1<span class="token punctuation">,</span> member2<span class="token punctuation">,</span> score2<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> memberN<span class="token punctuation">,</span> scoreN <span class="token operator">=</span> ZRANGE<span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">&quot;WITHSCORES&quot;</span><span class="token punctuation">)</span>
    <span class="token comment"># 使用 ZADD 命令重写有序集合键</span>
    f<span class="token punctuation">.</span>write_command<span class="token punctuation">(</span>ZADD<span class="token punctuation">,</span> key<span class="token punctuation">,</span> score1<span class="token punctuation">,</span> member1<span class="token punctuation">,</span> score2<span class="token punctuation">,</span> member2<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> scoreN<span class="token punctuation">,</span> memberN<span class="token punctuation">)</span>
  <span class="token keyword">def</span> <span class="token function">rewrite_expire_time</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment"># 获取毫秒精度的键过期时间戳</span>
    timestamp <span class="token operator">=</span> get_expire_time_in_unixstamp<span class="token punctuation">(</span>key<span class="token punctuation">)</span>
    <span class="token comment"># 使用 PEXPIREAT 命令重写键的过期时间</span>
    f<span class="token punctuation">.</span>write_command<span class="token punctuation">(</span>PEXPIREAT<span class="token punctuation">,</span> key<span class="token punctuation">,</span> timestamp<span class="token punctuation">)</span>
</code></pre></div><p>因为aof_rewrite函数生成的新aof文件只包含还原当前数据库状态所必须的命令，所以新AOF文件不会浪费任何硬盘空间。</p> <p>注：为了避免在执行命令时造成客户端输入缓冲区溢出，重写程序在处理泪飙，哈希表，集合，有序集合这四种可能会带有多个元素的键时，会先检查键包含的元素数量，如果元素的数量超过了redis.h/REDIS_AOF_REWRITE_ITEMS_PER_CMS常量的值，那么重写程序将使用多条命令来记录键的值，而不单单使用一条命令。</p> <ol start="2"><li>AOF后台重写</li></ol> <p>aof_rewrite函数可以很好的完成创建一个新AOF文件的任务，但是，这个函数会进行大量的写入操作，所以调用这个函数的线程将被长时间阻塞，因为redis服务器使用单个线程来处理命令请求，所以如果由服务器直接调用aof_rewrite函数的话，那么在重写AOF文件期间，服务器将无法处理客户端发来的命令请求。</p> <p>Redis不希望AOF重写造成服务器无法处理请求，所以Redis决定将AOF重写程序放到子进程里执行，主要目的为：</p> <p>a). 子进程进行AOF重写期间，服务器进程(父进程)可以继续处理命令请求。</p> <p>b). 子进程带有服务器进程的数据副本，使用子进程而不是线程，可以在避免使用锁的情况下，保证数据的安全性。</p> <p>存在的问题：</p> <p>子进程重写期间，进行了新的数据操作，会导致数据库状态和重写后的aof文件所保存的数据库状态不一致。</p> <p>redis设置了一个aof重写缓冲区，这个缓冲区在服务器创建子进程之后开始使用，当redis服务器执行完一个写命令之后，它会同时将这个写命令发送给AOF缓冲区和AOF重写缓冲区。</p> <p>子进程执行AOF重写期间，服务器进程需要执行三个工作：</p> <p>a). 执行客户端发来的命令</p> <p>b). 将执行后的写命令追加到AOF缓冲区</p> <p>c). 将执行后的写命令追加到AOF重写缓冲区</p> <p>作用：</p> <p>a). AOF缓冲区的内容会定期被写入和同步到AOF文件，对现有AOF文件的处理工作会正常执行</p> <p>b). 从创建子进程开始，服务器执行的所有写命令都会被记录到AOF重写缓冲区里面。</p> <p>当子进程完成AOF重写工作之后，它会项父进程发送一个信号，父进程在接到该信号之后，会调用一个信号处理函数，执行以下工作：</p> <p>a). 将AOF重写缓冲区中的所有内容写入到新AOF文件中，这时新AOF文件所保存的数据库状态将和服务器当前的数据库状态一致。</p> <p>b). 对新的AOF文件进行改名，原子地(atomic)覆盖现有地AOF文件，完成新旧两个AOF文件地替换。</p> <h3 id="重点回顾"><a href="#重点回顾" class="header-anchor">#</a> 重点回顾</h3> <p>a). AOF文件通过保存所有修改数据库地写命令请求来记录服务器地数据库状态</p> <p>b). AOF文件中地所有命令都以Redis命令请求协议地格式保存</p> <p>c). 命令请求会保存到AOF缓冲区里面，之后再定期写入并同步到AOF文件</p> <p>d). appendfsync选项地不同值对AOF持久化功能地安全性以及Redis服务器地性能有很大地影响。</p> <p>e). 服务器只要载入并重新执行保存再AOF文件中地命令，就可以还原数据库本来地状态</p> <p>f). AOF重写可以产生一个新的AOF文件，这个新的AOF文件和原有地AOF文件所保存地数据库状态一样，但体积更小。</p> <p>g). AOF重写是通过读写数据库中地键值对来实现地，程序无须对现有AOF文件进行任何读入，分析或者写入操作</p> <p>h). 在执行BGREWRITEAOF命令时，Redis服务器会维护一个AOF重写缓冲区，该缓冲区会在子进程创建新AOF文件期间，记录服务器所执行地所有写命令。当子进程完成创建新AOF文件地工作后，服务器会将重写缓冲区中地所有内容追加到新AOF文件地末尾，使得新旧两个AOF文件所保存地数据库状态一致。最后，服务器用新的AOF文件替换旧地AOF文件，以此来完成AOF文件重写操作。</p> <h2 id="事件"><a href="#事件" class="header-anchor">#</a> 事件</h2> <p>Redis服务器是一个事件驱动程序，服务器需要处理以下两类事件：</p> <p>a). 文件事件(file event): Redis服务器通过套接字与客户端(或者其他Redis服务器)进行连接，而文件事件就是服务器对套接字操作地抽象。服务器与客户端(或者其他服务器)地通信会产生相应地文件事件，而服务器则通过监听并处理这些事件来完成一系列网络通信操作。</p> <p>b). 时间事件(time event): Redis服务器中的一些操作(比如serverCron函数)需要在给定的时间点执行，而时间事件就是服务器对这类定时操作的抽象。</p> <h3 id="文件事件"><a href="#文件事件" class="header-anchor">#</a> 文件事件</h3> <p>redis基于Reactor模式开发了自己的网络事件处理器：这个处理器被称为文件事件处理器(file event handle):</p> <p>a). 文件事件处理器使用I/O多路复用(multiplexing)程序来同时监听多个套接字，并根据套接字目前执行的任务来套接字关联不同的事件处理器。</p> <p>b). 当被监听的套接字准备好执行连接应答(accept), 读取(read), 写入(write), 关闭(close)等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</p> <p>文件事件处理器以单线程方式运行，但通过使用I/O多路复用程序来监听多个套接字，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与redis服务器中其他同样以单线程方式运行地模块进行对接，这保持了Redis内部单线程设计的简单性。</p> <ol><li>文件事件处理器的构成</li></ol> <p>文件事件处理器通过四个部分组成：套接字，I/O多路复用程序，文件事件分派器(dispatcher)，以及事件处理器。</p> <p>文件事件是对套接字操作的抽象，每当一个套接字准备好执行连接应答(accept), 写入，读取，关闭等操作时，就会产生一个文件事件。因为一个服务器通过会连接多个套接字，所以多个文件事件可能会并发的出现。</p> <p>I/O多了复用程序负责监听多个套接字，并向文件事件分派器传送那些产生了事件的套接字。</p> <p>尽管多个文件事件可能会并发地出现，但I/O多路复用程序总是会将所有产生事件地套接字都放到一个队列里面，然后通过这个队列，以有序(sequentially), 同步(synchronously)，每次一个套接字地方式向文件事件分派器传送套接字。当上一个套接字产生地事件被处理完毕之后(该套接字为事件所关联地事件处理器执行完毕)，I/O多路复用程序才会继续向文件事件分派器传送下一个套接字。</p> <p>文件事件分派器接收I/O多路复用程序传来地套接字，并根据套接字产生地事件的类型，调用相应的事件处理器。</p> <p>服务器会为执行不同任务的套接字关联不同的事件处理器，这些处理器是一个个函数，它们定义了某个事件发生时，服务器应该执行的动作。</p> <ol start="2"><li>I/O多路复用程序的实现</li></ol> <p>Redis的I/O多路复用程序的所有功能都是通过包装常见的select，epoll，evport和kqueue这些I/O多路复用函数库来实现的，每个I/O多路复用函数库在Redis源码中对应一个单独地文件，比如ae_select.c, ae_epoll.c, ae_kqueue.c.</p> <p>Redis为每个I/O多路复用函数库都实现了相同的API,所以I/O多路复用程序的底层实现是可以互换的。</p> <p>Redis在I/O多路复用程序的实现源码中用#include宏定义了相应的规则，程序会在编译时自动选择系统中性能最高的I/O多路复用数据库来作为Redis的I/O多路复用程序的底层实现：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">/* Include the best multiplexing layer supported by this system.
 * The following should be ordered by performances, descending. */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">HAVE_EVPORT</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&quot;ae_evport.c&quot;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>
    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">HAVE_EPOLL</span></span>
    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&quot;ae_epoll.c&quot;</span></span>
    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>
        <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">HAVE_KQUEUE</span></span>
        <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&quot;ae_kqueue.c&quot;</span></span>
        <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>
        <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&quot;ae_select.c&quot;</span></span>
        <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
</code></pre></div><ol start="3"><li>事件的类型</li></ol> <p>I/O多路复用程序可以监听多个套接字的 ae.h/AE_READABLE 事件和 ae.h/AE_WRITABLE 事件，这两类事件和套接字之间的对应关系如下：</p> <p>a). 当套接字变成可读时(客户端对套接字执行write操作，或者执行close操作)，或者有新的可应答(acceptable)套接字出现时(客户端对服务器的监听套接字执行connect操作)，套接字产生AE_READABLE事件。</p> <p>b). 当套接字编程可写时(客户端对套接字执行read操作)，套接字产生AE_WRITABLE事件。</p> <p>I/O多路复用程序允许服务器同时监听套接字的AE_READABLE事件和AE_WRITABLE事件，如果一个套接字同时产生了这两种事件，那么文件事件分派器会优先处理AE_READABLE事件，等到AE_READABLE事件处理完之后，才处理AE_WRITABLE事件。</p> <p>如果一个套接字又可读又可写的话，那么服务器将先读套接字，后写套接字。</p> <ol start="4"><li>API</li></ol> <p>ae.c/aeCreateFileEvent函数接受一个套接字描述符，一个事件类型，以及一个事件处理器作为参数，将给定套接字的给定事件加入到I/O多路复用程序的监听范围之内，并对事件和事件处理器进行关联。</p> <p>ae.c/aeDeleteFileEvent函数接受一个套接字描述符和一个监听事件类型作为参数，让I/O多路复用程序取消对给定套接字的给定事件的监听，并取消事件和事件处理器之间的关联。</p> <p>ae.c/aeGetFileEvents函数接受一个套接字描述符，返回该套接字正在被监听的事件类型：</p> <p>a). 如果套接字没有任何事件被监听，那么函数返回AE_NONE.</p> <p>b). 如果套接字的读事件正在被监听，那么函数返回AE_READABLE.</p> <p>c). 如果套接字的写事件正在被监听，那么函数返回AE_WRITABLE.</p> <p>d). 如果套接字的读事件和写事件正在被监听，那么函数返回AE_READABLE | AE_WRITABLE.</p> <p>ae.c/aeWait函数接受一个套接字描述符，一个事件类型和一个毫秒数为参数，在给定的时间内阻塞并等待套接字的给定类型事件产生，当事件成功产生，或者等待超时之后，函数返回。</p> <p>ae.c/aeApiPoll函数接受一个sys/time.h/struct timeval结构为参数，并在指定的时间内，阻塞并等待所有被aeCreateFileEvent函数设置为监听状态的套接字产生文件事件，当有至少一个事件产生，或者等待超时后，函数返回。</p> <p>ae.c/aeProcessEvents函数是文件事件分派器，它先调用aeApiPoll函数来等待事件产生，然后遍历所有已产生的事件，并调用相应的事件处理器来处理这些事件。</p> <p>ae.c/aeGetApiName函数返回I/O多路复用程序底层所使用的I/O多路复用函数库的名称：返回&quot;epoll&quot;表示底层为epoll函数库，返回&quot;select&quot;表示底层为select函数库。</p> <ol start="5"><li>文件事件的处理器</li></ol> <p>redis为文件事件编写了多个处理器，这些事件处理器分别用于实现不同的网络通信需求</p> <p>a). 为了对连接服务器的各个客户端进行应答，服务器要为监听套接字关联连接应答处理器。</p> <p>networking.c/acceptTcpHandler函数是redis的连接应答处理器，这个处理器用于对连接服务器监听套接字的客户端进行应答，具体实现为sys/socket.h/accept函数的包装。</p> <p>当Redis服务器进行初始化的时候，程序会将这个连接应答处理器和服务器监听套接字的AE_READABLE事件关联起来，当有客户端用sys/socket.h/connect函数连接服务器监听套接字的时候，就会产生AE_READABLE事件，引发连接应答处理器执行，并执行相应的套接字应答操作。</p> <p>b). 为了接收客户端传来的命令请求，服务器要为客户端套接字关联命令请求处理器。</p> <p>networking.c/readQueryFromClient函数是redis的命令请求处理器，这个处理器负责从套接字中读入客户端发送的命令请求内容，具体实现为unistd.h/read函数的包装。</p> <p>当一个客户端通过连接应答处理器成功连接到服务器之后，服务器会将客户端套接字的AE_READABLE事件和命令请求处理器关联起来，当客户端向服务器发送命令请求的时候，套接字就会产生AE_READABLE事件，引发命令请求处理器执行，并执行相应的套接字读入操作。</p> <p>c). 为了向客户端返回命令的执行结果，服务器要为客户端套接字关联命令回复处理器。</p> <p>networking.c/sendReplyToClient函数是redis的回复处理器处理器，这个处理器负责将服务器执行命令后得到的命令回复通过套接字返回给客户端，具体实现为unistd.h/write函数的包装。</p> <p>当服务器有命令回复需要传送给客户端的时候，服务器会将客户端套接字的AE_WRITABLE事件和命令回复处理器关联起来，当客户端准备接收服务器传回的命令回复时，就会产生AE_WRITABLE事件，引发命令回复处理器执行，并执行相应的套接字写入操作。</p> <p>当命令回复发送完毕之后，服务器就会解除命令回复处理器与客户端套接字的AE_WRITABLE事件之间的关联。</p> <p>d). 当主服务器和从服务器进行复制操作时，主从服务器都需要关联特别为复制功能编写的复制处理器。</p> <ol start="6"><li>以此完整的客户端与服务器连接事件示例</li></ol> <p>此处需要补一个图</p> <h3 id="时间事件"><a href="#时间事件" class="header-anchor">#</a> 时间事件</h3> <p>redis的时间事件分为两类</p> <p>a). 定时事件：让一段程序在指定的时间之后执行以此，比如说，让程序X在当前时间的30毫秒之后执行一次</p> <p>b). 周期性事件：让一个程序每隔指定时间就执行一次，比如说，让程序Y每隔30毫秒就执行一次。</p> <p>一个时间事件主要由三个属性组成：</p> <p>a). id: 服务器为时间事件创建的全局唯一ID，ID号从小到大的顺序递增，新事件的ID号比旧事件的ID号要大。</p> <p>b). when: 毫秒精度的UNIX事件戳，记录了时间事件的到达时间</p> <p>c). timeProc: 时间事件处理器，一个函数。当时间事件到达时，服务器就会调用相应的处理器来处理事件。</p> <p>一个时间事件时定时事件还是周期性事件取决于事件事件处理器的返回值:</p> <p>a). 如果事件处理器返回ae.h/AE_NOMORE, 那么这个事件为定时事件：该事件在达到一次之后就会被删除，之后不再到达。</p> <p>b). 如果事件处理器返回一个非AE_NOMORE的整数值，那么这个事件为周期性时间：当一个时间事件到达之后，服务器会根据事件处理器返回的值，对时间事件的when属性进行更新，让这个事件在一段事件之后再次到达，并以这种方式一致更新并运行下去。</p> <p>目前redis只使用周期性事件，而没有使用定时事件。</p> <ol><li>实现</li></ol> <p>服务器将所有时间事件都放在一个无序链表中，每当时间事件执行器运行时，它就遍历整个链表，查找所有已到达的时间事件，并调用相应的事件处理器。</p> <p>无序链表并不影响时间事件处理器的性能</p> <p>在目前版本中，正常模式下的redis服务器只使用serverCron一个时间事件，而在benchmark模式下，服务器也只是用两个时间事件。这种情况下，服务器几乎是将无序链表退化成一个指针来使用，所以使用无序链表来保存时间事件，并不影响事件执行的性能。</p> <ol start="2"><li>API</li></ol> <p>ae.c/aeCreateTimeEvent函数接受一个毫秒数milliseconds和一个时间事件处理器proc作为参数，将一个新的时间事件添加到服务器，这个新的时间事件添加到服务器，这个新的时间事件将在当前时间的milliseconds毫秒之后到达，而事件的处理器为proc。</p> <p>ae.c/aeDeleteFileEvent函数接受一个时间事件ID作为参数，然后从服务器中删除该ID所对应的时间事件</p> <p>ae.c/aeSearchNearestTime函数返回到达事件距离当前时间最接近的那个时间事件</p> <p>ae.c/processTimeEvents 函数是时间事件的执行器，这个函数会遍历所有已到达的时间事件，并调用这些事件的处理器。已到达指的是，时间事件的when属性记录的UNIX时间戳等于或小于当前时间的UNIX时间戳。</p> <p>processTimeEvents伪代码如下：</p> <div class="language-py extra-class"><pre class="language-py"><code><span class="token keyword">def</span> <span class="token function">processTimeEvents</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token comment"># 遍历服务器中的所有时间事件</span>
  <span class="token keyword">for</span> time_event <span class="token keyword">in</span> all_time_event<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment"># 检查事件是否已经到达</span>
    <span class="token keyword">if</span> time_event<span class="token punctuation">.</span>when <span class="token operator">&lt;=</span> unix_ts_now<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
      <span class="token comment"># 事件已到达</span>
      <span class="token comment"># 执行事件处理器，并获取返回值</span>
      retval <span class="token operator">=</span> time_event<span class="token punctuation">.</span>timeProc<span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token comment"># 如果这是一个定时事件</span>
      <span class="token keyword">if</span> retval <span class="token operator">==</span> AE_NOMORE<span class="token punctuation">:</span>
        <span class="token comment"># 那么将该事件从服务器中删除</span>
        delete_time_event_from_server<span class="token punctuation">(</span>time_event<span class="token punctuation">)</span>
      <span class="token keyword">else</span><span class="token punctuation">:</span>
        <span class="token comment"># 那么按照事件处理器的返回值更新时间事件的when属性</span>
        <span class="token comment"># 让这个事件在指定的时间之后再次到达</span>
        update_when<span class="token punctuation">(</span>time_event<span class="token punctuation">,</span> retval<span class="token punctuation">)</span>
</code></pre></div><ol start="3"><li>时间事件应用示例：serverCron函数</li></ol> <p>持续运行的redis服务器需要定期对自身的资源和状态进行检查和调整，从而确保服务器可以长期，稳定地运行，这些定期操作由redis.c/serverCron函数负责执行，它地主要包括：</p> <p>a). 更新服务器地各类统计信息，比如时间，内存占用，数据库占用情况</p> <p>b). 清理数据库中的过期键值对。</p> <p>c). 关闭和清理连接失效的客户端。</p> <p>d). 尝试进行AOF或RDB的持久化操作。</p> <p>e). 如果服务器是主服务器，那么对从服务器进行定期同步。</p> <p>f). 如果处于集群模式，对集群进行定期同步和连接测试。</p> <h3 id="事件的调度与执行"><a href="#事件的调度与执行" class="header-anchor">#</a> 事件的调度与执行</h3> <p>因为服务器中同时存在文件事件和时间事件两种事件类型，所以服务器必须对这两种事件进行调度，决定何时应该处理文件事件，何时又应该处理时间事件，以及花多少时间来处理它们。</p> <p>事件的调度和执行由ae.c/aeProcessEvents函数负责，以下为伪代码：</p> <div class="language-py extra-class"><pre class="language-py"><code><span class="token keyword">def</span> <span class="token function">aeProcessEvents</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token comment"># 获取到达时间离当前时间最接近的时间事件</span>
  time_event <span class="token operator">=</span> aeSearchNearestTimer<span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token comment"># 计算最接近的时间事件距离到达还有多少毫秒</span>
  remain_ms <span class="token operator">=</span> time_event<span class="token punctuation">.</span>when <span class="token operator">-</span> unix_ts_now<span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token comment"># 如果事件已到达，那么remaind_ms的值可能为负数，将它设定为0</span>
  <span class="token keyword">if</span> remaind_ms <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">:</span>
    remaind_ms <span class="token operator">=</span> <span class="token number">0</span>
  <span class="token comment"># 根据remaind_ms的值，创建timeval结果</span>
  timeval <span class="token operator">=</span> create_timeval_with_ms<span class="token punctuation">(</span>remaind_ms<span class="token punctuation">)</span>
  <span class="token comment"># 阻塞并等待文件事件产生，最大阻塞时间由传入的timeval结构决定</span>
  <span class="token comment"># 如果remaind_ms的值为0，那么aeApiPoll调用之后马上返回，不阻塞</span>
  aeApiPoll<span class="token punctuation">(</span>timeval<span class="token punctuation">)</span>
  <span class="token comment"># 处理所有已产生的文件事件</span>
  processFileEvents<span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token comment"># 处理所有已到达的时间事件</span>
  processTimeEvents<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><div class="language-py extra-class"><pre class="language-py"><code><span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token comment"># 初始化服务器</span>
  init_server<span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token comment">#一直处理事件，直到服务器关闭为止</span>
  <span class="token keyword">while</span> server_is_not_shutdown<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    aeProcessEvents<span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token comment"># 服务器关闭，执行清理操作</span>
  clean_server<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>以下是事件的调度和执行规则：</p> <p>a). aeApiPoll函数的最大阻塞时间由到达时间最接近当前时间的时间事件决定，这个方法既可以避免服务器对时间事件进行频繁的轮询，也可以确保aeApiPoll函数不会阻塞过长时间。</p> <p>b). 因为文件事件是随机出现的，如果等待并处理完一次文件事件之后，仍未有任何时间事件到达，那么服务器将再次等待并处理文件事件。随着文件事件的不断执行，时间会逐渐向时间事件所设置的到达时间逼近，并最终来到到达时间，这时服务器就可以开始处理到达的时间事件了。</p> <p>c). 对文件事件和时间事件的处理都是同步，有序，原子地执行的，服务器不会中途中断事件处理，也不会对事件进行抢占，因此，不管是文件事件的处理器，还是时间事件的处理器，它们都会尽可能地减少程序地阻塞时间，并在有需要时主动让出执行权，从而降低造成事件饥饿地可能性。</p> <p>d). 因为时间事件在文件事件之后执行，并且事件之间不会出现抢占，所以时间事件的实际处理时间，通常会比时间事件设定的到达时间稍微晚一些。</p> <h3 id="重点回顾-2"><a href="#重点回顾-2" class="header-anchor">#</a> 重点回顾</h3> <p>a). redis服务器时一个事件驱动程序，服务器处理的事件分为时间事件和文件事件</p> <p>b). 文件事件处理器是基于Reactor模式实现的网络通信程序</p> <p>c). 文件事件是对套接字操作的抽象：每次套接字变为可应答(acceptable), 可写(writable)或者可读(readable)时，相应的文件事件就会产生</p> <p>d). 文件事件分为AE_READABLE事件(读事件)和AE_WRITABLE事件(写事件)两类</p> <p>e). 时间事件分为定时事件和周期性事件：定时事件只在指定的时间到达一次，而周期性事件则每隔一段时间到达一次</p> <p>f). 服务器在一般情况下只执行serverCron函数一个时间事件，并且这个事件是周期性事件。</p> <p>g). 文件事件和时间事件之间是合作关系，服务器会轮流处理这两种事件，并且处理事件的过程中也不会进行抢占</p> <p>h). 时间事件的实际处理时间通常会比设定的到达时间晚一些。</p> <h2 id="客户端"><a href="#客户端" class="header-anchor">#</a> 客户端</h2> <p>redis服务器是典型的一对多服务器程序：一个服务器可以与多个客户端建立网络连接，每个客户端可以向服务器发送命令请求，而服务器则接收并处理客户端发送的命令请求，并向客户端返回命令回复。</p> <p>通过使用由I/O多路复用技术实现的文件事件处理器，redis服务器使用单线程，单进程的方式来处理命令请求，并与多个客户端进行网络通信。</p> <p>每个服务器进行连接的客户端，服务器都为这些客户端建立了相应的redis.h/redisClient结构，这个结构保存了客户端当前的状态信息。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">/* With multiplexing we need to take per-client state.
 * Clients are taken in a liked list.
 *
 * 因为 I/O 复用的缘故，需要为每个客户端维持一个状态。
 *
 * 多个客户端状态被服务器用链表连接起来。
 */</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">redisClient</span> <span class="token punctuation">{</span>

    <span class="token comment">// 套接字描述符</span>
    <span class="token keyword">int</span> fd<span class="token punctuation">;</span>

    <span class="token comment">// 当前正在使用的数据库</span>
    redisDb <span class="token operator">*</span>db<span class="token punctuation">;</span>

    <span class="token comment">// 当前正在使用的数据库的 id （号码）</span>
    <span class="token keyword">int</span> dictid<span class="token punctuation">;</span>

    <span class="token comment">// 客户端的名字</span>
    robj <span class="token operator">*</span>name<span class="token punctuation">;</span>             <span class="token comment">/* As set by CLIENT SETNAME */</span>

    <span class="token comment">// 查询缓冲区</span>
    sds querybuf<span class="token punctuation">;</span>

    <span class="token comment">// 查询缓冲区长度峰值</span>
    size_t querybuf_peak<span class="token punctuation">;</span>   <span class="token comment">/* Recent (100ms or more) peak of querybuf size */</span>

    <span class="token comment">// 参数数量</span>
    <span class="token keyword">int</span> argc<span class="token punctuation">;</span>

    <span class="token comment">// 参数对象数组</span>
    robj <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">;</span>

    <span class="token comment">// 记录被客户端执行的命令</span>
    <span class="token keyword">struct</span> <span class="token class-name">redisCommand</span> <span class="token operator">*</span>cmd<span class="token punctuation">,</span> <span class="token operator">*</span>lastcmd<span class="token punctuation">;</span>

    <span class="token comment">// 请求的类型：内联命令还是多条命令</span>
    <span class="token keyword">int</span> reqtype<span class="token punctuation">;</span>

    <span class="token comment">// 剩余未读取的命令内容数量</span>
    <span class="token keyword">int</span> multibulklen<span class="token punctuation">;</span>       <span class="token comment">/* number of multi bulk arguments left to read */</span>

    <span class="token comment">// 命令内容的长度</span>
    <span class="token keyword">long</span> bulklen<span class="token punctuation">;</span>           <span class="token comment">/* length of bulk argument in multi bulk request */</span>

    <span class="token comment">// 回复链表</span>
    list <span class="token operator">*</span>reply<span class="token punctuation">;</span>

    <span class="token comment">// 回复链表中对象的总大小</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> reply_bytes<span class="token punctuation">;</span> <span class="token comment">/* Tot bytes of objects in reply list */</span>

    <span class="token comment">// 已发送字节，处理 short write 用</span>
    <span class="token keyword">int</span> sentlen<span class="token punctuation">;</span>            <span class="token comment">/* Amount of bytes already sent in the current
                               buffer or object being sent. */</span>

    <span class="token comment">// 创建客户端的时间</span>
    time_t ctime<span class="token punctuation">;</span>           <span class="token comment">/* Client creation time */</span>

    <span class="token comment">// 客户端最后一次和服务器互动的时间</span>
    time_t lastinteraction<span class="token punctuation">;</span> <span class="token comment">/* time of the last interaction, used for timeout */</span>

    <span class="token comment">// 客户端的输出缓冲区超过软性限制的时间</span>
    time_t obuf_soft_limit_reached_time<span class="token punctuation">;</span>

    <span class="token comment">// 客户端状态标志</span>
    <span class="token keyword">int</span> flags<span class="token punctuation">;</span>              <span class="token comment">/* REDIS_SLAVE | REDIS_MONITOR | REDIS_MULTI ... */</span>

    <span class="token comment">// 当 server.requirepass 不为 NULL 时</span>
    <span class="token comment">// 代表认证的状态</span>
    <span class="token comment">// 0 代表未认证， 1 代表已认证</span>
    <span class="token keyword">int</span> authenticated<span class="token punctuation">;</span>      <span class="token comment">/* when requirepass is non-NULL */</span>

    <span class="token comment">// 复制状态</span>
    <span class="token keyword">int</span> replstate<span class="token punctuation">;</span>          <span class="token comment">/* replication state if this is a slave */</span>
    <span class="token comment">// 用于保存主服务器传来的 RDB 文件的文件描述符</span>
    <span class="token keyword">int</span> repldbfd<span class="token punctuation">;</span>           <span class="token comment">/* replication DB file descriptor */</span>

    <span class="token comment">// 读取主服务器传来的 RDB 文件的偏移量</span>
    off_t repldboff<span class="token punctuation">;</span>        <span class="token comment">/* replication DB file offset */</span>
    <span class="token comment">// 主服务器传来的 RDB 文件的大小</span>
    off_t repldbsize<span class="token punctuation">;</span>       <span class="token comment">/* replication DB file size */</span>
    
    sds replpreamble<span class="token punctuation">;</span>       <span class="token comment">/* replication DB preamble. */</span>

    <span class="token comment">// 主服务器的复制偏移量</span>
    <span class="token keyword">long</span> <span class="token keyword">long</span> reploff<span class="token punctuation">;</span>      <span class="token comment">/* replication offset if this is our master */</span>
    <span class="token comment">// 从服务器最后一次发送 REPLCONF ACK 时的偏移量</span>
    <span class="token keyword">long</span> <span class="token keyword">long</span> repl_ack_off<span class="token punctuation">;</span> <span class="token comment">/* replication ack offset, if this is a slave */</span>
    <span class="token comment">// 从服务器最后一次发送 REPLCONF ACK 的时间</span>
    <span class="token keyword">long</span> <span class="token keyword">long</span> repl_ack_time<span class="token punctuation">;</span><span class="token comment">/* replication ack time, if this is a slave */</span>
    <span class="token comment">// 主服务器的 master run ID</span>
    <span class="token comment">// 保存在客户端，用于执行部分重同步</span>
    <span class="token keyword">char</span> replrunid<span class="token punctuation">[</span>REDIS_RUN_ID_SIZE<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">/* master run id if this is a master */</span>
    <span class="token comment">// 从服务器的监听端口号</span>
    <span class="token keyword">int</span> slave_listening_port<span class="token punctuation">;</span> <span class="token comment">/* As configured with: SLAVECONF listening-port */</span>

    <span class="token comment">// 事务状态</span>
    multiState mstate<span class="token punctuation">;</span>      <span class="token comment">/* MULTI/EXEC state */</span>

    <span class="token comment">// 阻塞类型</span>
    <span class="token keyword">int</span> btype<span class="token punctuation">;</span>              <span class="token comment">/* Type of blocking op if REDIS_BLOCKED. */</span>
    <span class="token comment">// 阻塞状态</span>
    blockingState bpop<span class="token punctuation">;</span>     <span class="token comment">/* blocking state */</span>

    <span class="token comment">// 最后被写入的全局复制偏移量</span>
    <span class="token keyword">long</span> <span class="token keyword">long</span> woff<span class="token punctuation">;</span>         <span class="token comment">/* Last write global replication offset. */</span>

    <span class="token comment">// 被监视的键</span>
    list <span class="token operator">*</span>watched_keys<span class="token punctuation">;</span>     <span class="token comment">/* Keys WATCHED for MULTI/EXEC CAS */</span>

    <span class="token comment">// 这个字典记录了客户端所有订阅的频道</span>
    <span class="token comment">// 键为频道名字，值为 NULL</span>
    <span class="token comment">// 也即是，一个频道的集合</span>
    dict <span class="token operator">*</span>pubsub_channels<span class="token punctuation">;</span>  <span class="token comment">/* channels a client is interested in (SUBSCRIBE) */</span>

    <span class="token comment">// 链表，包含多个 pubsubPattern 结构</span>
    <span class="token comment">// 记录了所有订阅频道的客户端的信息</span>
    <span class="token comment">// 新 pubsubPattern 结构总是被添加到表尾</span>
    list <span class="token operator">*</span>pubsub_patterns<span class="token punctuation">;</span>  <span class="token comment">/* patterns a client is interested in (SUBSCRIBE) */</span>
    sds peerid<span class="token punctuation">;</span>             <span class="token comment">/* Cached peer ID. */</span>

    <span class="token comment">/* Response buffer */</span>
    <span class="token comment">// 回复偏移量</span>
    <span class="token keyword">int</span> bufpos<span class="token punctuation">;</span>
    <span class="token comment">// 回复缓冲区</span>
    <span class="token keyword">char</span> buf<span class="token punctuation">[</span>REDIS_REPLY_CHUNK_BYTES<span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span> redisClient<span class="token punctuation">;</span>
</code></pre></div><p>redis服务器状态结构的clients属性是一个链表，这个链表保存了所有与服务器连接的客户端的状态结构，对客户端执行批量操作，或者查找某个指定的客户端，都可以通过遍历clients链表来完成。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">redisServer</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  <span class="token comment">// 一个链表，保存了所有客户端状态</span>
  list <span class="token operator">*</span>clients<span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="客户端属性"><a href="#客户端属性" class="header-anchor">#</a> 客户端属性</h3> <p>客户端状态包含的属性可以分为两类：</p> <p>a). 一类是比较通用的属性，这些属性很少与特定功能相关，无论客户端执行的是什么工作，它们都要用到这些属性</p> <p>b). 另外一类是和特定功能相关的属性，比如操作数据库时需要用到的db属性和dictid属性，执行事务时需要用到的mstate属性，以及执行WATCH命令时需要用到的warched_keys属性等等。</p> <ol><li>套接字描述符</li></ol> <p>客户端状态的fd属性记录了客户端正在使用的套接字描述符：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">redisClient</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  <span class="token keyword">int</span> fd<span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span> redisClient<span class="token punctuation">;</span>
</code></pre></div><p>根据客户端类型的不同，fd属性的值可以是-1或者是大于-1的整数：</p> <p>a). -1：表示伪客户端(fake clent). 伪客户端处理的命令请求来源AOF文件或者Lua脚本，而不是网络，所以这种客户端不需要套接字连接，自然也不需要记录套接字描述符。目前redis服务器会在两个地方用到伪客户端，一个用于载入AOF文件并还原数据库状态，而另一个则用于执行Lua脚本中包含的redis命令。</p> <p>b). 大于-1的整数：表示普通客户端. 普通客户端使用套接字来与服务器进行通信，所以服务器会用fd属性来记录客户端套接字的描述符。</p> <p>执行</p> <div class="language-sh extra-class"><pre class="language-sh"><code>CLIENT list
</code></pre></div><p>CLIENT list 命令可以列出目前所有连接到服务器的普通客户端，命令输出中的fd域显示了服务器连接客户端所有的套接字描述符。</p> <ol start="2"><li>名字</li></ol> <p>在默认情况下，一个连接到服务器的客户端是没有名字的。</p> <p>使用</p> <div class="language-sh extra-class"><pre class="language-sh"><code>CLIENT setname
</code></pre></div><p>命令可以为客户端设置一个名字，让客户端的身份变得更清晰。</p> <ol start="3"><li>标志</li></ol> <p>客户端的标志属性flags记录了客户端的角色(role)，以及客户端目前所处的状态</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">redisClient</span> <span class="token punctuation">{</span>
  <span class="token comment">// ..</span>
  <span class="token keyword">int</span> flags<span class="token punctuation">;</span>
  <span class="token comment">// ..</span>
<span class="token punctuation">}</span> redisClient<span class="token punctuation">;</span>
</code></pre></div><p>flags属性的值可以是单个标志：</p> <div class="language-sh extra-class"><pre class="language-sh"><code>flags <span class="token operator">=</span> <span class="token operator">&lt;</span>flag<span class="token operator">&gt;</span>
</code></pre></div><p>也可以是多个标志的二进制或，比如：</p> <div class="language-sh extra-class"><pre class="language-sh"><code>flags <span class="token operator">=</span> <span class="token operator">&lt;</span>flag<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span> <span class="token operator">|</span> <span class="token operator">&lt;</span>flag<span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span> <span class="token operator">|</span> <span class="token punctuation">..</span>.
</code></pre></div><p>每个标志使用一个常量表示，一部分标志记录了客户端的角色：</p> <p>a). 在主从服务器进行复制操作时，主服务器会成为从服务器的客户端，而从服务器也会成为主服务器的客户端。REDIS_MASTER标志表示客户端代表的是一个主服务器，REDIS_SLAVE标志表示客户端代表的是一个从服务器。</p> <p>b). REDIS_PRE_PSYNC标志表示客户端代表的是一个版本低于Redis2.8的从服务器，主服务器不能使用PSYNC命令与这个从服务器进行同步。这个标志只能在REDIS_SLAVE标志处于打开状态时使用。</p> <p>c). REDIS_LUA_CLIENT标识表示客户端是专门用于处理Lua脚本里面包含的Redis命令的伪客户端。</p> <p>而另外一部分标志则记录了客户端目前所处的状态：</p> <p>a). REDIS_MONITOR标志表示客户端正在执行MONITOR命令。</p> <p>b). REDIS_UNIX_SOCKET标志表示服务器使用UNIX套接字来连接客户端。</p> <p>c). REDIS_BLOCKED标志表示客户端正在被BRPOP, BLPOP等命令阻塞。</p> <p>d). REDIS_UNBLOCKED标志表示客户端已经从REDIS_BLOCKED标志所表示的阻塞状态中脱离出来，不再阻塞。REDIS_UNBLOCKED标志只能在REDIS_BLOCKED标志已经打开的情况下。</p> <p>e). REDIS_MULTI标志表示客户端正在执行事务</p> <p>f). REDIS_DIRTY_CAS标志表示事务使用WATCH命令监视的数据库键已经被修改，REDIS_DIRTY_EXEC标志表示事务在命令入队时出现错误，以上两个标志都表示事务的安全性已经被破坏，只要这两个标记中的任意一个被打开，EXEC命令必然会执行失败。这两个标志只能在客户端打开了REDIS_MULTI标志的情况下使用。</p> <p>g). REDIS_CLOSE_ASAP标志表示客户端的输出缓冲区大小超出了服务器允许的范围，服务器会在下一次执行serverCron函数时闭关了这个客户端，以免服务器的稳定性受到这个客户端影响。积存在输出缓冲区中的所有内容会直接被释放，不会返回客户端。</p> <p>h). REDIS_CLOSE_AFTER_REPLY 标志表示有用户对这个客户端执行了CLIENT KILL命令，或者客户端发送给服务器的命令请求中包含了错误的协议内容。服务器会将客户端积存在输出缓冲区中的所有内容发送给客户端，然后关闭客户端。</p> <p>i). REDIS_ASKING 标志表示客户端向集群节点发送了ASKING命令</p> <p>j). REDIS_FORCE_AOF 标志强制服务器将当前执行的命令写入到AOF文件里面，REDIS_FORCE_REPL 标志强制主服务器将当前执行的命令复制给所有从服务器。当执行PUBSUB命令会使客户端打开REDIS_FORCE_AOF标志，执行SCRIPT LOAD命令会使客户端打开REDIS_FORCE_AOF标志和REDIS_FORCE_REPL标志。</p> <p>k). 在主从服务器进行命令传播期间，从服务器需要向主服务器发送REPLICATION ACK命令，在发送这个命令之前，从服务器必须打开主服务器对应的客户端的REDIS_MASTER_FORCE_REPLY 标志，否则发送操作会被拒绝执行。</p> <p>上述标志都定义在redis.h文件里面。</p> <p>PUBSUB命令和SCRIPT LOAD命令的特殊性</p> <p>通常情况下，Redis只会将那些对数据库进行了修改的命令写入到AOF文件，并复制到各个从服务器。如果一个命令没有对数据库进行任何修改，那么它就会被认为是只读命令，这个命令不会被写入到AOF文件，也不会被复制到从服务器。</p> <p>但是PUBSUB命令和SCRIPT LOAD命令是其中例外。</p> <p>PUBSUB命令虽然没有修改数据库，但PUBSUB命令向频道的所有订阅者发送消息这一行为带有副作用，接收到消息的所有客户端的状态都会因为这个命令而改变。</p> <p>SCRIPT LOAD命令的情况与PUBSUB命令类型：虽然SCRIPT LOAD命令没有修改数据库，但它修改了服务器状态，所以它是一个带有副作用的命令。</p> <ol start="4"><li>输入缓冲区</li></ol> <p>客户端状态的输入缓冲区用于保存客户端发送的命令请求：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">redisClient</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  sds querybuf<span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span> redisClient<span class="token punctuation">;</span>
</code></pre></div><p>如果客户端向服务器发送了以下命令请求：</p> <div class="language-sh extra-class"><pre class="language-sh"><code>SET key value
</code></pre></div><p>那么客户端状态的querybuf属性将是一个包含以下内容的SDS值：</p> <div class="language- extra-class"><pre class="language-text"><code>*3\r\n$3\r\nSET\r\n$3\r\nkey\r\n$5\r\nvalue\r\n
</code></pre></div><p>输入缓冲区的大小会根据输入内容动态地缩小或者扩大，但它地最大大小不能超过1GB，否则服务器将关闭这个客户端。</p> <ol start="5"><li>命令与命令参数</li></ol> <p>在服务器将客户端发送地命令请求保存到客户端状态地querybuf属性之后，服务器将对命令请求地内容进行分析，并将得出地命令参数以及命令参数地个数分别保存到客户端状态argv属性和argc属性：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">redisClient</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  robj <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">;</span>
  <span class="token keyword">int</span> argc<span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span> redisClient<span class="token punctuation">;</span>
</code></pre></div><p>argv属性是一个数组，数组中地每个项都是一个字符串对象，其中argv[0]是要执行地命令，而之后地其他项则是传给命令地参数。</p> <p>argc属性则负责记录argv数组地长度。</p> <ol start="6"><li>命令的实现函数</li></ol> <p>当服务器从协议内容中分析并得出argv属性和argc属性的值之后，服务器将根据项argv[0]的值，在命令表中查找命令所对应的命令实现函数。</p> <p>命令表是一个字典，字典的键是一个SDS结构，保存了命令的名字，字典的值是命令的实现函数，命令的标志，命令应该给定的参数个数，命令的总执行次数和总消耗时长等统计信息。</p> <p>当程序在命令表中成功找到argv[0]所对应的redisCommand结构时，它会将客户端状态的cmd指针指向这个结构：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">redisClient</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  <span class="token keyword">struct</span> <span class="token class-name">redisCommand</span> <span class="token operator">*</span>cmd<span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span> redisClient<span class="token punctuation">;</span>
</code></pre></div><p>服务器就可以使用cmd属性所指向的redisCommand结构，以及argv，argc属性中保存的命令参数信息，调用命令实现函数，执行客户端指定的命令。</p> <ol start="7"><li>输出缓冲区</li></ol> <p>执行命令所得的命令回复会被保存在客户端状态的输出缓冲区里面，每个客户端都有两个输出缓冲区可用，一个缓冲区的大小是固定的，另一个缓冲区的大小是可变的：</p> <p>a). 固定大小的缓冲区用于保存那些长度比较小的回复，比如OK, 简短的字符串值，整数值，错误回复等等。</p> <p>b). 可变大小的缓冲区用于保存那些长度比较大的回复，比如一个非常长的字符串值，一个由很多项组成的列表，一个包含了很多元素的集合等等。</p> <p>客户端的固定大小缓冲区由buf和bufpos两个属性组成：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">redisClient</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  <span class="token keyword">char</span> buf<span class="token punctuation">[</span>REDIS_REPLY_CHUNK_BYTES<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span> bufpos<span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span> redisClient<span class="token punctuation">;</span>
</code></pre></div><p>buf是一个大小为REDIS_REPLY_CHUNK_BYTES字节的字节数组，而bufpos属性则记录了buf数组目前已使用的字节数量。</p> <p>REDIS_REPLY_CHUNK_BYTES常量目前的默认值16*1024，即是说，buf数组的默认大小为16KB。</p> <p>当buf数组的空间已经用完，或者回复因为太大而没办法放进buf数组里面时，服务器就会开始使用可变大小缓冲区。</p> <p>可变大小缓冲区由reply链表和一个或多个字符串对象组成：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">redisClient</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  list <span class="token operator">*</span>reply<span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span> redisClient<span class="token punctuation">;</span>
</code></pre></div><p>通过使用链表来连接多个字符串对象，服务器可以为客户端保存一个非常长的命令回复，而不必受到固定大小缓冲区16KB大小的限制。</p> <ol start="8"><li>身份验证</li></ol> <p>客户端状态的authenticated属性用于记录客户端是否通过了身份验证：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">redisClient</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  <span class="token keyword">int</span> authenticated<span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span> redisClent<span class="token punctuation">;</span>
</code></pre></div><p>如果authenticated的值为0，那么表示客户端未通过身份验证；如果authenticated的值为1，表示客户端已经通过了身份验证。</p> <p>客户端authenticated属性的值为0时，除了AUTH命令之外，客户端发送的所有命令都会被服务器拒绝执行。</p> <p>客户端通过AUTH命令成功进行身份验证之后，客户端状态authenticated属性的值就会从0变为1.</p> <p>authenticated属性仅在服务器启用了身份验证功能时使用。如果服务器没有启用身份验证功能的话，那么即使authenticated属性的值为0，服务器也不会拒绝执行客户端发送的命令请求。</p> <ol start="9"><li>时间</li></ol> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">redisClient</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  time_t ctime<span class="token punctuation">;</span>
  time_t lastinteraction<span class="token punctuation">;</span>
  time_t obuf_soft_limit_reached_time<span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span> redisClient<span class="token punctuation">;</span>
</code></pre></div><p>ctime属性记录了创建客户端的时间，这个时间可以用来计算客户端与服务器已经连接了多少秒，CLIENT list命令的age域记录了这个秒数。</p> <p>lastinteraction属性记录了客户端与服务器最后一次进行互动的时间，这里的互动可以是客户端向服务器发送命令请求，也可以是服务器向客户端发送命令回复。</p> <p>lastinteraction属性可以用来计算客户端的空转(idle)时间，也即是，距离客户端与服务器最后一次进行互动以来，已经过去了多少秒，CLIENT list命令的idle域记录了这个秒数。</p> <p>obuf_soft_limit_reached_time属性记录了输出缓冲区第一次到达软性限制(soft limit)的时间。</p> <h2 id="客户端的创建与关闭"><a href="#客户端的创建与关闭" class="header-anchor">#</a> 客户端的创建与关闭</h2> <p>服务器使用不同的方式来创建和关闭不同类型的客户端。</p> <ol><li>创建普通客户端</li></ol> <p>如果客户端是通过网络连接与服务器进行连接的普通客户端，那么在客户端使用connect函数连接到服务器时，服务器就会调用连接事件处理器，为客户端创建相应的客户端状态，并将这个新的客户端状态添加到服务器状态结构clients链表的末尾。</p> <ol start="2"><li>关闭普通客户端</li></ol> <p>一个普通客户端可以因为多种原因而被关闭：</p> <p>a). 如果客户端进程退出或者被杀死，那么客户端与服务器之间的网络连接将被关闭，从而造成客户端被关闭。</p> <p>b). 如果客户端向服务器发送了带有不符合协议格式的命令请求，那么这个客户端也会被服务器关闭</p> <p>c). 如果客户端成为了CLIENT KILL命令的目标，那么它也会被关闭</p> <p>d). 如果用户为服务器设置了timeout配置选项，那么当客户端的空转时间超过timeout选项设置的值时，客户端将被关闭。不过timeout选项有一些例外情况：如果客户端是主服务器(打开了REDIS_MASTER标志)，从服务器(打开了REDIS_SLAVE标志)，正在被BLPOP等命令阻塞(打开了REDIS_BLOCKED标志)，或者正在执行SUBSCRIBE, PSUBSRIBE等订阅命令，那么即使客户端的空转时间超过了timeout选项的值，客户端也不会被服务器关闭。</p> <p>e). 如果客户端发送的命令请求的大小超过了输入缓冲区的限制大小(默认为1GB)，那么这个客户端会被服务器关闭。</p> <p>f). 如果要发送给客户端的命令回复的大小超过了输出缓冲区的限制大小，那么这个客户端会被服务器关闭。</p> <p>可变大小缓冲区由一个链表和任意多个字符串对象组成，理论上来说，这个缓冲区可以保存任意长的命令回复。</p> <p>但是，为了避免客户端的回复过大，占用过的服务器资源，服务器会时刻检查客户端的输出缓冲区大小，并在缓冲区的大小超出范围时，执行相应的限制操作：</p> <p>a). 硬性限制(hard limit): 如果输出缓冲区的大小超过了硬性限制所设置的大小，那么服务器立即关闭客户端。</p> <p>b). 软性限制(soft limit): 如果输出缓冲区的大小超过了软性限制所设置的大小，但还没超过硬性限制，那么服务器将使用客户端状态结构的obuf_soft_limit_reached_time属性记录下客户端到达软性限制的起始时间。之后服务器会继续监视客户端，如果输出缓冲区的大小一直超出软性限制，并且持续时间超过服务器设定的时长，那么服务器将关闭客户端；相反地，如果输出缓冲区地大小在指定时间之内，不再超出软性限制，那么客户端就不会被关闭，并且obuf_soft_limit_reached_time属性地值将被清零。</p> <p>使用client-output-buffer-limit选项可以为普通客户端，从服务器客户端，执行发布与订阅功能地客户端分别设置不同地软性限制和硬性限制，该选项的格式为：</p> <div class="language-sh extra-class"><pre class="language-sh"><code>client-output-buffer-limit  <span class="token operator">&lt;</span>class<span class="token operator">&gt;</span>  <span class="token operator">&lt;</span>hardlimit<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>soft limit<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>soft seconds<span class="token operator">&gt;</span>
</code></pre></div><ol start="3"><li>Lua脚本的伪客户端</li></ol> <p>服务器会在初始化时创建负责执行Lua脚本中包含的Redis命令的伪客户端，并将这个伪客户端关联在服务器状态结构的lua_client属性中：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">redisServer</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  redisClient <span class="token operator">*</span>lua_client<span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>lua_client 伪客户端在服务器运行的整个生命期中会一直存在，只有服务器被关闭时，这个客户端才会被关闭。</p> <ol start="4"><li>AOF文件的伪客户端</li></ol> <p>服务器在载入AOF文件时，会创建用于执行AOF文件包含的Redis命令的伪客户端，并在载入完成之后，关闭这个伪客户端。</p> <ol start="5"><li>重点回顾</li></ol> <p>a). 服务器状态结构使用clients链表连接起多个客户端状态，新添加的客户端状态会被放到链表的末尾</p> <p>b). 客户端状态的flags属性使用不同标志来表示客户端的角色，以及客户端当前所处的状态。</p> <p>c). 输入缓冲区记录了客户端发送的命令请求，这个缓冲区的大小不能超过1GB。</p> <p>d). 命令的参数和参数个数会被记录在客户端状态的argv和argc属性里面，而cmd属性则记录了客户端要执行命令的实现函数。</p> <p>e). 客户端由固定大小缓冲区和可变大小缓冲区两种缓冲区可用，其中固定大小缓冲区的最大大小为16KB，而可变大小缓冲区的最大大小不能超过服务器设置的硬性限制值。</p> <p>f). 输出缓冲区限制值有两种，如果输出缓冲区的大小超过了服务器设置的硬性限制，那么客户端会被立即关闭；除此之外，如果客户端在一定时间内，一直超过服务器设置的软性限制，那么客户端也会被关闭。</p> <p>g). 当一个客户端通过网络连接连接上服务器时，服务器会为这个客户端创建相应的客户端状态。网络连接关闭，发送了不合协议格式的命令请求，成为CLIENT KILL 命令的目标，空转时间超时，输出缓冲区的大小超出限制，以上都会造成客户端被关闭。</p> <p>h). 处理Lua脚本的伪客户端在服务器初始化时创建，这个客户端会一直存在，直到服务器关闭。</p> <p>i). 载入AOF文件时使用的伪客户端在载入工作开始时动态创建，载入工作完毕之后关闭。</p> <h2 id="服务器"><a href="#服务器" class="header-anchor">#</a> 服务器</h2> <h3 id="命令请求的执行过程"><a href="#命令请求的执行过程" class="header-anchor">#</a> 命令请求的执行过程</h3> <p>一个命令请求从发送到获得回复的过程中，客户端和服务器需要完成一系列操作。</p> <p>举例：</p> <p>我们使用客户端执行以下命令：</p> <div class="language- extra-class"><pre class="language-text"><code>SET KEY VALUE
</code></pre></div><p>那么从客户端发送SET KEY VALUE命令到获得回复OK期间，客户端和服务器共需要执行以下操作：</p> <p>a). 客户端向服务器发送命令请求SET KEY VALUE.</p> <p>b). 服务器接收并处理客户端发来的命令请求SET KEY VALUE. 在数据库中进行设置操作，并产生命令回复OK。</p> <p>c). 服务器将命令回复OK发送给客户端。</p> <p>d). 客户端接收服务器返回的命令回复OK, 并将这个回复打印给用户观看。</p> <ol><li>发送命令请求</li></ol> <p>Redis服务器的命令请求来自Redis客户端，当用户在客户端中键入一个命令请求时，客户端将这个命令请求转换成协议格式，然后通过连接到服务器的套接字，将协议格式的命令请求给服务器。</p> <p>如：客户端输入如下命令</p> <div class="language-sh extra-class"><pre class="language-sh"><code>SET KEY VALUE
</code></pre></div><p>那么客户端会将这个命令转换成协议：</p> <div class="language- extra-class"><pre class="language-text"><code>*3\r\n$3\r\nSET\r\n$3\r\nKEY\r\n$5\r\nVALUE\r\n
</code></pre></div><p>然后将这段协议内容发送给服务器。</p> <ol start="2"><li>读取命令请求</li></ol> <p>当客户端与服务器之间的连接套接字因为客户端的写入而变得可读时，服务器将调用命令请求处理器来执行以下操作：</p> <p>a). 读取套接字中协议格式的命令请求，并将其保存到客户端状态的输入缓冲区里面。</p> <p>b). 对输入缓冲区中的命令请求进行分析，提取出命令请求中包含的命令参数，以及命令参数的个数，然后分别将参数和参数个数保存到客户端状态的argv属性和argc属性里面。</p> <p>c). 调用命令执行器，执行客户端指定的命令。</p> <ol start="3"><li>命令执行器(1): 查找命令实现</li></ol> <p>命令执行器要做的第一件事就是根据客户端状态的argv[0]参数，在命令表(command table)中查找参数所指定的命令，并将找到的命令保存到客户端状态的cmd属性里面。</p> <p>命令表是一个字典，字典键为一个个命令名字，而字典的值为一个个redisCommand结构。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">/*
 * Redis 命令
 */</span>
<span class="token keyword">struct</span> <span class="token class-name">redisCommand</span> <span class="token punctuation">{</span>

    <span class="token comment">// 命令名字</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">;</span>

    <span class="token comment">// 实现函数 函数指针，指向命令的实现函数，比如setCommand。</span>
    redisCommandProc <span class="token operator">*</span>proc<span class="token punctuation">;</span>

    <span class="token comment">// 参数个数</span>
    <span class="token comment">// 用于检查命令请求的格式是否正确。如果这个值为负数-N，那么表示参数的数量大于等于N。</span>
    <span class="token keyword">int</span> arity<span class="token punctuation">;</span>

    <span class="token comment">// 字符串表示的 FLAG</span>
    <span class="token comment">// 字符串形式的标识值，这个值记录了命令的属性，比如这个命令是写命令还是读命令，这个命令是否允许在载入数据时使用，这个命令是否允许在Lua脚本中使用。</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>sflags<span class="token punctuation">;</span> <span class="token comment">/* Flags as string representation, one char per flag. */</span>

    <span class="token comment">// 实际 FLAG</span>
    <span class="token comment">// 对sflags标识进行分析得出的二进制标识，由程序自动生成。服务器对命令标识进行检查时使用的都是flags属性而不是sflags属性，因为对二进制标识的检查可以方便地通过 &amp; ，^, ~等操作来完成。</span>
    <span class="token keyword">int</span> flags<span class="token punctuation">;</span>    <span class="token comment">/* The actual flags, obtained from the 'sflags' field. */</span>

    <span class="token comment">/* Use a function to determine keys arguments in a command line.
     * Used for Redis Cluster redirect. */</span>
    <span class="token comment">// 从命令中判断命令的键参数。在 Redis 集群转向时使用。</span>
    redisGetKeysProc <span class="token operator">*</span>getkeys_proc<span class="token punctuation">;</span>

    <span class="token comment">/* What keys should be loaded in background when calling this command? */</span>
    <span class="token comment">// 指定哪些参数是 key</span>
    <span class="token keyword">int</span> firstkey<span class="token punctuation">;</span> <span class="token comment">/* The first argument that's a key (0 = no keys) */</span>
    <span class="token keyword">int</span> lastkey<span class="token punctuation">;</span>  <span class="token comment">/* The last argument that's a key */</span>
    <span class="token keyword">int</span> keystep<span class="token punctuation">;</span>  <span class="token comment">/* The step between first and last key */</span>

    <span class="token comment">// 统计信息</span>
    <span class="token comment">// microseconds 记录了命令执行耗费的总毫微秒数</span>
    <span class="token comment">// calls 是命令被执行的总次数</span>
    <span class="token keyword">long</span> <span class="token keyword">long</span> microseconds<span class="token punctuation">,</span> calls<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>sflags的标识有如下意义：</p> <table><thead><tr><th style="text-align:center;">标识</th> <th style="text-align:center;">意义</th> <th style="text-align:center;">带有这个标识的命令</th></tr></thead> <tbody><tr><td style="text-align:center;">w</td> <td style="text-align:center;">这是一个写入命令，可能会修改数据库</td> <td style="text-align:center;">SET, RPUSH, DEL等等</td></tr> <tr><td style="text-align:center;">r</td> <td style="text-align:center;">这是一个只读命令，不会修改数据库</td> <td style="text-align:center;">GET,STRLEN,EXISTS等等</td></tr> <tr><td style="text-align:center;">m</td> <td style="text-align:center;">这个命令可能会占用大量内存，执行之前需要先检查服务器的内存使用情况，如果内存紧缺的话就禁止执行这个命令</td> <td style="text-align:center;">SET, APPEND, RPUSH, LPUSH, SADD, SINTERSTORE等等</td></tr> <tr><td style="text-align:center;">a</td> <td style="text-align:center;">这是一个管理命令</td> <td style="text-align:center;">SAVE, BGSAVE, SHUTDOWN 等等</td></tr> <tr><td style="text-align:center;">p</td> <td style="text-align:center;">这是一个发布与订阅功能方面的命令</td> <td style="text-align:center;">PUBLISH, SUBSCRIBE, PUBSUB 等等</td></tr> <tr><td style="text-align:center;">s</td> <td style="text-align:center;">这个命令不可以在Lua脚本中使用</td> <td style="text-align:center;">BRPOP, BLPOP, BRPOPLPUSH, SPOP等等</td></tr> <tr><td style="text-align:center;">R</td> <td style="text-align:center;">这是一个随机命令，对于相同的数据集和相同的参数，命令返回的结果可能不同</td> <td style="text-align:center;">SPOP, SRANDMEMBER, SSCAN, RANDOMKEY 等等</td></tr> <tr><td style="text-align:center;">S</td> <td style="text-align:center;">当在Lua脚本中使用这个命令时，对这个命令的输出结果进行一次排序，使得命令结果有序</td> <td style="text-align:center;">SINTER, SUNION, SDIFF, SMEMBERS, KEYS 等等</td></tr> <tr><td style="text-align:center;">l</td> <td style="text-align:center;">这个命令可以在服务器载入数据的过程中使用</td> <td style="text-align:center;">INFO, SHUTDOWN, PUBLISH等等</td></tr> <tr><td style="text-align:center;">t</td> <td style="text-align:center;">这是一个允许从服务器在带有过期数据时使用的命令</td> <td style="text-align:center;">SLAVEOF, PING, INFO等等</td></tr> <tr><td style="text-align:center;">M</td> <td style="text-align:center;">这个命令在监视器(monitor)模式下不会自动被传播</td> <td style="text-align:center;">EXEC</td></tr></tbody></table> <ol start="4"><li>命令执行器(2): 执行预备操作</li></ol> <p>到目前为止，服务器已经将执行命令所需多的命令实现函数(保存在客户端状态的cmd属性)，参数(保存在客户端状态的argv属性)，参数个数(保存在客户端状态的argc属性)都收集齐了，但是在真正执行命令之前，程序还需要进行一些预备操作，从而确保命令可以正确，顺利地被执行。这些操作包括：</p> <p>a). 检查客户端状态的cmd指针是否指向null，如果是的话，那么说明用户输入的命令名字找不到相应的命令实现，服务器不再执行后续步骤，并向客户端返回一个错误。</p> <p>b). 根据客户端cmd属性指向的redisCommand结构的arity属性，检查命令请求所给定的参数个数是否正确，当参数个数不正确时，不再执行后续步骤，直接向客户端返回一个错误。</p> <p>c). 检查客户端是否已经通过了身份验证，未通过身份验证的客户端只能执行AUTH命令，如果未通过身份验证的客户端试图执行除AUTH命令之外的其他命令，那么服务器将向客户端返回一个错误。</p> <p>d). 如果服务器打开了maxmemory功能，那么在执行命令之前，先检查服务器器的内存占用情况，并在有需要时进行内存回收，从而使得接下来的命令可以顺利执行。如果内存回收失败，那么不再执行后续步骤，向客户端返回一个错误。</p> <p>e). 如果服务器上一次执行BGSAVE命令时出错，并且服务器打开了stop-writes-on-bgsave-error功能，而且服务器即将要执行的命令是一个写命令，那么服务器将拒绝执行这个命令，并向客户端返回一个错误。</p> <p>f). 如果客户端当前正在用SUBSCRIBE命令订阅频道，或者正在用PSUBSCRIBE命令订阅模式，那么服务器只会执行客户端发来的SUBSCRIBE, PSUBSCRIBE, UNSUBSCRIBE, PUNSUBSCRIBE四个命令，其他命令都会被服务器拒绝。</p> <p>g). 如果服务器正在进行数据载入，那么客户端发送的命令必须要带有l标识才会被执行，其他命令都会被拒绝。</p> <p>h). 如果服务器因为执行Lua脚本而超时并进入阻塞状态，那么服务器只会执行客户端发来的SHUTDOWN nosave命令和SCRIPT KILL 命令，其他命令都会被服务器拒绝。</p> <p>i). 如果客户端正在执行事务，那么服务器只会执行客户端发来的EXEC，DISCARD, MULTI, WATCH四个命令，其他命令都会被放进事务队列中。</p> <p>j). 如果服务器打开了监视器功能，那么服务器会将要执行的命令和参数等信息发送给监视器。当完成了以上预备操作之后，服务器就可以开始真正执行命令了。</p> <p>注： 以上只列出服务器在单机模式下执行命令的检查操作，当服务器在复制或集群模式下，预备操作还会更多。</p> <ol start="5"><li>命令执行器(3): 调用命令实现函数</li></ol> <p>完成以上两步后，只要执行以下语句就可以了：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">// client 是指向客户端状态的指针</span>
client <span class="token operator">-&gt;</span> cmd <span class="token operator">-&gt;</span> <span class="token function">proc</span><span class="token punctuation">(</span>client<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// set命令等于执行 setCommand(client) 语句</span>
</code></pre></div><p>被调用的命令实现函数会执行指定的操作，并产生相应的命令回复，这些回复会被保存在客户端状态的输出缓冲区里面(buf属性和reply属性)，之后实现函数还会未客户端的套接字关联命令回复处理器，这个处理器负责将命令回复返回给客户端。</p> <ol start="6"><li>命令执行器(4): 执行后续工作</li></ol> <p>在执行完实现函数之后，服务器还需要执行一些后续工作：</p> <p>a). 如果服务器开启了慢查询日志功能，那么慢查询日志模块会检查是否需要为刚刚执行完的命令请求添加一条新的慢查询日志。</p> <p>b). 根据刚刚执行命令所耗费的时长，更新被执行命令的redisCommand结构的milliseconds属性，并将命令的redisCommand结构的calls计数器的值增一。</p> <p>c). 如果服务器开启了AOF持久化功能，那么AOF持久化模块会将刚刚执行的命令请求写入到AOF缓冲区里面</p> <p>d). 如果有其他正在复制当前这个服务器，那么服务器会将刚刚执行的命令传播给所有从服务器。</p> <ol start="7"><li>将命令回复发送给客户端</li></ol> <p>命令实现函数会将命令回复保存到客户端的输出缓冲区中，并未客户端的套接字关联命令回复处理器，当客户端套接字变为可写状态时，服务器就会执行命令回复处理器，将保存在客户端输出缓冲区中的命令回复发送给客户端。</p> <p>当命令回复发送完毕之后，回复处理器会清空客户端状态的输出缓冲区，未处理下一个命令请求做好准备。</p> <ol start="8"><li>客户端接收并打印命令回复</li></ol> <p>客户端接收到协议格式的命令回复之后，会将这些回复转换未人类可读的格式。</p> <p>以上步骤为redis客户端和服务器执行命令请求的整个过程。</p> <h3 id="servercron-函数"><a href="#servercron-函数" class="header-anchor">#</a> serverCron 函数</h3> <p>Redis服务器中的serverCron函数默认每隔100毫秒执行一次，这个函数负责管理服务器的资源，并保持服务器自身的良好运转。</p> <p>以下将介绍redis中与serverCron函数有关的属性</p> <ol><li>更新服务器时间缓存</li></ol> <p>redis服务器中有不少功能需要获取系统的当前时间，而每次获取系统的当前时间都需要执行一次系统调用，为了减少系统调用执行次数，服务器状态中的unixtime属性和mstime属性被用作当前时间的缓存：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">redisServer</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  <span class="token comment">// 保存了秒级精度的系统当前UNIX时间戳</span>
  time_t unixtime<span class="token punctuation">;</span>
  <span class="token comment">// 保存了毫秒级精度的系统当前UNIX时间戳</span>
<span class="token punctuation">}</span>

</code></pre></div><p>因为serverCron函数默认会以每100毫秒一次的频率更新unixtime属性和mstime属性，所以这两个属性记录的时间的精确度并不高：</p> <p>a). 服务器只会在打印日志，更新服务器的LRU时钟，决定是否执行持久化任务，计算服务器上线时间(uptime)这类对时间精度要求不高的功能上。</p> <p>b). 对于为键设置过期时间，添加慢查询日志这种需要高精度时间的功能来说，服务器还是会再次执行系统调用，从而获取最准确的系统当前时间。</p> <ol start="2"><li>更新LRU时钟</li></ol> <p>服务器状态中的lrulock属性保存了服务器的LRU时钟，这个属性和上面介绍的unixtime属性，mstime属性一样，都是服务器时间缓存的一种：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">redisServer</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  <span class="token comment">// 默认每10秒更新一次的时钟缓存，</span>
  <span class="token comment">// 用于计算键的空转时长</span>
  <span class="token keyword">unsigned</span> lrulock<span class="token operator">:</span><span class="token number">22</span><span class="token punctuation">;</span>
  <span class="token comment">// </span>
<span class="token punctuation">}</span>
</code></pre></div><p>每个redis对象都会有一个lru属性，这个lru属性保存了对象最后一次被命令访问的时间：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">redisObject</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  <span class="token keyword">unsigned</span> lru<span class="token operator">:</span><span class="token number">22</span><span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span> robj<span class="token punctuation">;</span>
</code></pre></div><p>当服务器要计算一个数据库键的空转时间(也即是数据库键对应的值对象的空转时间)，程序会用服务器的lrulock属性记录的时间减去对象的lru属性记录的时间，得出的计算结果就是这个对象的空转时间。</p> <p>serverCron函数默认会以每10秒一次的频率更新lruclock属性的值，这个时钟不是实时的，所以根据这个属性计算出来的LRU时间实际上只是一个模糊的估算值。</p> <p>lrulock时钟的当前值可以通过INFO server 命令的lru_clock域查看。</p> <ol start="3"><li>更新服务器每秒执行命令次数</li></ol> <p>serverCron函数中的trackOperationsPerSecond函数会以每100毫秒一次的频率执行，这个函数的功能是以抽样计算的方式，估计并记录服务器在最近一秒钟处理的命令请求数量，这个值可以通过INFO status 命令的 instantaneous_ops_per_sec 域查看。</p> <p>trackOperationsPerSecond函数和服务器状态中四个ops_sec_开头的属性有关：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">redisServer</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  <span class="token comment">// 上一次进行抽样的时间</span>
  <span class="token keyword">long</span> <span class="token keyword">long</span> ops_sec_last_sample_time<span class="token punctuation">;</span>
  <span class="token comment">// 上一次抽样时，服务器已执行命令的数量</span>
  <span class="token keyword">long</span> <span class="token keyword">long</span> ops_sec_last_sample_ops<span class="token punctuation">;</span>
  <span class="token comment">// REDIS_OPS_SEC_SMAPLES 大小 (默认值为16)的环形数组</span>
  <span class="token comment">// 数组中的每个项都记录了一次抽样结果</span>
  <span class="token keyword">long</span> <span class="token keyword">long</span> ops_sec_samples<span class="token punctuation">[</span>REDIS_OPS_SEC_SAMPLES<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token comment">// ops_sec_samples数组的索引值，</span>
  <span class="token comment">// 每次抽样后将值自增一，</span>
  <span class="token comment">// 在值等于16时重置为0</span>
  <span class="token comment">// 让ops_sec_samples 数组构成一个环形数组。</span>
  <span class="token keyword">int</span> ops_sec_idx<span class="token punctuation">;</span>
  <span class="token comment">// ....</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>trackOperationsPerSecond函数每次运行，都会根据ops_sec_last_sample_time记录的上一次抽样时间和服务器的当前时间，以及ops_sec_last_sample_ops记录的上一次抽样的已执行命令数量和服务器当前的已执行命令数量，计算出两次 trackOperationsPerSecond调用之间，服务器平均每一毫秒处理了多少个命令请求，然后将这个平均值乘以1000，这就得到了服务器在一秒钟内能处理多少个命令请求的估计值，这个估计值被作为一个新的数组项被放进ops_sec_samples环形数组里面。</p> <p>当客户端执行INFO命令时，服务器就会调用 getOperationsPerSecond函数，根据ops_sec_samples环形数组中的抽样结果，计算出instantaneous_ops_per_sec属性的值，以下是getOperationsPerSecond函数的实现代码：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token function">getOperatonsPerSecond</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> j<span class="token punctuation">;</span>
  <span class="token keyword">long</span> <span class="token keyword">long</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token comment">// 计算所有取样值的总和</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> REDIS_OPS_SEC_SAMPLES<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    sum <span class="token operator">+=</span> server<span class="token punctuation">.</span>ops_sec_samples<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 计算取样的平均值</span>
  <span class="token keyword">return</span> sum <span class="token operator">/</span> REDIS_OPS_SEC_SAMPLES<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>根据getOperationsPerSecond函数的定义可以看出，instantaneous_ops_per_sec属性的值是通过计算最近 REDIS_OPS_SEC_SAMPLES次取样的平均值来计算得出的，它只是一个估算值。</p> <ol start="4"><li>更新服务器内存峰值记录</li></ol> <p>服务器状态中的stat_peak_memory 属性记录了服务器的内存峰值大小.</p> <p>每次serverCron函数执行时，程序都会查看服务器当前使用的内存数量，并与stat_peak_memory 保存的数值进行比较，如果当前使用的内存数量比stat_peak_memory属性记录的值要大，那么程序就将当前使用的内存数量记录到 stat_peak_memory 属性里面。</p> <p>INFO memory命令的 used_memory_peak 和 used_memory_peak_human 两个域分别以两种格式记录了服务器的内存峰值：</p> <div class="language-sh extra-class"><pre class="language-sh"><code>redis<span class="token operator">&gt;</span> INFO memory
<span class="token comment"># Memory</span>
<span class="token punctuation">..</span>.
used_memory_peak:501824
used_memory_peak_human:490.06k
<span class="token punctuation">..</span>.
</code></pre></div><ol start="5"><li>处理SIGTERM信号</li></ol> <p>在启动服务器时，redis会为服务器进行的SIGTERM信号处理器 sigtermHandler 函数，这个信号处理器负责在服务器接到 SIGTERM 信号时，打开服务器状态的 shutdown_asap标识：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">// SIGTERM信号的处理器</span>
<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sigtermHandler</span><span class="token punctuation">(</span><span class="token keyword">int</span> sig<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 打印日志</span>
  <span class="token function">redisLogFromHandler</span><span class="token punctuation">(</span>REDIS_WARNING<span class="token punctuation">,</span> <span class="token string">&quot;Received SIGTERM, scheduling shutdown...&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 打开关闭标识</span>
  server<span class="token punctuation">.</span>shutdown_asap <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>每次serverCron 函数运行时，程序都会服务器状态的shutdown_asap属性进行检查，并根据属性的值决定是否关闭服务器：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">redisServer</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  <span class="token comment">// 关闭服务器的标识</span>
  <span class="token comment">// 值为1时，关闭服务器</span>
  <span class="token comment">// 职位0时，不做动作</span>
  <span class="token keyword">int</span> shutdown_asap<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><ol start="6"><li>管理客户端资源</li></ol> <p>serverCron 函数每次执行都会调用 clientsCron 函数，clientsCron函数会对一定数量的客户端进行以下两个检查：</p> <p>a). 如果客户端与服务器之间的连接已经超时(很长一段时间里客户端和服务器都没有互动)，那么程序释放这个客户端</p> <p>b). 如果客户端在上一次执行命令请求之后，输入缓冲区的大小超过了一定的长度，那么程序会释放客户端当前的输入缓冲区，并重新创建一个默认大小的输入缓冲区，从而客户端的输入缓冲区耗费了过多的内存。</p> <ol start="7"><li>管理数据库资源</li></ol> <p>serverCron 函数每次执行都会调用databasesCron 函数，这个函数会对服务器中的一部分数据库进行检查，删除其中的过期键，并在有需要时，对字典进行收缩操作。</p> <ol start="8"><li>执行被延迟的BGREWRITEAOF</li></ol> <p>在服务器执行BGSAVE命令的期间，如果客户端向服务器发来BGREWRITEAOF命令，那么服务器会将BGREWRITEAOF命令的执行时间延迟到BGSAVE命令执行完毕之后。</p> <p>服务器的aof_rewrite_scheduled标识记录了服务器是否延迟了BGREWRITEAOF命令：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">redisServer</span> <span class="token punctuation">{</span>
  <span class="token comment">// ..</span>
  <span class="token comment">// 如果值为1，那么表示有 BGREWRITEAOF命令被延迟了</span>
  <span class="token keyword">int</span> aof_rewrite_scheduled<span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre></div><p>每次serverCron函数执行时，函数都会检查BGSAVE命令或者BGREWRITEAOF命令是否正在执行，如果这个两个命令都没在执行，并且aof_rewrite_scheduled属性的值为1，那么服务器就会执行之前被推延的BGREWRITEAOF命令。</p> <ol start="9"><li>检查持久化操作的运行状态</li></ol> <p>服务器状态使用rdb_child_pid属性和aof_child_pid属性记录执行BGSAVE命令和BGREWRITEAOF命令的子进程的ID，这两个属性也可以用于检查BGSAVE命令或者BGREWRITEAOF命令是否正在执行：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">redisServer</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  <span class="token comment">// 记录执行BGSAVE命令的子进程的ID：</span>
  <span class="token comment">// 如果服务器灭有在执行BGSAVE,那么这个属性值为-1</span>
  pid_t rdb_child_pid<span class="token punctuation">;</span>
  <span class="token comment">// 记录执行BGREWRITEAOF命令的子进程的ID</span>
  <span class="token comment">// 如果服务器没有在执行BGREWRITEAOF,那么这个属性的值为-1</span>
  pid_t aof_child_pid<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>每次serverCron函数执行时，程序都会检查rdb_child_pid 和aof_child_pid两个属性的值，只要其中一个属性的值不为-1，程序就会执行一次wait3函数，检查子进程是否有信号发来服务器进程：</p> <p>a). 如果有信号到达，那么表示新的RDB文件已经生成完毕(对于BGSAVE命令来说)，或者AOF文件已经重写完毕(对于BGREWRITEAOF命令来说)，服务器需要进行相应命令的后续操作，比如用新的RDB文件替换现有的RDB文件，或者用重写后的AOF文件替换现有的AOF文件。</p> <p>b). 如果没有信号到达，那么表示持久化操作未完成，程序不做动作。</p> <p>如果 rdb_child_pid 和 aof_child_pid 两个属性的值都为-1，那么表示服务器在进行持久化操作，在这种情况下，程序执行以下三个检查：</p> <p>a). 查看是否有BGREWRITEAOF被延迟了，如果有的话，那么开始一次新的BGREWRITEAOF操作。</p> <p>b). 检查服务器的自动保存条件是否已经被满足，如果条件满足，并且服务器没有在执行其他持久化操作，那么服务器开始一次新的BGSAVE操作。(因为条件1可能会引发一次BGREWRITEAOF, 所以在这个检查中，程序会再次确认服务器是否已经在执行持久化操作了)</p> <p>c). 检查服务器设置的AOF重写条件是否满足，如果条件满足，并且服务器没有在执行其他持久化操作，那么服务器将会开始一次新的BGREWRITEAOF操作。(因为条件1和条件2都可能会引起新的持久化擦欧总，所以在这个检查中，我们要再次确认服务器是否已经在执行持久化操作了)</p> <ol start="10"><li>将AOF缓冲区中的内容写入AOF文件</li></ol> <p>如果服务器开启了AOF持久化功能，并且AOF缓冲区里面还有带写入的数据，那么serverCron函数会调用相应的程序，将AOF缓冲区中的内容写入到AOF文件里面。</p> <ol start="11"><li>关闭异步客户端</li></ol> <p>服务器会关闭那些输出缓冲区大小超出限制的客户端。</p> <ol start="12"><li>增加cronloops计数器的值</li></ol> <p>服务器状态的cronloops属性记录了serverCron函数执行的次数</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">redisServer</span> <span class="token punctuation">{</span>
  <span class="token comment">//.. </span>
  <span class="token comment">// serverCron函数的运行次数计数器</span>
  <span class="token comment">// serverCron函数每执行一次，这个属性的值就增1</span>
  <span class="token keyword">int</span> cronloops<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>cronloops属性目前在服务器中的唯一作用，就是在复制模块中实现&quot;每执行serverCron函数N次就执行一次指定代码&quot;的功能：</p> <div class="language-py extra-class"><pre class="language-py"><code><span class="token keyword">if</span> cronloops <span class="token operator">%</span> N <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>
  <span class="token comment"># 执行指定代码...</span>
</code></pre></div><h3 id="初始化服务器"><a href="#初始化服务器" class="header-anchor">#</a> 初始化服务器</h3> <p>redis服务器从启动到能够接收客户端的命令请求，需要经过一系列的初始化和设置过成，比如初始化服务器状态，接受用户指定的服务器配置，创建相应的数据结构和网络连接等等。</p> <ol><li>初始化服务器状态结构</li></ol> <p>初始化服务器的第一步是创建一个struct redisServer类型的实例变量server作为服务器的状态，并为结构中的各个属性设置默认值。</p> <p>该部分功能由redic.c/initServerConfig函数完成。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">initServerConfig</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 设置服务器的运行id</span>
  <span class="token function">getRandomHexChars</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>runid<span class="token punctuation">,</span>REDIS_RUN_ID_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 为运行id加上结尾字符</span>
  server<span class="token punctuation">.</span>runid<span class="token punctuation">[</span>REDIS_RUN_ID_SIZE<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'\0'</span><span class="token punctuation">;</span>

  <span class="token comment">// 设置默认配置文件路径</span>
  server<span class="token punctuation">.</span>configfile <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>

  <span class="token comment">// 设置默认服务器频率</span>
  server<span class="token punctuation">.</span>hz <span class="token operator">=</span> REDIS_DEFAULT_HZ<span class="token punctuation">;</span>

  <span class="token comment">// 设置服务器的运行架构</span>
  server<span class="token punctuation">.</span>arch_bits <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">64</span> <span class="token operator">:</span> <span class="token number">32</span><span class="token punctuation">;</span>

  <span class="token comment">// 设置默认服务器端口号</span>
  server<span class="token punctuation">.</span>port <span class="token operator">=</span> REDIS_SERVERPORT<span class="token punctuation">;</span>

  <span class="token comment">// ....</span>
<span class="token punctuation">}</span>

</code></pre></div><p>initServerConfig函数主要完成的工作：</p> <p>a). 设置服务器运行ID</p> <p>b). 设置服务器的默认运行频率</p> <p>c). 设置服务器的默认配置文件路径</p> <p>d). 设置服务器的运行架构</p> <p>e). 设置服务器的默认端口号</p> <p>f). 设置服务器的默认RDB持久化条件和AOF持久化条件</p> <p>g). 初始化服务器的LRU时钟</p> <p>h). 创建命令表</p> <p>initServerConfig函数设置的服务器状态属性基本都是一些整数，浮点数，或字符串属性，除了命令表之外，initServerConfig函数没有创建服务器状态的其他数据结构，数据库，慢查询，Lua环境，共享对象这些数据结构在之后的步骤才会创建。</p> <p>当initServerConfig函数执行完毕之后，服务器就可以进入初始化的第二阶段————载入配置选项。</p> <ol start="2"><li>载入配置选项</li></ol> <p>在启动服务器时，用户可以通过给定配置参数或指定配置文件来修改服务器的默认配置：</p> <div class="language-sh extra-class"><pre class="language-sh"><code>$ redis-server --port <span class="token number">10086</span>
</code></pre></div><p>另外还可以通过配置文件进行设置</p> <div class="language-sh extra-class"><pre class="language-sh"><code>$ redis-server redis.conf
</code></pre></div><p>conf文件, 以下只是一些简单设置</p> <div class="language-conf extra-class"><pre class="language-text"><code># 将服务器的数据库数量设置为32个
databases 32

# 关闭 RDB文件的压缩功能
rdbcompression no
</code></pre></div><p>服务器在用initServerConfig函数初始化完server变量后，就会开始载入用户给定的配置参数和配置文件，并根据用户设定的配置，对server变量相关属性的值进行修改。</p> <ol start="3"><li>初始化服务器数据结构</li></ol> <p>载入配置选项值创建了命令表一个数据结构，除了命令表外，服务器状态还包含其他数据结构。</p> <p>a). server.clients链表，这个链表记录了所有与服务器相连的客户端的状态结构，链表的每个节点都包含了一个redisClient结构实例。</p> <p>b). server.db数组，数组中包含了服务器的所有数据库</p> <p>c). 用于保存频道订阅信息的server.pubsub_channels字典，以及用于保存模式订阅信息的server.pubsub_patterns链表。</p> <p>d). 用于执行Lua脚本的Lua环境server.lua</p> <p>e). 用于保存慢查询日志的servers.slowlog属性</p> <p>当初始化服务器进行到这一步，服务器将调用initServer函数，为以上提到的数据结构分配内存，并在有需要时，为这些数据结构设置或者关联初始化值。</p> <p>服务器到现在才初始化数据结构的原因在于，服务器必须先载入用户指定的配置选项，然后才能正确地对数据结构进行初始化。如果在执行initServerConfig函数时就对数据结构进行初始化，那么一旦用户通过配置选项修改了和数据结构有关地服务器状态属性，服务器就要重新调整和修改已创建地数据结构。为了避免出现这种麻烦地情况，服务器选择了将server状态地初始化分为两步进行，initServerConfig函数主要负责初始化一般属性，而initServer函数主要负责初始化数据结构。</p> <p>initServer除了初始化数据结构之外，还进行了一些非常重要地设置操作，其中包含：</p> <p>a). 为服务器设置进程信号处理器</p> <p>b). 创建共享对象：这些对象包含Redis服务器经常用到地一些值，比如包含&quot;OK&quot;回复地字符串对象，包含&quot;ERR&quot;回复的字符串对象，包含整数1到10000的字符串对象等等，服务器通过重用这些共享对象来避免反复创建相同的对象。</p> <p>c). 打开服务器的监听端口，并为监听套接字关联连接应答事件处理器，等待服务器正式运行时接受客户端的连接。</p> <p>d). 为serverCron函数创建时间事件，等待服务器正式运行时执行serverCron函数。</p> <p>e). 如果AOF持久化功能已经打开，那么打开现有的AOF文件，如果AOF文件不存在，那么创建并打开一个新的AOF文件，为AOF写入做好准备。</p> <p>f). 初始化服务器的后台I/O模块(bio), 为将来的I/O操作做好准备。</p> <p>当initServer函数执行完毕之后，服务器将用ASCII字符在日志中打印出Redis的图标，以及Redis的版本号信息。</p> <ol start="4"><li>还原数据库状态</li></ol> <p>在完成了对服务器状态server变量的初始化之后，服务器需要载入RDB文件或者AOF文件，并根据文件记录的内容来还原服务器的数据库状态。</p> <p>根据服务器是否启用了AOF持久化功能，服务器载入数据时所使用的目标文件会有所不同：</p> <p>a). 如果服务器启用了AOF持久化功能，那么服务器使用AOF文件来原数据库状态。</p> <p>b). 相反地，如果服务器没有启用AOF持久化功能，那么服务器使用RDB文件来还原数据库状态。</p> <p>当服务器完成数据库状态还原工作之后，服务器将在日志中打印出载入文件并还原数据库状态所耗费地时长。</p> <ol start="5"><li>执行事件循环</li></ol> <p>服务器打印日志</p> <div class="language- extra-class"><pre class="language-text"><code>... The server is now ready to accept connections on port 6379
</code></pre></div><p>并开始执行服务器地事件循环。</p> <p>至此，服务器地初始化工作圆满完成，服务器现在开始接受客户端地连接请求，并处理客户端发来地命令请求了。</p> <h3 id="重点回顾-3"><a href="#重点回顾-3" class="header-anchor">#</a> 重点回顾</h3> <p>a). 一个命令请求从发送到完成主要包括以下步骤: 1). 客户端将命令请求发送给服务器. 2). 服务器读取命令请求，并分析出命令参数. 3). 命令执行器根据参数查找命令的实现函数，然后执行实现函数并得出命令回复. 4). 服务器将命令回复返回给客户端。</p> <p>b). serverCron函数默认每隔100毫秒执行一次，它的工作主要包括更新服务器状态信息，处理服务器接收的SIGTERM信号，管理客户端资源和数据库状态，检查并执行持久化操作等等。</p> <p>c). 服务器从启动能够处理客户端的命令请求需要执行以下步骤：1). 初始化服务器状态；2). 载入服务器配置；3). 初始化服务器数据结构；5). 还原数据库状态；6). 执行事件循环。</p> <h2 id="复制"><a href="#复制" class="header-anchor">#</a> 复制</h2> <p>redis中，用户可以通过执行SLAVEOF命令或者设置slaveof选项，让一个服务器去复制(replicate)另一个服务器。</p> <p>命令：</p> <div class="language- extra-class"><pre class="language-text"><code>SLAVEOF ip port
</code></pre></div><p><a href="http://redis.io/topics/replication" target="_blank" rel="noopener noreferrer">官方文档<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h3 id="旧版本复制功能的实现"><a href="#旧版本复制功能的实现" class="header-anchor">#</a> 旧版本复制功能的实现</h3> <p>redis复制功能分为同步(sync)和命令传播两个操作</p> <p>a). 同步操作用于将从服务器的数据库状态更新至主服务器当前所处的数据库状态。</p> <p>b). 命令传播操作则用于在主服务器的数据库状态被修改，导致主从服务器的数据库状态出现不一致时，让主从服务器的数据库重新回到一致状态。</p> <ol><li>同步</li></ol> <p>当客户端向从服务器发送SLAVEOF命令，要求从服务器复制主服务器时，从服务器首先需要执行同步操作。也即是，将从服务器的数据库状态更新至主服务器当前所处的数据库状态。</p> <p>从服务器对主服务器的同步操作需要通过向主服务器发送SYNC命令来完成，SYNC步骤如下：</p> <p>a). 从服务器向主服务器发送SYNC命令</p> <p>b). 收到SYNC命令的主服务器执行BGSAVE命令，在后台生成一个RDB文件，并使用一个缓冲区记录从现在开始执行的所有写命令。</p> <p>c). 当主服务器的BGSAVE命令执行完毕时，主服务器会将BGSAVE命令生成的RDB文件发送给从服务器，从服务器接收并载入这个RDB文件，将自己的数据库状态更新至主服务器执行BGSAVE命令时的数据库状态。</p> <p>d). 主服务器将记录在缓冲区里面的所有命令发送给从服务器，从服务器执行这些写命令，将自己的数据库状态更新至主服务器数据当前所处的状态。</p> <ol start="2"><li>命令传播</li></ol> <p>在同步操作执行完毕后，主从服务器两者的数据库将达到一致状态，但这种一致不是一成不变的，当主服务器执行客户端发送的写命令时，主服务器的数据库就有可能会被修改，并导致主从服务器状态不再一致。</p> <p>为了让主从服务器再次回到一致状态，主服务器需要对从服务器执行命令传播操作：主服务器会将自己执行的写命令，也即是造成主从服务器不一致的那条写命令，发送给从服务器执行，当从服务器执行了相同的写命令之后，主从服务器将再次回到一致状态。</p> <h3 id="旧版复制功能的缺陷"><a href="#旧版复制功能的缺陷" class="header-anchor">#</a> 旧版复制功能的缺陷</h3> <p>在redis中，从服务器对主服务器的复制可以分为以下两种情况：</p> <p>a). 初次复制：从服务器以前没有复制过任何主服务器，或者从服务器当前要复制的主服务器和上一次复制的主服务器不同。</p> <p>b). 断线后重复制：处于命令传播阶段的主从服务器因为网络原因而中断了复制，但从服务器通过主动重连接重新连上了主服务器，并继续复制主服务器。</p> <p>初次复制，旧版功能能够很好地完成任务，但对于断线后重新复制来说，旧版复制功能虽然也能让主从复制重新回到一致状态，但效率却非常低。</p> <p>断线后，从服务器终于重新连接上主服务器，从服务器将向主服务器发送SYNC命令，而主服务器会将包含所有键的RDB文件发送给从服务器，从服务器通过接收和载入这个RDB文件来将自己的数据库更新至主服务器数据当前所处的状态。</p> <p>SYNC命令是一个非常消耗资源的操作</p> <p>每次执行SYNC命令，主从服务器需要执行以下动作：</p> <p>a). 主服务器需要执行BGSAVE命令来生成RDB文件，这个生成操作会耗费主服务器大量的CPU, 内存和磁盘I/O资源。</p> <p>b). 主服务器需要将自己生成的RDB文件发送给从服务器，这个发送操作会耗费主从服务器大量的网络资源(宽带和流量)，并对主服务器响应命令请求的时间产生影响。</p> <p>c). 接收到RDB文件的从服务器需要载入主服务器发来的RDB文件，并在载入期间，从服务器会因为阻塞而没有办法处理命令请求。</p> <p>因为SYNC命令是一个十分耗费资源的操作，所以Redis有必要保证在真正有需要的时候才执行SYNC命令。</p> <h3 id="新版复制功能的实现"><a href="#新版复制功能的实现" class="header-anchor">#</a> 新版复制功能的实现</h3> <p>Redis为哦了解决旧版出现的问题，Redis从2.8版本开始，使用PSYNC命令代替SYNC命令来执行复制时的同步操作。</p> <p>PSYNC命令具有完成重同步(full resynchronization)和部分重同步(partial resynchronization)两者模式：</p> <p>a). 完整重同步用于处理初次复制情况：完整重同步的执行步骤和SYNC命令的执行步骤基本一样，都是通过让主服务器创建并发送RDB文件，以及向服务器发送保存在缓冲区里面的写命令来进行同步。</p> <p>b). 而部分重同步则用来处理断线后重复制情况：当从服务器在断线后重新连接主服务器时，如果条件允许，主服务器可以将主从服务器连接断开期间执行的写命令发送给从服务器，从服务器只要接收并执行这些写命令，就可以将数据库更新至主服务器当前所处的状态。</p> <h3 id="部分重同步的实现"><a href="#部分重同步的实现" class="header-anchor">#</a> 部分重同步的实现</h3> <p>部分重同步功能由以下三部分构成：</p> <p>a). 主服务器的复制偏移量(replication offset)和从服务器的复制偏移量。</p> <p>b). 主服务器的复制积压缓冲区(replication backlog)。</p> <p>c). 服务器的运行ID(run ID).</p> <ol><li>复制偏移量</li></ol> <p>执行复制的双方————主服务器和从服务器都会分别维护一个复制偏移量。</p> <p>a). 主服务器每次向从服务器传播N个字节的数据时，就将自己的复制偏移量的值加上N。</p> <p>b). 从服务器每次收到主服务器传播来的N个字节的数据时，就将自己的复制偏移量的值加上N。</p> <p>通过对比主从服务器的复制偏移量，程序可以很容易地直到主从服务器是否处于一致状态：</p> <p>a). 如果主从服务器处于一致状态，那么主从服务器两者地偏移量总是相同地。</p> <p>b). 相反，如果主从服务器的偏移量不相同，说明主从服务器并未处于一致状态。</p> <ol start="2"><li>复制积压缓冲区</li></ol> <p>复制积压缓冲区是由主服务器维护的一个固定长度(fixed-size)先进先出(FIFO)队列，默认大小为1MB.</p> <p>固定长度先进先出队列的入队和出队规则跟普通的先进先出队列一样：新元素从一边进入队列，而旧元素从另一边弹出队列。该队列长度是固定的，当入队元素的数量大于队列长度时，最先入队的元素会被弹出，而新元素会被放入队列。</p> <p>当服务器进行命令传播时，它不仅会将写命令发送给所有从服务器，还会将写命令入队到复制积压缓冲区里面。</p> <p>主服务器的复制积压缓冲区里面会保存着一部分最近传播的写命令，并且复制积压缓冲区会为队列种的每个字节记录相应的复制偏移量。</p> <p>当从服务器重新脸上主服务器时，从服务器会通过PSYNC命令将自己的复制偏移量offset发送给主服务器，主服务器会根据这个复制偏移量来决定对从服务器执行何种同步操作：</p> <p>a). 如果offset命令偏移量之后的数据(也即是偏移量offset + 1开始的数据)仍然存在于复制积压缓冲区里面，那么主服务器将对从服务器执行部分重同步操作。</p> <p>b). 如果offset偏移量之后的数据已经不存在复制积压缓冲区，那么冲服务器将对从服务器执行完整重同步操作。</p> <p>所以需要根据需要调整积压缓冲区的大小。默认为1MB，如果主服务器需要执行大量写命令，或者主从服务器断线后重连接所需要的时间比较长，则需要调大积压缓冲区大小。</p> <p>复制积压缓冲区的大小大小可以根据以下公式进行估算。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>second <span class="token operator">*</span> write_size_per_second 
</code></pre></div><p>其中second为从服务器断线后重新连接上主服务器所需的平均时间。</p> <p>而write_size_per_second则是主服务器平均每秒产生的写命令数据量(协议格式的写命令的长度总和)。</p> <p>且为了安全起见，可以将复制积压缓冲区的大小设为 2 * second * write_size_per_second, 这样可以保证绝大部分断线情况都能用部分重同步来处理。</p> <ol start="3"><li>服务器运行ID</li></ol> <p>a). 每个redis服务器，不论主服务器还是从服务器，都会有自己的运行ID</p> <p>b). 运行ID在服务器启动时自动生成，由40个随机的十六进行符号组成。</p> <p>当从服务器对主服务器进行初次复制时，主服务器会将自己的运行id传送给从服务器，从而服务器则hi将这个运行ID保存起来。</p> <p>当从服务器断线并重新连上一个主服务器时，从服务器将向当前连接的主服务器发送之前保存的运行Id：</p> <p>a) 如果从服务器保存的运行ID和当前连接的主服务器运行ID相同，那么说明从服务器断线之前复制的就是当前连接的这个主服务器，主服务器可以继续尝试执行部分重同步操作。</p> <p>b) 如果从服务器保存的运行ID和当前连接的主服务器的运行ID并不相同，那么说明从服务器断线之前复制的主服务器并不是当前连接的这个主服务器，主服务器将对从服务器执行完整重同步操作。</p> <h3 id="psync命令的实现"><a href="#psync命令的实现" class="header-anchor">#</a> PSYNC命令的实现</h3> <p>PSYNC命令的调用方式有两种：</p> <p>a). 如果从服务器以前没有复制过任何主服务器，或者之前执行过SLAVEOF no one命令，那么从服务器在开始一次新的复制时将向主服务器发送PSYNC ? -1 命令，主动请求主服务器进行完整重同步。</p> <p>b). 如果服务器已经复制过某个主服务器，那么从服务器开始一次新的复制会将会向主服务器发送PSYNC <runid><offset> 命令：其中runid为上一次复制的主服务器的运行ID, 而offset则是从服务器当前的复制偏移量，接收到这个命令的主服务器会通过这个参数来判断应该对从服务器执行哪种同步操作。</offset></runid></p> <p>根据情况，接收到PSYNC命令的主服务器会向从服务器返回以下三种回复的其中一种：</p> <p>a). 如果主服务器返回+ FULLRESYNC <runid><offset> 回复，那么表示主服务器将与从服务器执行完整重同步操作：其中runid是这个主服务器的运行ID, 从服务器会将这个ID保存起来，在下一次发送PSYNC命令时使用；而offset则是主服务器当前的复制偏移量，从服务器会将这个值作为自己的初始化偏移量。</offset></runid></p> <p>b). 如果主服务器返回 + CONTINUE 回复，那么表示主服务器将与从服务器执行部分重同步操作，从服务器只要等着主服务器将自己缺少的那部分数据发送过来就可以了。</p> <p>c). 如果主服务器返回 -ERR 回复，那么表示主服务器版本低于Redis2.8，无法失败PSYNC命令，从服务器将向主服务器发送SYNC命令，并与主服务器执行完整同步操作。</p> <h3 id="复制的实现"><a href="#复制的实现" class="header-anchor">#</a> 复制的实现</h3> <p>通过向从服务器发送SLAVEOF命令，我们可以让一个从服务器去复制一个主服务器：</p> <div class="language-sh extra-class"><pre class="language-sh"><code>SLAVEOF <span class="token operator">&lt;</span>master_ip<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>master_port<span class="token operator">&gt;</span>
</code></pre></div><ol><li>步骤1：设置主服务器的地址和端口</li></ol> <p>当客户端向从服务器发送以下命令时</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token number">127.0</span>.0.1:12345 <span class="token operator">&gt;</span> SLAVEOF <span class="token number">127.0</span>.0.1  <span class="token number">6379</span>
OK
</code></pre></div><p>从服务器首先要做的就是将客户端给定的主服务器ip地址127.0.0.1以及端口保存到服务器状态的masterhost属性和 masterport 属性里面：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">redisServer</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  <span class="token comment">// 主服务器的地址</span>
  <span class="token keyword">char</span> <span class="token operator">*</span>masterhost<span class="token punctuation">;</span>
  <span class="token comment">// 主服务器的端口</span>
  <span class="token keyword">int</span> masterport<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><ol start="2"><li>步骤2：建立套接字连接</li></ol> <p>在SLAVEOF命令执行之后，从服务器将根据命令所设置的ip地址和端口，创建连向主服务器的套接字连接。</p> <p>如果从服务器创建的套接字能成功连接到主服务器，那么从服务器将成为这个套接字关联一个专门用于处理复制工作的文件事件处理器，这个处理器将复制执行后续的复制工作，比如接收RDB文件，以及接收主服务器传播来写命令。</p> <p>主服务器在接受(accpt)从服务器的套接字连接之后，将为该套接字创建相应的客户端状态，并将从服务器看作是一个连接到主服务器的客户端来对待，这时从服务器将同时具有服务器(server)和客户端(client)两个身份：从服务器可以向主服务器发送命令请求，而主服务器则会向从服务器返回命令回复。</p> <ol start="3"><li>步骤3：发送ping命令</li></ol> <p>从服务器成为主服务器的客户端之后，第一件事就是向主服务器发送一个PING命令。</p> <p>作用：</p> <p>a). 检查套接字的读写状态是否正常</p> <p>b). 检查主服务器能否正常处理命令请求。</p> <p>一般会遇到三种情况：</p> <p>a). 主服务器向从服务器返回一个命令回复，但从服务器却不能在规定的时限内读取出命令回复的内容，那么表示主从服务器之间的网络连接状态不佳，不能继续执行复制工作的后续步骤。这种情况，从服务器断开并重新创建连向主服务器的套接字。</p> <p>b). 如果主服务器向从服务器返回一个错误，那么表示主服务器暂时没办法处理从服务器的命令请求，不能继续执行复制工作的后续步骤。这种情况，从服务器断开并重新创建连向主服务器的套接字。</p> <p>c). 如果从服务器读取到&quot;PONG&quot;回复，那么表示主从服务器之间的网络连接状态正常。并且主服务器可以正常处理从服务器发送的命令请求。</p> <ol start="4"><li>步骤4：身份验证</li></ol> <p>a). 如果从服务器设置了masterauth选项，那么进行身份验证。</p> <p>b). 没有设置，则不进行身份验证。</p> <p>身份验证，从服务器将向主服务器发送一条AUTH命令，命令的参数为从服务器masterauth选项的值。</p> <p>发送后，会遇到以下几种情况：</p> <p>a). 如果主服务器没有设置requirepass选项，并且从服务器也没有设置masterauth选项，那么主服务器将继续执行从服务器发送的命令，复制工作可以继续。</p> <p>b). 如果从服务通过AUTH命令发送的密码和主服务器requirepass选项所设置的密码相同，那么主服务器将继续执行从服务器发送的命令，复制工作可以继续进行。否则将返回密码错误。</p> <p>c). 如果主服务器设置了requirepass选项，但从服务器没有设置materauth选项，那么主服务器将返回一个NOAUTH错误。如果主服务区没有设置requirepass选项，但从服务器设置了masterauth选项，那么主服务器返回一个no password is set 错误。</p> <ol start="5"><li>步骤5：发送端口信息</li></ol> <p>从服务器将执行命令REPLCONF listening-port <port-number>, 向主服务器发送从服务器的监听端口号。</port-number></p> <p>主服务器接受到这个命令后，会将端口号记录在从服务器所对应的客户端状态 slave_listening_port属性中：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">redisClient</span> <span class="token punctuation">{</span>
  <span class="token comment">// 从服务器的监听端口号</span>
  <span class="token keyword">int</span> slave_listening_port<span class="token punctuation">;</span>
<span class="token punctuation">}</span> redisClient<span class="token punctuation">;</span>
</code></pre></div><p>slave_listening_port属性目前唯一的作用就是在主服务器执行INFO replication命令时打印从服务器的端口号。</p> <ol start="6"><li>步骤6：同步</li></ol> <p>从服务器将向服务器发送PSYNC命令，执行同步操作，并将自己的数据库至主服务器数据库当前所处的状态。</p> <p>a). 如果PSYNC命令执行的是完整的重同步操作，那么主服务器需要成为从服务器的客户端，才能将保存在缓冲区里面的写命令发送给从服务器执行。</p> <p>b). 如果PSYNC命令执行的是部分重同步操作，那么主服务器需要成为从服务器的客户端，才能向从服务器发送保存在复制积压缓冲区里面的写命令。</p> <p>同步操作执行之后，主从服务器双方都是对方的客户端，它们可以相互向对象发送命令请求，或者相互向对方返回命令回复。</p> <ol start="7"><li>步骤7：命令传播</li></ol> <p>当完成了同步之后，主从服务器就会进入命令传播阶段，这时主服务器只要一直将自己执行的写命令发送给从服务器，而从服务器只要一直接收并执行服务器发来的写命令，就可以保证主从服务器一直保持一致了。</p> <h3 id="心跳检测"><a href="#心跳检测" class="header-anchor">#</a> 心跳检测</h3> <p>在命令传播阶段，从服务器默认会以每秒一次的频率，向主服务器发送命令：</p> <div class="language-sh extra-class"><pre class="language-sh"><code>REPLCONF ACK <span class="token operator">&lt;</span>replication_offset<span class="token operator">&gt;</span>
</code></pre></div><p>其中replication_offset是从服务器当前的复制偏移量。</p> <p>发送REPLCONF ACK命令对于主从服务器有三个作用：</p> <p>a). 检测主从服务器的网络连接状态</p> <p>b). 辅助实现min-slaves选项</p> <p>c). 检测命令丢失</p> <ol><li>检测主从服务器的网络连接状态</li></ol> <p>如果主服务器超过一秒钟没有收到从服务器发来的REPLCONF ACK命令，那么主服务器就知道主从服务器之间的连接出问题了。</p> <p>通过向主服务器发送info replication命令，可以看到最后一次发送replconf ack命令距离限制多少秒了。</p> <ol start="2"><li>辅助实现min-slaves选项</li></ol> <p>redis的min-slaves-to-write和min-slaves-max-lag两个选项可以防止主服务器在不安全的情况下执行写命令。</p> <p>min-slaves-to-write：从服务器的个数。</p> <p>min-slaves-max-lag：从服务器的延迟都大于多少秒。</p> <p>这些情况，主服务器将拒绝执行写命令。</p> <ol start="3"><li>检测命令丢失</li></ol> <p>如果中间发送命令丢失，那么执行该命令时，主服务器将会发觉从服务器当前的复制偏移量少于自己的复制偏移量，在复制积压缓冲区里面找到从服务器缺少的数据，并将这些数据重新发送给从服务器。</p> <h3 id="重点回顾-4"><a href="#重点回顾-4" class="header-anchor">#</a> 重点回顾</h3> <p>a). redis 2.8以前的复制功能不能高效地处理断线后重复制情况，2.8后新添加部分重同步功能可以解决这个问题。</p> <p>b). 部分重同步通过复制偏移量，复制积压缓冲区，服务器运行ID三个部分来实现。</p> <p>c). 在复制操作刚开始地时候，从服务器会成为主服务器的客户端，并通过向主服务器发送命令请求来执行复制步骤，而在复制操作的后期，主从服务器会互相成为对方的客户端。</p> <p>d). 主服务器通过向从服务器传播命令来更新从服务器的状态，保持主从服务器一致，从而服务器则通过向主服务器发送命令来进行心跳检测，以及命令丢失检测。</p> <h2 id="sentinel-哨兵"><a href="#sentinel-哨兵" class="header-anchor">#</a> Sentinel 哨兵</h2> <p>Sentinel(哨岗，哨兵)是Redis的高可用性(high availability)解决方案：由一个或多个Sentinel实例(instance)组成的Sentinel系统(system)可以监视任意多个主服务器，以及这些主服务器属下的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线主服务器属下的某个从服务器升级为新的主服务器，然后由新的主服务器代替已下线的主服务器继续处理命令请求。</p> <p><img src="" alt="服务器与Sentinel系统"></p> <p>上图展示了Sentinel系统监视服务器的例子。其中：</p> <p>a). 用双环图案表示的是当前的主服务器server1.</p> <p>b). 用单环图案表示的是主服务器的三个从服务器server2，server3以及server4.</p> <p>c). server2, server3, server4三个从服务器正在复制主服务器server1，而Sentinel系统则在监视所有四个服务器。</p> <p>假设这时，主服务器server1进入下线状态，那么从服务器server2，server3，server4对主服务器的复制操作将被中止，并且Sentinel系统会察觉到server1已下线。</p> <p>当server1的下线时长超过用户设定的下线时长上限时，Sentinel系统就会对server1执行故障转移操作：</p> <p>a). 首先，Sentinel系统会挑选server1属下的其中一个从服务器，并将这个被选中的从服务器升级为新的主服务器。</p> <p>b). 之后，Sentinel系统会向server1属下的所有从服务器发送新的复制指令，让它们成为新的主服务器的从服务器，当所有从服务器都开始复制新的主服务器时，故障转移操作执行完毕。</p> <p>c). 另外，Sentinel还会继续监视已下线的server1，并在它重新上线时，将它设置为新的主服务器的从服务器。</p> <p>Sentinel系统会将某个节点升级为新的主服务器，并让服务器server3和server4成为server2的从服务器的过程。</p> <p>之后如果server1重新上线的话，它将被Sentinel系统降级为server2的从服务器。</p> <h3 id="启动并初始化sentinel"><a href="#启动并初始化sentinel" class="header-anchor">#</a> 启动并初始化Sentinel</h3> <p>启动一个Sentinel可以使用命令</p> <div class="language-sh extra-class"><pre class="language-sh"><code>$ redis-sentinel /path/to/your/sentinel.conf
</code></pre></div><p>或者命令：</p> <div class="language-sh extra-class"><pre class="language-sh"><code>$ redis-server /path/to/your/sentinel.conf --sentinel
</code></pre></div><p>这两个命令的效果完全一样。</p> <p>当一个Sentinel启动时，它需要执行以下步骤：</p> <p>a). 初始化服务器</p> <p>b). 将普通redis服务器使用的代码替换成Sentinel专用代码。</p> <p>c). 初始化Sentinel状态</p> <p>d). 根据给定的配置文件，初始化Sentinel的监视主服务器列表</p> <p>e). 创建连向主服务器的网络连接。</p> <ol><li>初始服务器</li></ol> <p>首先，因为Sentinel本质上只是一个运行在特殊模式下的redis服务器，所以启动Sentinel的第一步，就是初始化一个普通的redis服务器。</p> <p>不过，因为Sentinel执行的工作和普通redis服务器执行的工作不同，所以Sentinel的初始化过程和普通redis服务器的初始化过程并不完全相同。</p> <p>例如，普通服务器在初始化时会通过载入RDB文件或者AOF文件来还原数据库状态，但是因为Sentinel并不使用数据库，所以初始化sentinel时就不会载入RDB文件或者AOF文件。</p> <p>展示了redis服务器在sentinel模式下运行时，服务器各个主要功能的使用情况。</p> <table><thead><tr><th style="text-align:center;">功能</th> <th style="text-align:center;">使用情况</th></tr></thead> <tbody><tr><td style="text-align:center;">数据库和键值对方面的命令，比如SET, DEL, FLUSHDB</td> <td style="text-align:center;">不使用</td></tr> <tr><td style="text-align:center;">事务命令，比如MULTI 和 WATCH</td> <td style="text-align:center;">不使用</td></tr> <tr><td style="text-align:center;">脚本命令，比如EVAL</td> <td style="text-align:center;">不使用</td></tr> <tr><td style="text-align:center;">RDB持久化命令，比如SAVE和BGSAVE</td> <td style="text-align:center;">不使用</td></tr> <tr><td style="text-align:center;">AOF持久化命令，比如BGREWRITEAOF</td> <td style="text-align:center;">不使用</td></tr> <tr><td style="text-align:center;">复制命令，比如SLAVEOF</td> <td style="text-align:center;">Sentinel 内部可以使用，但客户端不可以使用</td></tr> <tr><td style="text-align:center;">发布与订阅命令，比如PUBLISH 和 SUBSCRIBE</td> <td style="text-align:center;">SUBSCRIBE, PSUBSCRIBE, UNSUBSCRIBE, PUNSUBSCRIBE四个命令在Sentinel内部和客户端都可以使用，但PUBLISH命令只能在Sentinel内部使用</td></tr> <tr><td style="text-align:center;">文件事件处理器(复制发送命令请求，处理命令回复)</td> <td style="text-align:center;">Sentinel 内部使用，但关联的文件事件处理器和普通redis服务器不同</td></tr> <tr><td style="text-align:center;">时间事件处理器(负责执行serverCron函数)</td> <td style="text-align:center;">sentinel内部使用，时间事件的处理器仍然是serverCron函数，serverCron函数会调用sentinel.c/sentinelTimer 函数，后者包含了Sentinel要执行的所有操作</td></tr></tbody></table> <ol start="2"><li>使用Sentinel专用代码</li></ol> <p>启动sentinel的第二个步骤就是将一部分普通服务器使用的代码替换成sentinel专用代码。比如说，普通redis服务器使用redis.h/REDIS_SERVERPORT常量的值作为服务器端口：</p> <div class="language- extra-class"><pre class="language-text"><code>#define REDIS_SERVERPORT 6379
</code></pre></div><p>而Sentinel则使用sentinel.c/REDIS_SENTINEL_PORT常量的值作为服务器端口：</p> <div class="language- extra-class"><pre class="language-text"><code>#define REDIS_SENTINEL_PORT 26379
</code></pre></div><p>除此之外，普通redis服务器使用redis.c/redisCommandTable作为服务器的命令表</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">redisCommand</span> redisCommandTable<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">{</span><span class="token string">&quot;get&quot;</span><span class="token punctuation">,</span>getCommand<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">&quot;r&quot;</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span><span class="token string">&quot;set&quot;</span><span class="token punctuation">,</span>setCommand<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">&quot;wm&quot;</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span><span class="token string">&quot;setnx&quot;</span><span class="token punctuation">,</span>setnxCommand<span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">&quot;wm&quot;</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token comment">// ....</span>
    <span class="token punctuation">{</span><span class="token string">&quot;script&quot;</span><span class="token punctuation">,</span>scriptCommand<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">&quot;ras&quot;</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span><span class="token string">&quot;time&quot;</span><span class="token punctuation">,</span>timeCommand<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">&quot;rR&quot;</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span><span class="token string">&quot;bitop&quot;</span><span class="token punctuation">,</span>bitopCommand<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token string">&quot;wm&quot;</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span><span class="token string">&quot;bitcount&quot;</span><span class="token punctuation">,</span>bitcountCommand<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">&quot;r&quot;</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token comment">/// ....</span>
<span class="token punctuation">}</span>
</code></pre></div><p>而Sentinel则使用sentinel.c/sentinelcmds作为服务器的命令表，并且其中的INFO命令会使用Sentinel模式下的专用实现sentinel.c/sentinelInfoCommand函数，而不是普通redis服务器使用的实现redis.c/infoCommand函数：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">redisCommand</span> sentinelcmds<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">{</span><span class="token string">&quot;ping&quot;</span><span class="token punctuation">,</span>pingCommand<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">&quot;&quot;</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span><span class="token string">&quot;sentinel&quot;</span><span class="token punctuation">,</span>sentinelCommand<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">&quot;&quot;</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span><span class="token string">&quot;subscribe&quot;</span><span class="token punctuation">,</span>subscribeCommand<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">&quot;&quot;</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span><span class="token string">&quot;unsubscribe&quot;</span><span class="token punctuation">,</span>unsubscribeCommand<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">&quot;&quot;</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span><span class="token string">&quot;psubscribe&quot;</span><span class="token punctuation">,</span>psubscribeCommand<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">&quot;&quot;</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span><span class="token string">&quot;punsubscribe&quot;</span><span class="token punctuation">,</span>punsubscribeCommand<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">&quot;&quot;</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span><span class="token string">&quot;publish&quot;</span><span class="token punctuation">,</span>sentinelPublishCommand<span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">&quot;&quot;</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span><span class="token string">&quot;info&quot;</span><span class="token punctuation">,</span>sentinelInfoCommand<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">&quot;&quot;</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span><span class="token string">&quot;shutdown&quot;</span><span class="token punctuation">,</span>shutdownCommand<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">&quot;&quot;</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>sentinelcmds命令表也解释了为什么在Sentinel模式下，redis服务器不能执行诸如 SET, DBSIZE, EVAL 等等这些命令，因为服务器根本没有在命令表中载入这些命令。PING, SENTINEL, INFO, SUBSCRIBE, UNSUBSCRIBE, PSUBSCRIBE 和 PUNSUBSCRIBE这七个命令就是客户端可以对Sentinel执行的全部命令了。</p> <ol start="3"><li>初始化Sentinel状态</li></ol> <p>在应用了sentinel的专用代码之后，接下来，服务器会初始化一个sentinel.c/sentinelState结构，这个结构保存了服务器中所有的Sentinel功能有关的状态(服务器的一般状态仍然由redis.h/redisServer结构保存)：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">/* Main state. */</span>
<span class="token comment">/* Sentinel 的状态结构 */</span>
<span class="token keyword">struct</span> <span class="token class-name">sentinelState</span> <span class="token punctuation">{</span>

    <span class="token comment">// 当前纪元</span>
    <span class="token keyword">uint64_t</span> current_epoch<span class="token punctuation">;</span>     <span class="token comment">/* Current epoch. */</span>

    <span class="token comment">// 保存了所有被这个 sentinel 监视的主服务器</span>
    <span class="token comment">// 字典的键是主服务器的名字</span>
    <span class="token comment">// 字典的值则是一个指向 sentinelRedisInstance 结构的指针</span>
    dict <span class="token operator">*</span>masters<span class="token punctuation">;</span>      <span class="token comment">/* Dictionary of master sentinelRedisInstances.
                           Key is the instance name, value is the
                           sentinelRedisInstance structure pointer. */</span>

    <span class="token comment">// 是否进入了 TILT 模式？</span>
    <span class="token keyword">int</span> tilt<span class="token punctuation">;</span>           <span class="token comment">/* Are we in TILT mode? */</span>

    <span class="token comment">// 目前正在执行的脚本的数量</span>
    <span class="token keyword">int</span> running_scripts<span class="token punctuation">;</span>    <span class="token comment">/* Number of scripts in execution right now. */</span>

    <span class="token comment">// 进入 TILT 模式的时间</span>
    mstime_t tilt_start_time<span class="token punctuation">;</span>   <span class="token comment">/* When TITL started. */</span>

    <span class="token comment">// 最后一次执行时间处理器的时间</span>
    mstime_t previous_time<span class="token punctuation">;</span>     <span class="token comment">/* Last time we ran the time handler. */</span>

    <span class="token comment">// 一个 FIFO 队列，包含了所有需要执行的用户脚本</span>
    list <span class="token operator">*</span>scripts_queue<span class="token punctuation">;</span>    <span class="token comment">/* Queue of user scripts to execute. */</span>

<span class="token punctuation">}</span> sentinel<span class="token punctuation">;</span>
</code></pre></div><ol start="4"><li>初始化Sentinel状态的masters属性</li></ol> <p>Sentinel状态中的masters字典记录了所有被sentinel监视的主服务器的相关信息，其中：</p> <p>a). 字典的键是被监视主服务器的名字</p> <p>b). 而字典的值则是被监视主服务器对应的sentinel.c/sentinelRedisInstance结构。</p> <p>每个sentinelRedisInstance结构代表一个被Sentinel监视的Redis服务器实例(instance), 这个实例可以是主服务器，从服务器或者另外一个Sentinel。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">sentinelRedisInstance</span> <span class="token punctuation">{</span>
    
    <span class="token comment">// 标识值，记录了实例的类型，以及该实例的当前状态</span>
    <span class="token keyword">int</span> flags<span class="token punctuation">;</span>      <span class="token comment">/* See SRI_... defines */</span>
    
    <span class="token comment">// 实例的名字</span>
    <span class="token comment">// 主服务器的名字由用户在配置文件中设置</span>
    <span class="token comment">// 从服务器以及 Sentinel 的名字由 Sentinel 自动设置</span>
    <span class="token comment">// 格式为 ip:port ，例如 &quot;127.0.0.1:26379&quot;</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">;</span>     <span class="token comment">/* Master name from the point of view of this sentinel. */</span>

    <span class="token comment">// 实例的运行 ID</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>runid<span class="token punctuation">;</span>    <span class="token comment">/* run ID of this instance. */</span>

    <span class="token comment">// 配置纪元，用于实现故障转移</span>
    <span class="token keyword">uint64_t</span> config_epoch<span class="token punctuation">;</span>  <span class="token comment">/* Configuration epoch. */</span>

    <span class="token comment">// 实例的地址</span>
    sentinelAddr <span class="token operator">*</span>addr<span class="token punctuation">;</span> <span class="token comment">/* Master host. */</span>

    <span class="token comment">// SENTINEL down-after-milliseconds 选项所设定的值</span>
    <span class="token comment">// 实例无响应多少毫秒之后才会被判断为主观下线（subjectively down）</span>
    mstime_t down_after_period<span class="token punctuation">;</span> <span class="token comment">/* Consider it down after that period. */</span>

    <span class="token comment">// SENTINEL monitor &lt;master-name&gt; &lt;IP&gt; &lt;port&gt; &lt;quorum&gt; 选项中的 quorum 参数</span>
    <span class="token comment">// 判断这个实例为客观下线（objectively down）所需的支持投票数量</span>
    <span class="token keyword">int</span> quorum<span class="token punctuation">;</span>         <span class="token comment">/* Number of sentinels that need to agree on failure. */</span>

    <span class="token comment">// SENTINEL parallel-syncs &lt;master-name&gt; &lt;number&gt; 选项的值</span>
    <span class="token comment">// 在执行故障转移操作时，可以同时对新的主服务器进行同步的从服务器数量</span>
    <span class="token keyword">int</span> parallel_syncs<span class="token punctuation">;</span> <span class="token comment">/* How many slaves to reconfigure at same time. */</span>

    <span class="token comment">// SENTINEL failover-timeout &lt;master-name&gt; &lt;ms&gt; 选项的值</span>
    <span class="token comment">// 刷新故障迁移状态的最大时限</span>
    mstime_t failover_timeout<span class="token punctuation">;</span>      <span class="token comment">/* Max time to refresh failover state. */</span>
    <span class="token comment">// ...</span>

<span class="token punctuation">}</span> sentinelRedisInstance<span class="token punctuation">;</span>
</code></pre></div><p>sentinelRedisInstance.addr属性是一个指向sentinel.c/sentinelAddr结构的指针，这个结构保存着实例的IP地址和端口号：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">sentinelAddr</span> <span class="token punctuation">{</span>
  <span class="token keyword">char</span> <span class="token operator">*</span>ip<span class="token punctuation">;</span>
  <span class="token keyword">int</span> port<span class="token punctuation">;</span>
<span class="token punctuation">}</span> sentinelAddr<span class="token punctuation">;</span>
</code></pre></div><p>对sentinel状态的初始化将引发对masters字典的初始化，而master字典的初始化是根据被载入的sentinel配置文件来进行的。</p> <ol start="5"><li>创建连向主服务器的网络连接</li></ol> <p>初始化Sentinel的最后一部是创建连向被监视主服务器的网络连接，sentinel将成为主服务器的客户端，它可以向主服务器发送命令，并从命令回复中获取相关的信息。</p> <p>对于每个被sentinel监视的主服务器来说，sentinel会创建两个连向主服务器的异步网络连接：</p> <p>a). 一个是命令连接，这个连接专门用于向主服务器发送命令，并接收命令回复。</p> <p>b). 另一个是订阅连接，这个连接专门用于订阅主服务器的__sentinel__: hello频道。</p> <p>问题: 为什么有两个连接？</p> <p>在redis目前的发布与订阅功能中，被发送的信息都不会保存在redis服务器里面，如果在信息发送时，想要接收信息的客户端不在线或者断线，那么这个客户端就会丢失这条信息。因此，为了不丢失__sentinel__: hello频道的任何信息，sentinel必须专门用一个订阅连接来接收该频道的信息。</p> <p>另一个，除了订阅频道之外，sentinel还必须向主服务器发送命令，以此来与主服务器进行通信，所以sentinel必须专门用一个订阅来连接来接收该频道的信息。</p> <p>另一方面，除了订阅频道之外，sentinel还必须向主服务器发送命令，以此来与主服务器进行通信，所以sentinel还必须向主服务器创建命令连接。</p> <p>因为sentinel需要与多个实例创建多个网络连接，所以sentinel使用的是异步连接。</p> <p><a href="">sentinel向主服务器创建网络连接</a></p> <h2 id="获取主服务器信息"><a href="#获取主服务器信息" class="header-anchor">#</a> 获取主服务器信息</h2> <p>Sentinel默认会以每十秒一次的频率，通过命令连接向被监视的主服务器发送INFO命令，并通过分析INFO命令的回复来获取主服务器的当前信息。</p> <p>sentinel收到服务器的信息，可以获取以下两方面的信息：</p> <p>a). 一方面是关于主服务器本身的信息，包括run_id域记录的服务器运行ID，以及role域记录的服务器角色。</p> <p>b). 另一方面是关于主服务器属于所有从服务器的信息，每个从服务器都由一个&quot;slave&quot;字符串开头的行记录，每行的ip=域记录了从服务器的IP地址，而port=域则记录了从服务器的端口号。根据这些ip地址和端口号，sentinel无须提供从服务器的地址信息，就可以自动发现从服务器。</p> <p>根据run_id域和role域记录的信息，sentinel将对主服务器的实例结构进行更新，例如，主服务器重启之后，它的运行ID就会和实例结构之前保存的运行ID不同，sentinel检测到这一情况之后，就会对实例结构的运行ID进行更新。</p> <p>至于主服务器返回的从服务器信息，则会被用于更新主服务器实例结构的slaves字典，这个字典记录了主服务器属下从服务器的名单：</p> <p>a). 字典的键是由sentinel自动设置的从服务器名字，格式为ip:port: 如对于IP地址为127.0.0.1, 端口号为11111的从服务器来说，sentinel为它设置的名字就是127.0.0.1:11111.</p> <p>b). 至于字典的值则是从服务器对应的实例结构：比如说，如果键是127.0.0.1:11111, 那么这个键的值就是IP地址为127.0.0.1，端口号为11111的从服务器的实例结构。</p> <p>Sentinel在分析INFO命令中包含的从服务器信息时，会检查从服务器对应的实例结构是否已经存在于slaves字典：</p> <p>a). 如果从服务器对应的实例结构已经存在，那么sentinel对从服务器的实例结构进行更新。</p> <p>b). 如果从服务器对应的实例结构不存在，那么说明这个从服务器是新发现的从服务器，sentinel会在slaves字典中为这个从服务器新创建一个实例结构。</p> <p><a href="">主服务器和它的三个从服务器</a></p> <p>注意对比图中主服务器实例结构和从服务器实例结构之间的区别：</p> <p>a). 主服务器实例结构的flags属性的值为SRI_MASTER, 而从服务器实例结构的flags属性的值为SRI_SLAVE.</p> <p>b). 主服务器实例结构的name属性的值是用户使用Sentinel配置文件设置的，而从服务器实例结构的name属性的值则是sentinel根据从服务器的IP地址和端口号自动设置的。</p> <h3 id="获取从服务器信息"><a href="#获取从服务器信息" class="header-anchor">#</a> 获取从服务器信息</h3> <p>当Sentinel发现主服务器有新的从服务器出现时，Sentinel除了会为这个新的从服务器创建相应的实例结构之外，Sentinel还会创建连接到从服务器的命令连接和订阅连接。</p> <p><a href="">sentinel与各个从服务器建立命令连接和订阅连接</a></p> <p>在创建命令连接之后，sentinel在默认情况下，会以每十秒一次的频率通过命令连接向从服务器发送INFO命令。</p> <p>根据INFO命令的回复，sentinel会提取出以下信息：</p> <p>a). 从服务器的运行ID run_id.</p> <p>b). 从服务器的角色role.</p> <p>c). 主服务器的IP地址master_host, 以及主服务器的端口号master_port.</p> <p>d). 主从服务器的连接状态master_link_status.</p> <p>e). 从服务器的优先级slave_priority.</p> <p>f). 从服务器的复制偏移量slave_repl_offset.</p> <p>根据这些信息，sentinel会对从服务器实例结构进行更新。</p> <h3 id="向主服务器和从服务器发送信息"><a href="#向主服务器和从服务器发送信息" class="header-anchor">#</a> 向主服务器和从服务器发送信息</h3> <p>在默认情况下，sentinel会以每两秒一次的频率，通过命令连接向所有被监视的主服务器和从服务器发送以下格式的命令：</p> <div class="language-sh extra-class"><pre class="language-sh"><code>PUBLISH  __sentinel__:hello  <span class="token string">&quot;&lt;s_ip&gt;,&lt;s_port&gt;,&lt;s_runid&gt;,&lt;s_epoch&gt;,&lt;m_name&gt;,&lt;m_ip&gt;,&lt;m_port&gt;,&lt;m_epoch&gt;&quot;</span>
</code></pre></div><p>这条命令向服务器的 <strong>sentinel</strong>:hello 频道发送了一条信息，信息的内容由多个参数组成：</p> <p>a). 其中以s_开头的参数记录的是sentinel本身的信息，各个参数的意义如下：</p> <table><thead><tr><th style="text-align:center;">参数</th> <th style="text-align:center;">意义</th></tr></thead> <tbody><tr><td style="text-align:center;">s_ip</td> <td style="text-align:center;">sentinel的ip地址</td></tr> <tr><td style="text-align:center;">s_port</td> <td style="text-align:center;">sentinel的端口号</td></tr> <tr><td style="text-align:center;">s_runid</td> <td style="text-align:center;">sentinel的运行ID</td></tr> <tr><td style="text-align:center;">s_epoch</td> <td style="text-align:center;">sentinel当前的配置纪元(configuration epoch)</td></tr></tbody></table> <p>b). 而m_开头的参数记录的则是主服务器的信息，各个参数的意义如下：</p> <table><thead><tr><th style="text-align:center;">参数</th> <th style="text-align:center;">意义</th></tr></thead> <tbody><tr><td style="text-align:center;">m_name</td> <td style="text-align:center;">主服务器的名字</td></tr> <tr><td style="text-align:center;">m_ip</td> <td style="text-align:center;">主服务器的IP地址</td></tr> <tr><td style="text-align:center;">m_port</td> <td style="text-align:center;">主服务器的端口号</td></tr> <tr><td style="text-align:center;">m_epoch</td> <td style="text-align:center;">主服务器当前的配置纪元</td></tr></tbody></table> <p>如果sentinel正在监视的主服务器，那么这些参数记录的就是主服务器的信息；如果sentinel正式监视的是从服务器，那么这些参数记录的就是从服务器正在复制的主服务器的信息。</p> <p>以下是一条sentinel通过PUBLISH命令向主服务器发送的信息示例：</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token string">&quot;127.0.0.1,26379,e955b4c85598ef5b5f055bc7ebfd5e828dbed4fa,0,mymaster,127.0.0.1,6379,0&quot;</span>
</code></pre></div><p>这个示例包含了以下信息：</p> <p>a). sentinel的ip地址为127.0.0.1端口号为26379，运行ID为 e955b4c85598ef5b5f055bc7ebfd5e828dbed4fa，当前的配置纪元为0.</p> <p>b). 主服务器的名字为mymaster, IP地址为127.0.0.1，端口号为6379，当前的配置纪元为0.</p> <h3 id="接收来自主服务器和从服务器的频道信息"><a href="#接收来自主服务器和从服务器的频道信息" class="header-anchor">#</a> 接收来自主服务器和从服务器的频道信息</h3> <p>当sentinel与一个主服务器或者从服务器建立起订阅连接之后，sentinel就会通过订阅连接，向服务器发送以下命令：</p> <div class="language- extra-class"><pre class="language-text"><code>SUBSCRIBE __sentinel__:hello
</code></pre></div><p>sentinel对 <strong>sentinel</strong>:hello 频道的订阅会一直持续到sentinel与服务器的连接断开为止。</p> <p>这也就是说，对于每个与sentinel连接的服务器，sentinel既通过命令连接向服务器的 <strong>sentinel</strong>:hello频道发送信息，又通过订阅连接从服务器的__sentinel__:hello频道接收信息。</p> <p>对于监视同一个服务器的多个sentinel来说，一个sentinel发送的信息会被其他sentinel接收到，这些信息会被用于更新其他sentinel对发送信息sentinel的认知，也会被用于更新其他sentinel对被监视服务器的认知。</p> <p>举个例子，假设现在有sentinel1，sentinel2，sentinel3三个sentinel再监视同一个服务器，那么当sentinel1向服务器向服务器的 <strong>sentinel</strong>:hello 频道发送一条信息时，所有订阅 <strong>sentinel</strong>:hello频道的sentinel(包括sentinel1自己在内)都会收到这条信息。</p> <p><a href="">向服务器发送信息</a></p> <p>当一个sentinel从__sentinel__:hello 频道收到一条信息时，sentinel会对这条信息进行分析，提取出信息中的sentinel IP地址，sentinel端口号，sentinel运行ID等八个参数，并进行以下检查：</p> <p>a). 如果信息中记录的sentinel运行id和接收信息的sentinel的运行id相同，说明这条信息是自己发送的，sentinel将丢弃这条信息，不做进一步处理。</p> <p>b). 相反地，如果信息中记录地sentinel运行ID和接收信息地sentinel地运行ID不相同，那么说明这条信息是监视同一个服务器地其他sentinel发来的，接收信息的sentinel将根据信息中的各个参数，对相应主服务器的实例结构进行更新。</p> <ol><li>更新sentinels字典</li></ol> <p>sentinel为主服务器创建的实例结构中的sentinels字典保存了除sentinel本身之外，所有同样监视这个主服务器的其他sentinel的资料。</p> <p>a). sentinel 字典的键是其中一个sentinel的名字，格式为ip:port。</p> <p>b). sentinel字典的值则是键所对应sentinel的实例结构，比如对于键&quot;127.0.0.1:26379&quot;来说，这个键sentinels字典中的值就是IP为127.0.0.1，端口为26379的sentinel的实例结构。</p> <p>当一个sentinel接收到其他sentinel发来的信息时(发送信息的sentinel为源sentinel，接收信息的sentinel为目标sentinel)，目标sentinel会从信息中分析并提取出以下两方面参数：</p> <p>a). 与sentinel有关的参数：源sentinel的ip地址，端口号，运行id和配置纪元。</p> <p>b). 与主服务器有关的参数：源sentinel正在监视的主服务器的名字，ip地址，端口号和配置纪元。</p> <p>根据信息中提取出的主服务器参数，目标sentinel会再自己的sentinel状态的masters字典中查找相应的主服务器实例结构，然后根据提取出的sentinel参数，检查主服务器实例结构的sentinels字典中，源sentinel的实例结构是否存在：</p> <p>a). 如果源sentinel的实例结构已经存在，那么对源sentinel的实例结构进行更新。</p> <p>b). 如果源sentinel的实例结构不存在，那么说明源sentinel是刚刚开始监视主服务器的新sentinel，目标sentinel会源sentinel创建一个新的实例结构，并将这个结构添加到sentinels字典里面。</p> <ol start="2"><li>创建连向其他sentinel的命令连接</li></ol> <p>当sentinel通过频道信息发现一个新的sentinel时，它不仅成为新sentinel在sentinels字典中创建相应的实例结构，还会创建一个连向新sentinel的命令连接，而新sentinel也同样会创建向这个sentinel的命令连接，最终监视同一主服务器多个sentinel将形成相互连接的网络：sentinel A有连向sentinel B的命令连接，而sentinel B也有连向sentinel A的命令连接。</p> <p>使用命令连接相连的各个sentinel可以通向其他sentinel发送命令请求来进行信息交换。</p> <p>sentinel之间不会创建订阅连接</p> <p>sentinel在连接主服务器或者从服务器时，会同时创建命令和订阅连接，但是在连接其他sentinel时，却只会创建命令连接，而不创建订阅连接。这是因为sentinel需要通过接收主服务器或者从服务器发来的频道信息来发现未知的新sentinel，所以才需要连接订阅连接，而相互已知的sentinel只要使用命令连接来进行通信就足够了。</p> <h3 id="检测主观下线状态"><a href="#检测主观下线状态" class="header-anchor">#</a> 检测主观下线状态</h3> <p>在默认情况下，sentinel会以每秒一次的频率向所有与它创建了命令连接的实例(包括主服务器，从服务器，其他sentinel在内)发送PING命令，并通过实例返回的PING命令回复来判断实例是否在线。</p> <p>实例对PING命令的回复可以分为以下两种情况：</p> <p>a). 有效回复：实例返回+PONG, -LOADING, -MASTERDOWN三种回复的其中一种。</p> <p>b). 无效回复：除有效回复之外的其他回复，或者在指定时限内没有返回任何回复。</p> <p>sentinel配置文件中的down-after-milliseconds选项指定了sentinel判断实例进入主观下线所需的时间长度：如果一个实例在down-after-milliseconds毫秒内，连续向sentinel返回无效回复，那么sentinel会修改这个实例所对应的实例结构，在结构的flags属性中打开SRI_S_DOWN标识，从此来表示这个实例已经进入主观下线状态。</p> <p>用户设置的down-after-milliseconds选项的值，不仅会被sentinel用来判断主服务器的主观下线状态，还会被用于判断主服务器属下的所有服务器，以及所有监视这个主服务器的其他sentinel的主观下线状态。</p> <p>多个sentinel设置的主观下线时长可能不同。</p> <h3 id="检查客观下线状态"><a href="#检查客观下线状态" class="header-anchor">#</a> 检查客观下线状态</h3> <p>当sentinel将一个主服务器判断为主观下线之后，为了确认这个主服务器是否真的下线了，它会向同样监视这一主服务器的其他sentinel进行询问，看它们是否也认为主服务器已经进入了下线状态(可以是主观下线或者客观下线)。当sentinel从其他sentinel那里接收到足够数量的已下线判断之后，sentinel就会将从服务器判定为客观下线，并对主服务器执行故障转移操作。</p> <ol><li>发送SENTINEL is-master-down-by-addr命令</li></ol> <p>sentinel使用：</p> <div class="language- extra-class"><pre class="language-text"><code>sentinel is-master-down-by-addr &lt;ip&gt; &lt;port&gt; &lt;current_epoch&gt; &lt;runid&gt;
</code></pre></div><table><thead><tr><th style="text-align:center;">参数</th> <th style="text-align:center;">意义</th></tr></thead> <tbody><tr><td style="text-align:center;">ip</td> <td style="text-align:center;">被sentinel判断为主观下线的主服务器的IP地址</td></tr> <tr><td style="text-align:center;">port</td> <td style="text-align:center;">被sentinel判断为主观下线的主服务器的端号</td></tr> <tr><td style="text-align:center;">current_epoch</td> <td style="text-align:center;">sentinel当前的配置纪元，用于选项领头sentinel</td></tr> <tr><td style="text-align:center;">runid</td> <td style="text-align:center;">可以是*符号或者sentinel的运行ID: *符号代表命令仅仅用于检测主服务器的客观下线状态，sentinel的运行id则用于选项领头sentinel</td></tr></tbody></table> <ol start="2"><li>接收SENTINEL is-master-down-by-addr命令</li></ol> <p>当一个Sentinel(目标sentinel)接收到另一个sentinel(源sentinel)发来的SENTINEL is-master-down-by命令时，目标sentinel会分析并取出命令请求中包含的各个参数，并根据其中的主服务器IP和端口号，检查主服务器是否已下线，然后向源sentinel返回一条包含三个参数的Multi Bulk回复作为SENTINEL is-master-down-by命令的回复:</p> <div class="language- extra-class"><pre class="language-text"><code>1) &lt;down_state&gt;
2) &lt;leader_runid&gt;
3) &lt;leader_epoch&gt;
</code></pre></div><table><thead><tr><th style="text-align:center;">参数</th> <th style="text-align:center;">意义</th></tr></thead> <tbody><tr><td style="text-align:center;">down_state</td> <td style="text-align:center;">返回目标sentinel对服务器的检查结果，1代表主服务器已下线，0代表主服务器未下线</td></tr> <tr><td style="text-align:center;">leader_runid</td> <td style="text-align:center;">可以是*符号或者目标sentinel的局部领头sentinel的运行ID：*符号代表命令仅仅用于检测主服务器的下线状态，而局部领头sentinel的运行ID则用于选举领头sentinel</td></tr> <tr><td style="text-align:center;">leader_epoch</td> <td style="text-align:center;">目标sentinel的局部领头sentinel的配置纪元，用于选举领头sentinel</td></tr></tbody></table> <ol start="3"><li>接收SENTINEL is-master-down-by-addr命令的回复</li></ol> <p>根据其他sentinel发回的SENTINEL is-master-down-by-addr命令回复。Sentinel将统计其他Sentinel同意主服务器已下线的数量，当这个一数量达到配置指定的判断客观下线所需的数量时，sentinel会将主服务器实例结构flags属性的SRI_O_DOWN标识打开，表示主服务器已经进入客观下线状态。</p> <p>客观下线状态的判断条件：</p> <p>当认为主服务器已经进入下线状态的sentinel数量，超过sentinel配置中设置的quorum参数的值，那么该sentinel就会认为主服务器已经进入客观下线状态。</p> <div class="language- extra-class"><pre class="language-text"><code>sentinel monitor master 127.0.0.1 6379 2
</code></pre></div><p>那么包括当前sentinel在内，只要总共有两个sentinel认为主服务器已经进入下线状态，那么当前sentinel就将主服务器判断为客观下线。</p> <p>不同sentinel判断客观下线的条件可能不同:</p> <p>对于监视同一个主服务器的多个sentinel来说，它们将主服务器标判断为客观下线的条件可能也不同：当一个sentinel将主服务器判断为客观下线时，其他sentinel可能并不这么认为。</p> <h3 id="选举领头sentinel"><a href="#选举领头sentinel" class="header-anchor">#</a> 选举领头Sentinel</h3> <p>当一个服务器被判断为客观下线时，监视这个下线主服务器的各个sentinel会进行协商，选举出一个领头sentinel，并由领头sentinel对下线主服务器执行故障转移操作。</p> <p>以下是redis选举领头sentinel的规则和方法：</p> <p>a). 所有在线的sentinel都有被选为领头sentinel的资格，换句话说，监视同一个主服务器的多个在线sentinel中的任意一个都有可能成为领头sentinel。</p> <p>b). 每个进行领头sentinel选举之后，不论选举是否成功，所有sentinel的配置纪元(configuration epoch)的值都会自增一次。配置纪元实际就是一个计数器，并没有什么特别的。</p> <p>c). 在一个配置纪元里面，所有sentinel都有一次将某个sentinel设置为局部领头sentinel的机会，并且局部领头一旦设置，在这个配置纪元里面就不能再更改。</p> <p>d). 每个发现主服务器进入客观下线的sentinel都会要求其他sentinel将自己设置为局部领头sentinel。</p> <p>e). 当一个sentinel(源sentinel)向另一个sentinel(目标sentinel)发送 SENTINEL is-master-down-by-addr命令，并且命令中的runid参数不是*符号而是源sentinel的运行ID时，这表示源sentinel要求目标sentinel将前者设置为后者的局部领头sentinel。</p> <p>f). sentinel设置局部领头sentinel的规则是先到先得：最先向目标sentinel发送设置要求的源sentinel将成为目标sentinel的局部领头sentinel，而之后接收到的所有设置要求都会被目标sentinel拒绝。</p> <p>g). 目标sentinel再接收到SENTINEL is-master-down-by-addr命令之后，将向sentinel返回一条命令回复，回复中的leader_runid参数和leader_epoch参数分别记录了目标sentinel的局部领头sentinel的运行ID和配置纪元。</p> <p>h). 源sentinel在接收到目标sentinel返回的命令回复之后，会检查回复中leader_epoch参数的值和自己的配置纪元是否相同，如果相同的话，那么源sentinel继续取出回复中的leader_runid参数，如果leader_runid参数的值和源sentinel的运行id一致，那么表示目标sentinel将源sentinel设置成了局部领头sentinel。</p> <p>i). 如果有某个sentinel被半数以上的sentinel设置成了局部领头sentinel，那么这个sentinel成为领头sentinel。</p> <p>j). 因为领头sentinel的产生需要半数以上sentinel的支持，并且每个sentinel在每个配置纪元里面只能设置一次局部领头sentinel，所以在一个配置纪元里面，只会出现一个领头sentinel。</p> <p>k). 如果在给定时限内，没有一个sentinel被选举为领头sentinel，那么各个sentinel将在一段时间之后再次进行选举，直到选出领头sentinel为止。</p> <p>例如：有三个sentinel正在监视同一个主服务器，并且这三个sentinel之前已经通过SENTINEL is-master-down-by-addr命令确认主服务器进入了客观下线状态。</p> <p>那么为了选出领头sentinel，三个sentinel将再次向其他sentinel发送SENTINEL is-master-down-by-addr命令。</p> <p>和检测客观下线状态时发送的SENTINEL is-master-down-by-addr命令不同，sentinel这次发送的命令会带有sentinel自己的运行ID.</p> <p>如果接收到这个命令的sentinel还没有设置局部领头sentinel的话，它就会将运行ID的sentinel设置为自己的局部领头sentinel，并返回命令回复。</p> <p>然后接收到命令回复的sentinel就可以根据这一回复，统计出有多少个sentinel将自己设置成了局部领头sentinel。</p> <p>根据命令请求发送的先后顺序不同，可能会有某个sentinel的SENTINEL is-master-down-by-addr命令比起其他sentinel发送的相同命令都更快到达，并最终胜出领头sentinel的选举，然后这个领头sentinel就可以开始对主服务器执行故障转移操作了。</p> <h3 id="故障转移"><a href="#故障转移" class="header-anchor">#</a> 故障转移</h3> <p>在选举产出领头sentinel之后，领头sentinel将对已下线的主服务器执行故障转移操作，该操作包含以下三个步骤：</p> <p>a). 在已下线主服务器属下的所有从服务器里面，挑选出一个从服务器，并将其转换为主服务器。</p> <p>b). 让已下线主服务器属下的所有从服务器改为复制新的主服务器。</p> <p>c). 将已下线主服务器设置为新的主服务器的从服务器，当这个旧的主服务器重新上线时，它就会成为新的主服务器的从服务器。</p> <ol><li>选出新的主服务器</li></ol> <p>故障转移操作第一步要做的就是在已下线主服务器属下的所有从服务器中，挑选出一个状态良好，数据完整的从服务器，然后向这个从服务器发送slaveof no one命令，将这个从服务器转换为主服务器。</p> <p>新的主服务器是怎样挑选出来的：</p> <p>领头sentinel会将已下线主服务器的所有从服务器保存到一个列表里面，然后按照以下规则，一项一项地对列表进行过滤：</p> <p>a). 删除列表中所有处于下线或者断线状态地从服务器，这可以保证列表中剩余地从服务器都是正常在线的。</p> <p>b). 删除列表中所有最近五秒内没有回复过领头sentinel的INFO命令的从服务器，这可以保证列表中剩余的从服务器都是最近成功进行过通信的。</p> <p>c). 删除所有与已下线主服务器连接断开超过down-after-millisenconds * 10 毫秒的从服务器： down-after-milliseconds选项指定了判断主服务器下线所需的时间，而删除断开时长超过down-after-milliseconds * 10 毫秒的从服务器，则可以保证列表中剩余的从服务器都没有过早地与主服务器断开连接，换句话说，列表中剩余的从服务器保存的数据都是比较新的。</p> <p>之后，领头sentinel将根据从服务器的优先级，对列表中剩余的从服务器进行排序，并选出其中优先级最高的从服务器。</p> <p>如果有多个具有相同最高优先级的从服务器，那么领头sentinel将按照从服务器的复制偏移量，对具有相同最高优先级的所有从服务器进行排序，选出其中偏移量最大的从服务器。</p> <p>如果还有相同的，那么领头sentinel将按照运行ID对这些从服务器进行排序，并选出其中运行ID最小的从服务器。</p> <ol start="2"><li>修改从服务器的复制目标</li></ol> <p>当新的主服务器出现之后，领头sentinel下一步要做的就是，让已下线主服务器属下的所有从服务器去复制新的主服务器，这一动作可以通过向从服务器发送slaveof命令实现的。</p> <ol start="3"><li>将旧的主服务器变成从服务器</li></ol> <p>将已下线的主服务器设置为新的主服务器的从服务器。</p> <p>因为旧的主服务器已经下线，当主服务器重新上线时，sentinel会向它发送slaveof命令，成为新的主服务器的从服务器。</p> <h3 id="重点回顾-5"><a href="#重点回顾-5" class="header-anchor">#</a> 重点回顾</h3> <p>a). sentinel 只是一个运行在特殊模式下的redis服务器，它使用了和普通模式不同的命令表，所以sentinel模式能够使用的命令和普通redis服务器能够使用的命令不同。</p> <p>b). sentinel会读入用户指定的配置文件，为每个要被监视的主服务器创建相应的实例结构，并创建连向主服务器的命令连接和订阅连接，其中命令连接用于主服务器发送命令请求，而订阅连接则用于接收指定频道的消息。</p> <p>c). sentinel通过向主服务器发送INFO命令来获得主服务器属下所有从服务器的地址信息，并为这些从服务器创建相应的实例结构，以及连向这些从服务器的命令连接和订阅连接。</p> <p>d). 在一般情况下，sentinel以每十秒一次的频率向被监视的主服务器和从服务器发送INFO命令，当主服务器处于下线状态，或者sentinel正在对主服务器进行故障转移操作时，sentinel向从服务器发送INFO命令的频率会改为每秒一次。</p> <p>e). 对于监视同一个主服务器和从服务器的多个sentinel来说，它们会以每两秒一次的频率，通过向监视服务器的__sentinel__:hello频道发送消息来向其他sentinel宣告自己的存在。</p> <p>f). 每个sentinel也会从__sentinel__:hello频道中接收其他sentinel发来的信息，并根据这些信息为其他sentinel创建相应的实例结构以及命令连接。</p> <p>g). sentinel 只会与主服务器和从服务器创建命令连接和订阅连接，sentinel与sentinel之间只创建命令连接</p> <p>h). sentinel以每秒一次的频率向实例发送ping命令，并根据实例对ping命令的回复来判断实例是否在线，当一个实例在指定的时长中连续向sentinel发送无效回复时，sentinel会将这个实例判断为主观下线。</p> <p>i). 当sentinel将一个主服务器判断为主观下线时，它会向同样监视这个主服务器的其他sentinel进行询问，看它们是否同意将这个主服务器已经进入主观下线状态。</p> <p>j). 当sentinel收集到足够多的主观下线投票之后，它会将主服务器判断为客观下线，并发起一次针对主服务器的故障转移操作。</p> <h2 id="集群"><a href="#集群" class="header-anchor">#</a> 集群</h2> <p>redis集群是redis提供的分布式数据库方案，集群通过分片来进行数据共享，并提供复制和故障转移功能。</p> <p>主要介绍集群的节点，槽指派，命令执行，重新分片，转向，故障转移，消息等。</p> <h3 id="节点"><a href="#节点" class="header-anchor">#</a> 节点</h3> <p>一个Redis集群通常由多个节点组成，在刚开始的时候，每个节点都是相互独立的，它们都处于一个只包含自己的集群当中，要组建一个真正可工作的集群，我们必须将各个独立的节点连接起来，构成一个包含多个节点的集群。</p> <p>连接各个节点的工作可以使用CLUSTER MEET命令来完成，该命令的格式如下：</p> <div class="language- extra-class"><pre class="language-text"><code>CLUSTER MEET &lt;ip&gt;  &lt;port&gt;
</code></pre></div><p>像一个节点node发送CLUSTER MEET 命令，可以让node节点与ip和port所指定的节点进行握手(handshake), 当握手成功时，node节点就会将ip和port所指定的节点添加到node节点当前所有的集群中。</p> <ol><li>启动节点</li></ol> <p>一个节点就是一个运行在集群模式下的redis服务器，redis服务器在启动时会根据cluster-enabled配置选项是否为yes来决定是否开启服务器的集群模式。</p> <p>节点(运行在集群模式下的redis服务器)会继续使用所有在单机模式中使用的服务器组件，比如：</p> <p>a). 节点会继续使用文件事件处理器来处理命令请求和返回命令回复。</p> <p>b). 节点会继续使用时间事件处理器来执行serverCron函数，而serverCron函数又会调用集群模式特有的clusterCron函数。clusterCron函数负责执行在集群模式下需要执行的常规操作，例如向集群中的其他节点发送Gossip消息，检查节点是否断线，或者检查是否需要对下线节点进行自动故障转移。</p> <p>c). 节点会继续使用数据库来保存键值对数据，键值对依然会是各种不同类型的对象</p> <p>d). 节点会继续使用RDB持久化模块和AOF持久化模块来执行持久化工作。</p> <p>e). 节点会继续使用发布与订阅模块来执行PUBLISH, SUBSCRIBE等命令。</p> <p>f). 节点会继续使用复制模块来进行节点的复制工作。</p> <p>g). 节点会继续使用Lua脚本环境来执行客户端输入的Lua脚本</p> <p>除此之外，节点会继续使用redisServer结构来保存服务器的状态，至于那些只有在集群模式下才会用到的数据，节点将它们保存到了cluster.h/clusterNode结构，cluster.h/clusterLink结构，以及cluster.h/clusterState结构里面，接下来的一节将对这三种数据结构进行介绍。</p> <ol start="2"><li>集群数据结构</li></ol> <p>clusterNode结构保存了一个节点的当前状态，比如节点的创建时间，节点的名字，节点当前的配置纪元，节点的IP地址和端口号等等。</p> <p>每个节点都会使用一个clusterNode结构来记录自己的状态，并为集群中的所有节点(包括主节点和从节点)都创建一个相应的clusterNode结构，以此来记录其他节点的状态：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">clusterNode</span> <span class="token punctuation">{</span>
  <span class="token comment">// 创建节点的时间</span>
  mstime_t ctime<span class="token punctuation">;</span>
  <span class="token comment">// 节点的名字，由40个十六进制符组成</span>
  <span class="token keyword">char</span> name<span class="token punctuation">[</span>REDIS_CLUSTER_NAMELEN<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token comment">// 节点标识</span>
  <span class="token comment">// 使用各种不同的标识值记录节点的角色</span>
  <span class="token comment">// 以及节点目前所处于的状态</span>
  <span class="token keyword">int</span> flags<span class="token punctuation">;</span>
  <span class="token comment">// 节点当前的配置纪元，用于实现故障转移</span>
  <span class="token keyword">uint64_t</span> configEpoch<span class="token punctuation">;</span>
  <span class="token comment">// 节点的IP地址</span>
  <span class="token keyword">char</span> ip<span class="token punctuation">[</span>REDIS_IP_STR_LEN<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token comment">// 节点的端口号</span>
  <span class="token keyword">int</span> port<span class="token punctuation">;</span>
  <span class="token comment">// 保存连接节点所需的有关信息</span>
  clusterLink <span class="token operator">*</span>link<span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>clusterNode结构的link属性是一个clusterLink结构，该结构保存了连接节点所需的有关信息，比如套接字描述符，输入缓冲区和输出缓冲区。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">clusterLink</span> <span class="token punctuation">{</span>
  <span class="token comment">// 连接的创建时间</span>
  mstime_t ctime<span class="token punctuation">;</span>
  <span class="token comment">// TCP套接字描述符</span>
  <span class="token keyword">int</span> fd<span class="token punctuation">;</span>
  <span class="token comment">// 输出缓冲区，保存着等待发送给其他节点的消息</span>
  sds sndbuf<span class="token punctuation">;</span>
  <span class="token comment">// 输入缓冲区，保存着从节点接收到的消息</span>
  sds rcvbuf<span class="token punctuation">;</span>
  <span class="token comment">// 与这个连接相关联的节点，如果没有的话就为null</span>
  <span class="token keyword">struct</span> <span class="token class-name">clusterNode</span> <span class="token operator">*</span>node<span class="token punctuation">;</span>
<span class="token punctuation">}</span> clusterLink<span class="token punctuation">;</span>
</code></pre></div><p>redisClient结构和clusterLink结构的相同和不同之处</p> <p>都有自己的套接字描述符和输入，输出缓冲区。区别在于，redisClient结构中的套接字和缓冲区是用于连接客户端的，而clusterLink结构中的套接字和缓冲区则是用于连接节点的。</p> <p>最后，每个节点都保存着一个clusterState结构，这个结构记录了在当前节点的视角下，集群目前所处的状态，例如集群是在线还是下线，集群包含多少个节点，集群当前的配置纪元：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">clusterState</span> <span class="token punctuation">{</span>
  <span class="token comment">// 指向当前节点的指针</span>
  clusterNode <span class="token operator">*</span>myself<span class="token punctuation">;</span>
  <span class="token comment">// 集群当前的配置纪元，用于实现故障转移</span>
  <span class="token keyword">uint64_t</span> curretnEpoch<span class="token punctuation">;</span>
  <span class="token comment">// 集群当前的状态，是在线还是下线</span>
  <span class="token keyword">int</span> state<span class="token punctuation">;</span>
  <span class="token comment">// 集群中至少处理着一个槽的节点的数量</span>
  <span class="token keyword">int</span> size<span class="token punctuation">;</span>
  <span class="token comment">// 集群节点名单(包括myself节点)</span>
  <span class="token comment">// 字典的键为节点的名字，字典的值为节点对应的clusterNode结构</span>
  dict <span class="token operator">*</span>nodes<span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span> clusterState<span class="token punctuation">;</span>
</code></pre></div><ol start="3"><li>CLUSTER MEET 命令的实现</li></ol> <p>通过向节点A发送CLUSTER METT命令，客户端可以让接收命令的节点A将另一个节点B添加到节点A当前所在的集群里面：</p> <div class="language- extra-class"><pre class="language-text"><code>CLUSTER MEET &lt;ip&gt; &lt;port&gt;
</code></pre></div><p>收到命令的节点A将与节点B进行握手(handshake),以此来确认彼此的存在，并为将来的进一步通信打好基础。</p> <p>a). 节点A会为节点B创建一个clusterNode结构，并将该节点添加到自己的clusterState.nodes字典里面。</p> <p>b). 之后，节点A将根据CLUSTER MEET命令给定的IP地址和端口号，向节点B发送一条MEET消息(message).</p> <p>c). 如果一切顺利，节点B将接收到节点A发送的MEET消息，节点B会为节点A创建一个clusterNode结构，并将结构添加到自己的clusterState.nodes字典里面。</p> <p>d). 之后，节点B将向节点A返回一条PONG消息。</p> <p>e). 如果一切顺利，节点A将接收到节点B返回的PONG消息，通过这条PONG消息节点A可以知道节点B已经成功地接收到了自己发送地MEET消息。</p> <p>f). 之后，节点A将向节点B返回一条PING消息。</p> <p>g). 如果一切顺利，节点B将接收到节点A返回地PING消息，通过这条PING消息节点B可以知道节点A已经成功地接收到了自己返回地PONG消息，握手完成。</p> <p>之后节点将会节点B地信息通过Gossip协议传播给集群中地其他节点，让其他节点也与节点B进行握手，最终，经过一段时间之后，节点B会被集群中地所有节点认识。</p> <h3 id="槽指派"><a href="#槽指派" class="header-anchor">#</a> 槽指派</h3> <p>redis集群通过分片的方式来保存数据库中的键值对：集群的整个数据库被分为16384个槽(slot), 数据库中的每个键都属于这16384个槽的其中一个，集群中的每个节点可以处理0个或最多16384个槽。</p> <p>当数据库中的16384个槽都有节点在处理时，集群处于上线状态(ok);相反地，如果数据库中有任何一个槽没有得到处理，那么集群处于下线状态(fail);</p> <p>上一节，使用CLUSTER MEET 命令将7000，7001，7002三个节点连接到同一个集群，不过这个集群目前仍然处于下线状态，因为集群中地三个都没有在处理任何槽。</p> <p>通过向节点发送CLUSTER ADDSLOTS命令，我们可以将一个或多个槽指派给节点负责：</p> <div class="language- extra-class"><pre class="language-text"><code>CLUSTER ADDSLOTS &lt;slot&gt; [slot]

如：
CLUSTER ADDSLOTS 0 1 2 3 4 5 6 7 8 9 ... 5000
</code></pre></div><ol><li>记录节点地槽指派信息</li></ol> <p>clusterNode结构地slot属性和numslot属性记录了节点负责处理哪些槽</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">clusterNode</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">char</span> slots<span class="token punctuation">[</span><span class="token number">16384</span><span class="token operator">/</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span> numslot<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>slot属性是一个二进制位数组(bit array), 这个数组地长度位2048个字节，共包含16384个二进制位。</p> <p>redis以0为起始索引，16383为终止索引，对slots数组的16384个二进制进行编号，并根据索引i上的二进制位的值来判断节点是否负责处理槽i:</p> <p>a) 如果slots数组在索引i上的二进制位的值为1，那么表示节点负责处理槽i</p> <p>b) 如果slots数组在索引i上的二进制位为0，那么表示节点不负责处理槽i</p> <p>numslot属性记录节点处理的槽的数量，也即是slots数组中值为1的二进制位的数量。</p> <ol start="2"><li>传播节点的槽指派信息</li></ol> <p>一个节点除了会将自己负责处理的槽记录在clusterNode结构的slots属性和numslots属性之外，它还会将自己的slots数组通过消息发送给集群中的其他节点，以此来告诉其他节点自己目前负责处理哪些槽。</p> <ol start="3"><li>记录集群所有槽的指派信息</li></ol> <p>clusterState结构中的slots数组记录了集群中所有16384个槽的指派信息：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">clusterState</span> <span class="token punctuation">{</span>
  <span class="token comment">// ....</span>
  clusterNode <span class="token operator">*</span>slots<span class="token punctuation">[</span><span class="token number">16384</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token comment">// ....</span>
<span class="token punctuation">}</span> clusterState<span class="token punctuation">;</span>
</code></pre></div><p>slots数组包含16384个项，每个数组项都是一个指向clusterNode结构的指针：</p> <p>a). 如果slots[i]指针指向NULL, 那么表示槽i尚未指派给任何节点。</p> <p>b). 如果slots[i]指针指向一个clusterNode结构，那么表示槽i已经指派给了clusterNode结构所代表的节点。</p> <p>减少了复杂度，可以通过这个知道slot指向哪个节点。</p> <p>使用ClusterNode结构的slots数组来记录单个节点的槽指派信息仍然是有必要的,可以减少查询的一些复杂度。</p> <p>clusterState.slots数组记录了集群中所有槽的指派信息，而clusterNode.slots数组只记录了clusterNode结构所代表的节点的槽指派信息。</p> <ol start="4"><li>CLUSTER ADDSLOTS命令的实现</li></ol> <p>CLUSTER ADDSLOTS命令接受一个或多个槽作为参数，并将所有输入的槽指派给接收该命令的节点负责：</p> <div class="language- extra-class"><pre class="language-text"><code>CLSUTER ADDSLOTS &lt;slot&gt; [slot ...]
</code></pre></div><p>代码实现伪代码</p> <div class="language-py extra-class"><pre class="language-py"><code><span class="token keyword">def</span> <span class="token function">CLSUTER_ADDSLOTS</span><span class="token punctuation">(</span><span class="token operator">*</span>all_input_slots<span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token comment"># 遍历所有输入槽，检查它们是否都是未指派槽</span>
  <span class="token keyword">for</span> i <span class="token keyword">in</span> all_input_slots<span class="token punctuation">:</span>
    <span class="token comment"># 如果有哪怕一个槽已经被指派给了某个节点</span>
    <span class="token comment"># 那么向客户端返回错误，并终止命令执行</span>
    <span class="token keyword">if</span> clusterState<span class="token punctuation">.</span>slots<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> NULL<span class="token punctuation">:</span>
      reply_error<span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token keyword">return</span>
  <span class="token comment"># 如果所有的槽都是未指派</span>
  <span class="token comment"># 那么再次遍历所有输入槽，将这些槽指派给当前节点</span>
  <span class="token keyword">for</span> i <span class="token keyword">in</span> all_input_slots<span class="token punctuation">:</span>
    <span class="token comment"># 设置clusterState结构的slots数组</span>
    <span class="token comment"># 将slots[i]的指针指向代表当前节点的clusterNode结构</span>
    clusterState<span class="token punctuation">.</span>slots<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> clusterState<span class="token punctuation">.</span>myself
    <span class="token comment"># 访问代表当前节点的clusterNode节点slots数组</span>
    <span class="token comment"># 将数组在索引i上的二进制位设置为1</span>
    setSlotBit<span class="token punctuation">(</span>clusterState<span class="token punctuation">.</span>myself<span class="token punctuation">.</span>slot<span class="token punctuation">,</span> i<span class="token punctuation">)</span>
</code></pre></div><h3 id="在集群中执行命令"><a href="#在集群中执行命令" class="header-anchor">#</a> 在集群中执行命令</h3> <p>当客户端向节点发送与数据库键有关的命令时，接收命令的节点会计算出命令要处理的数据库键属于哪个槽，并检查这个槽是否指派给自己</p> <p>a). 如果键所在的槽正好就指派给了当前节点，那么节点直接执行这个命令。</p> <p>b). 如果键所在的槽并没有指派给当前节点，那么节点会像客户端返回一个MOVED错误，指引客户端转向(redirect)至正确的节点，并再次发送之前想要执行的命令。</p> <ol><li>计算键属于哪个槽</li></ol> <p>节点使用算法来计算给定key属于哪个槽</p> <div class="language-py extra-class"><pre class="language-py"><code><span class="token keyword">def</span> <span class="token function">slot_number</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token keyword">return</span> CRC16<span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">16383</span>
</code></pre></div><p>其中CRC16(key)语句用于计算键key的CRC-16校验和，而&amp;16383语句则用于计算出一个介于0-16383之间的整数作为键key的槽号。</p> <p>可以使用CLUSTER KEYSLOT <key> 命令查看一个给定的键属于哪个槽。</key></p> <div class="language-py extra-class"><pre class="language-py"><code><span class="token keyword">def</span> <span class="token function">CLUSTER_KEYSLOT</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token comment"># 计算槽号</span>
  slot <span class="token operator">=</span> slot_number<span class="token punctuation">(</span>key<span class="token punctuation">)</span>
  <span class="token comment"># 将槽号返回给客户端</span>
  reply_client<span class="token punctuation">(</span>slot<span class="token punctuation">)</span>
</code></pre></div><ol start="2"><li>判断槽是否由当前节点负责处理</li></ol> <p>当节点计算出键所属的槽i之后，节点就会检查自己在clusterState.slots数组中的项i，判断键所在的槽是否由自己负责：</p> <p>a). 如果clusterState.slots[i]等于clusterState.myself, 那么说明槽i由当前节点负责，节点可以执行客户端发送的命令。</p> <p>b). 如果clusterState.slots[i]不等于clusterState.myself, 那么说明槽i并由当前节点负责，节点会根据clusterState.slots[i]指向的clusterNode结构所记录的节点IP和端口号，项客户端返回MOVED错误，指引客户端转向正在处理槽i的节点。</p> <ol start="3"><li>MOVED错误</li></ol> <p>当节点发现键所在的槽并非由自己负责处理的时候，节点就会向客户端返回一个MOVED错误，指引客户端转向至正在负责槽的节点。</p> <p>MOVED错误的格式为：</p> <div class="language- extra-class"><pre class="language-text"><code>MOVED &lt;slot&gt; &lt;ip&gt;:&lt;port&gt;
</code></pre></div><p>表示槽由另一个redis节点负责。</p> <p>如果客户端尚未与想要转向的节点创建套接字连接，那么客户端会先根据MOVED错误提供的IP地址和端口号来连接节点，然后再进行转向。</p> <p>被隐藏的MOVED错误</p> <p>集群模式的redis-cli客户端再接收到MOVED错误时，并不会打印出MOVED错误，而是根据MOVED错误自动进行节点转向，并打印出转向信息，所以我们是看不见节点返回的MOVED错误的。</p> <p>只有使用单机模式的客户端才会打印MOVED错误信息。</p> <p>这是因为单机模式的redis-cli客户端不清楚MOVED错误的作用，所以它只会直接将MOVED错误直接打印出来，而不会进行自动转向。</p> <ol start="4"><li>节点数据库的实现</li></ol> <p>集群节点保存键值对以及键值对过期时间的方式与单机redis服务器保存键值对以及键值对过期时间的方式完全相同。</p> <p>节点和单机服务器再数据库方面的一个区别是，节点只能使用0号数据库，而单机redis服务器则没有这一限制。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">clusterState</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  zskiplist <span class="token operator">*</span>slots_to_keys<span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span> clusterState<span class="token punctuation">;</span>
</code></pre></div><p>slots_to_keys跳跃表每个节点的分值(score)都是一个槽号，而每个节点的成员(member)都是一个数据库键：</p> <p>a). 每当节点往数据库中添加一个新的键值对时，节点就会将这个键以及键的槽号关联到slots_to_keys跳跃表。</p> <p>b). 当节点删除数据库中的某个键值对时，节点就会在slots_to_keys跳跃表解除被键与槽号的关联。</p> <p>通过在slots_to_keys跳跃表中记录各个数据库键所属的槽，节点可以很方便地对属于某个或某些槽地所有数据库键进行批量操作。例如命令 CLUSTER GETKEYSINSLOT <count>命令可以返回最多count个属于槽slot地数据库键，而这个命令就是通过遍历slots_to_keys跳跃表来实现的。</count></p> <h3 id="重新分片"><a href="#重新分片" class="header-anchor">#</a> 重新分片</h3> <p>redis集群的重新分片操作可以将任意数量已经指派给某个节点(源节点)的槽改为指派给另一个节点(目标节点)，并且相关槽所属的键值对也会从源节点被移动到目标节点。</p> <p>重新分片操作可以在线进行，在重新分片的过程中，集群不需要下线，并且源节点和目标节点都可以继续处理命令请求。</p> <p>重新分片的实现原理：</p> <p>Redis集群的重新分片操作是由redis的集群管理软件redis-trib负责执行的，Redis提供了进行重新分片所需的所有命令，而redis-trib则通过向源节点和目标节点发送命令来进行重新分片操作。</p> <p>redis-trib对集群的单个槽slot进行重新分片的步骤如下：</p> <p>a). redis-trib对目标节点发送CLUSTER SETSLOT  IMPORTING &lt;source_id&gt; 命令，让目标节点准备好从源节点导入(import)属于槽slot的键值对</p> <p>b). redis-trib对源节点发送CLUSTER SETSLOT  MIGRATING &lt;target_id&gt;命令，让源节点准备好将槽slot的键值对迁移(migrate)至目标节点。</p> <p>c). redis-trib向源节点发送CLUSTER GETKEYSINSLOT <count>命令，获得最多count个属于槽slot的键值对的键名。</count></p> <p>d). 对于步骤3获得的每个键名，redis-trib都向源节点发送一个MIGRATE &lt;target_ip&gt; &lt;target_port&gt; &lt;key_name&gt; 0 <timeout>命令，将被选中的键原子地从源节点迁移至目标节点。</timeout></p> <p>e). 重复执行步骤3和步骤4，直到源节点保存的所有槽slot的键值对都被迁移至目标节点为止。</p> <p>f). redis-trib向集群中的任意一个节点发送CLUSTER SETSLOT  NODE &lt;target_id&gt;命令，将槽slot指派给目标节点，这一指派信息会通过信息发送至整个集群，最终集群中的所有节点都会知道槽slot已经指派给了目标节点。</p> <h3 id="ask错误"><a href="#ask错误" class="header-anchor">#</a> ASK错误</h3> <p>在进行重新分片期间，源节点向目标节点迁移一个槽的过程中，可能会出现一个情况：属于被迁移槽的一部分键值对保存在源节点里面，而另一部分键值对则保存在目标节点里面。</p> <p>当客户端向源节点发送一个与数据库键有关的命令，并且命令要处理的数据库键恰好就属于正在被迁移的槽时：</p> <p>a). 源节点会先在自己的数据库里面查找指定的键，如果找到的话，就直接执行客户端发送的命令。</p> <p>b). 相反的，如果源节点没能在自己的数据库里面找到指定的键，那么这个键有可能已经被迁移到了目标节点，源节点将向客户端返回一个ASK错误，指引客户端转向正在导入槽的目标节点，并再次发送之前想要执行的命令。</p> <ol><li>CLUSTER SETSLOT IMPORTING 命令的实现</li></ol> <p>clusterState结构的importing_slots_from数组记录了当前节点正在从其他节点导入的槽：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">clusterState</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  clusterNode <span class="token operator">*</span>importing_slots_from<span class="token punctuation">[</span><span class="token number">16384</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span> clusterState<span class="token punctuation">;</span>
</code></pre></div><p>如果importing_slots_from[i]的值不为NULL, 而是指向一个clusterNode结构，那么表示当前节点正在从clusterNode所代表的节点导入槽i。</p> <p>在对集群进行重新分片的时候，向目标节点发送命令：</p> <div class="language- extra-class"><pre class="language-text"><code>CLUSTER  SETSLOT &lt;i&gt; IMPORTING &lt;source_id&gt;
</code></pre></div><p>可以将目标节点clusterState.importing_slot_from[i]的值设置未source_id所代表节点的clusterNode结构。</p> <ol start="2"><li>CLUSTER SETSLOT MIGRATING 命令的实现</li></ol> <p>clusterState结构的migrating_slots_to数组记录了当前节点正在迁移至其他节点的槽：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">clusterState</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  clusterNode <span class="token operator">*</span>migrating_slots_to<span class="token punctuation">[</span><span class="token number">16384</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span> clusterState<span class="token punctuation">;</span>
</code></pre></div><p>如果migrating_slots_to[i]的值不为NULL, 而是指向一个clusterNode结构，那么表示当前节点正在将槽i迁移至clusterNode所代表的节点。</p> <p>在对集群进行重新分片的时候，向源节点发送命令：</p> <div class="language- extra-class"><pre class="language-text"><code>CLUSTER SETSLOT &lt;i&gt; MIGRATING &lt;target_id&gt;
</code></pre></div><p>可以将源节点clusterState.migrating_slots_to[i]的值设置为target_id所代表节点的clusterNode结构。</p> <ol start="3"><li>ASK错误</li></ol> <p>如果节点收到一个关于键key的命令请求，并且键key所属的槽i正好就指派给了这个节点，那么节点会尝试在自己的数据库里查找键key，如果找到了的话，节点就直接执行客户端发送的命令。</p> <p>与此相反，如果节点没有在自己的数据库里找到键key，那么节点会检查自己的clusterState.migrating_slots_to[i], 查键key所属的槽i是否正在进行迁移，如果槽i的确在进行迁移的话，那么节点会向客户端发送一个ASK错误，引导客户端到正在导入槽i的节点去查找键key。</p> <ol start="4"><li>ASKING命令</li></ol> <p>ASKING命令唯一要做的就是打开发送该命令的客户端的REDIS_ASKING标识，以下时该命令的伪代码实现：</p> <div class="language-py extra-class"><pre class="language-py"><code><span class="token keyword">def</span> <span class="token function">ASKING</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token comment"># 打开标识</span>
  client<span class="token punctuation">.</span>flags <span class="token operator">|</span><span class="token operator">=</span> REDIS_ASKING
  <span class="token comment"># 向客户端返回OK回复</span>
  reply<span class="token punctuation">(</span><span class="token string">&quot;OK&quot;</span><span class="token punctuation">)</span>
</code></pre></div><ol start="5"><li>ASK错误和MOVED错误的区别</li></ol> <p>ASK错误和MOVED错误都会导致客户端转向，它们的区别在于：</p> <p>a). MOVED错误代表槽的负责权已经从一个节点转移到了另一个节点：在客户端收到关于槽i的MOVED错误之后，客户端每次遇到关于槽i的命令请求时，都可以直接将命令请求发送至MOVED错误所指向的节点，因为该节点就是目前负责槽i的节点。</p> <p>b). 相反，ASK错误只是两个节点在迁移槽的过程中使用的一种临时措施：在客户端收到关于槽i的ASK错误之后，客户端只会在接下来的一次命令请求中将关于槽i的命令请求发送至ASK错误所指示的节点，但这种转向不会对客户端今后发送关于槽i的命令请求产生任何影响，客户端仍然会将关于槽i的命令请求发送至目前负责处理槽i的节点，除非ASK错误再次出现。</p> <h2 id="复制与故障转移"><a href="#复制与故障转移" class="header-anchor">#</a> 复制与故障转移</h2> <p>Redis集群中的节点分为主节点和从节点，其中主节点用于处理槽，而从节点则用于复制某个主节点，并在被复制某个主节点，并在被复制的主节点下线时，代替下线主节点继续处理命令请求。</p> <ol><li>设置从节点</li></ol> <p>向一个节点发送命令</p> <div class="language- extra-class"><pre class="language-text"><code>CLUSTER REPLICATE &lt;node_id&gt;
</code></pre></div><p>可以让接收命令的节点成为node_id所指定节点的从节点，并开始对主节点进行复制：</p> <p>a). 接收到该命令的节点首先会在自己的clusterState.nodes字典中找到node_id所对应节点的clusterNode结构，并将自己的clusterState.myself.slaveof指针指向这个结构，以此来记录这个节点正在复制的主节点：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">clusterNode</span> <span class="token punctuation">{</span>
  <span class="token comment">//.. </span>
  <span class="token comment">// 如果这是一个从节点，那么指向主节点</span>
  <span class="token keyword">struct</span> <span class="token class-name">clusterNode</span> <span class="token operator">*</span>slaveof<span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>b). 然后节点会修改自己在clusterState.myself.flags中的属性，关闭原本的REDIS_NODE_MASTER标识，打开REDIS_NODE_SLAVE标识，表示这个节点已经由原来的主节点变成了从节点。</p> <p>c). 最后，节点会调用复制代码，并根据clusterState.myself.slaveof指向的clusterNode结构所保存的IP地址和端口号，对主节点进行复制。因为节点的复制功能和单机Redis服务器的复制功能使用了相同的代码，所以让从节点复制主节点相当于从节点发送命令SLAVEOF.</p> <p>一个节点成为从节点，并开始复制某个主节点这一信息会通过消息发送给集群中的其他节点，最终集群中的所有节点都会知道某个从节点正在复制某个主节点。</p> <p>集群中的所有节点都会代表主节点的clusterNode结构的slaves属性和numslaves属性中记录正在复制这个主节点和从节点名单：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">clusterNode</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  <span class="token comment">// 正在复制这个主节点的从节点数量</span>
  <span class="token keyword">int</span> numslaves<span class="token punctuation">;</span>
  <span class="token comment">// 一个数组</span>
  <span class="token comment">// 每个数组项指向一个正在复制这个主节点的从节点的clusterNode结构</span>
  <span class="token keyword">struct</span> <span class="token class-name">clusterNode</span> <span class="token operator">*</span><span class="token operator">*</span>slaves<span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><ol start="2"><li>故障检测</li></ol> <p>集群中的每个节点都会定期地向集群中的其他节点发送PING命令，以此来检测对方是否在线，如果接收PING消息的节点没有在规定的时间内，向发送PING消息的节点返回PONG消息，那么发送PING消息的节点就会将接收PING消息的节点标记为疑似下线。</p> <p>当一个主节点A通过消息得知主节点B认为主节点C进入疑似下线状态时，主节点A会在自己的clusterState.nodes字典中找到主节点C所对应的clusterNode结构，并将主节点B的小仙报告添加到clusterNode结构的fail_reports链表里面：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">clusterNode</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  <span class="token comment">// 一个链表，记录了所有其他节点对该节点的下线报告</span>
  list <span class="token operator">*</span>fail_reports<span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>每个下线报告由一个clusterNodeFailReport结构表示：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">clusterNodeFailReport</span> <span class="token punctuation">{</span>
  <span class="token comment">// 报告目标节点已经下线的节点</span>
  <span class="token keyword">struct</span> <span class="token class-name">clusterNode</span> <span class="token operator">*</span>node<span class="token punctuation">;</span>
  <span class="token comment">// 最后一次从node节点收到下线报告的时间</span>
  <span class="token comment">// 程序使用这个时间戳来检查下线报告是否过期</span>
  mstime_t time<span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">typedef</span> clusterNodeFailReport<span class="token punctuation">;</span>
</code></pre></div><ol start="3"><li>故障转移</li></ol> <p>当一个节点发现自己正在复制的主节点进入了已下线状态时，从节点将开始对下线主节点进行故障转移，以下是故障转移的执行步骤：</p> <p>a). 复制下线主节点的所有从节点里面，会有一个从节点被选中。</p> <p>b). 被选中的从节点会执行SLAVEOF no one命令，成为新的主节点。</p> <p>c). 新的主节点会撤销所有对已下线主节点的槽指派，并将这些槽全部指派给自己。</p> <p>d). 新的主节点向集群广播一条PONG消息，这条PONG消息可以让集群中的其他节点立即知道这个节点已经由从节点变成了主节点，并且这个主节点已经接管了原本由已下线节点负责处理的槽。</p> <p>e). 新的主节点开始接收和自己负责处理的槽有关的命令请求，故障转移完成。</p> <ol start="4"><li>选举新的主节点</li></ol> <p>新的主节点是通过选举产生的。</p> <p>a). 集群的配置纪元是一个自增计数器，它的初始值为0</p> <p>b). 当集群里的某个节点开始一次故障转移操作时，集群配置纪元的值会被增一。</p> <p>c). 对于每个配置纪元，集群里每个负责处理槽的主节点都有一次投票的机会，而一个向主节点要求投票的从节点将获得主节点的投票</p> <p>d). 当从节点发现自己正在复制的主节点进行已下线状态时，从节点会向集群广播一条CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST消息，要求所有收到这条消息，并且具有投票权的主节点向这个从节点投票。</p> <p>e). 如果一个主节点具有投票权(它正在复制处理槽)，并且这个主节点尚未投票给其他从节点，那么主节点将向要求投票的从节点返回一条CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK消息，表示这个主节点支持从节点成为新的主节点。</p> <p>f). 每个参与选举的从节点都会接收CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK消息，并根据自己收到了多少条这种消息来统计自己获得了多少主节点的支持。</p> <p>g). 如果集群里有N个具有投票权的主节点，那么当一个从节点收集到大于等于N/2 + 1张支持票时，这个从节点就会当选为新的主节点。</p> <p>h). 因为在每一个配置纪元里面，每个具有投票的主节点之只能投一次票，所以如果有N个主节点进行投票，那么具有大于等于N/2+1张支持票的从节点只会有一个，确保了新的主节点只会有一个。</p> <p>i). 如果在一个配置纪元里面没有从节点能收集到足够多的支持票，那么集群进入一个新的配置纪元，并再次进行选举，直到选出新的主节点为止。</p> <h3 id="消息"><a href="#消息" class="header-anchor">#</a> 消息</h3> <p>集群中的每个节点通过发送和接收消息(message)来进行通信，我们称发送消息的节点为发送者(sender),接收消息的节点为接收者(receiver).</p> <p>节点发送的消息主要有以下五种：</p> <p>a). MEET消息：当发送者接到客户端发送的CLUSTER MEET命令时，发送者会向接收者发送MEET消息，请求接收者加入到发送者当前所处的集群里面。</p> <p>b). PING消息：集群里的每个节点默认每隔一秒钟就会从已知节点列表中随机选出五个节点，然后对这个节点中最长时间没有发送给PING消息的节点发送PING消息，以此来检测被选中的节点是否在线。除此之外，如果节点A最后以此收到节点B发送的PONG消息的时间，距离当前时间已经超过了节点A的cluster-node-timeout选项设置时长的一半，那么节点A也会向节点B发送PING消息，这可以防止节点A因为长时间没有随机选中节点B作为PING消息的发送对象而导致节点B的信息更新滞后。</p> <p>c). PONG消息：当接收者收到发送者发来的MEET消息或者PING消息时，为了向发送者确认这条MEET消息或者PING消息已到达，接收者向发送者返回一条PONG消息，另外，一个节点也可以通过向集群广播自己的PONG消息来集群中的其他节点立即刷新关于这个节点认识，例如当以此故障转移操作成功执行之后，新的主节点会向集群广播一条PONG消息，以此来让集群中的其他节点立即直到这个节点已经变成了主节点，并且接管了已下线节点负责的槽。</p> <p>d). FAIL消息：当一个主节点A判断另一个主节点B已经进入FAIL状态时，节点A会向集群广播一条关于节点B的FAIL消息，所以收到这条消息的节点都会立即将节点B标记为已下线。</p> <p>e). PUBLISH消息：当节点接收到一个PUBLISH命令时，节点会执行这个命令，并向集群广播一条PUBLISH消息，所有接收到这条PUBLISH消息的节点都会执行相同的PUBLISH命令。</p> <p>一条消息由消息头(header)和消息正文(data)组成，接下来的内容将首先介绍消息头，然后再分别介绍上面提到的五种不同类型的消息正文。</p> <ol><li>消息头</li></ol> <p>节点发送的所有消息都有一个消息头包裹，消息头除了包含消息正文之外，还记录了消息发送者自身正文之外，还记录了消息发送者自身的一些信息，因为这些信息也会被消息接收者用到，所以严格来讲，我们可以认为消息头本身也是消息的一部分。</p> <p>每隔消息头都由一个cluster.h/clusterMsg结构表示：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>
  <span class="token comment">// 消息的长度(包括这个消息头的长度和消息正文的长度)</span>
  <span class="token keyword">uint32_t</span> totlen<span class="token punctuation">;</span>
  <span class="token comment">// 消息的类型</span>
  <span class="token keyword">uint16_t</span> type<span class="token punctuation">;</span>
  <span class="token comment">// 消息正文包含的节点信息数量</span>
  <span class="token comment">// 只在发送MEET, PING, PONG三个Gossip协议消息时使用</span>
  <span class="token keyword">uint16_t</span> count<span class="token punctuation">;</span>
  <span class="token comment">// 发送者所处的配置纪元</span>
  <span class="token keyword">uint64_t</span> currentEpoch<span class="token punctuation">;</span>
  <span class="token comment">// 如果发送者是一个主节点，那么这里记录的是发送者的配置纪元</span>
  <span class="token comment">// 如果发送者是一个从节点，那么这里记录的是发送者正在复制的主节点的配置纪元</span>
  <span class="token keyword">uint64_t</span> configEpoch<span class="token punctuation">;</span>
  <span class="token comment">// 发送者的名字(ID)</span>
  <span class="token keyword">char</span> sender<span class="token punctuation">[</span>REDIS_CLUSTER_NAMELEN<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token comment">// 发送者目前的槽指派信息</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">char</span> myslots<span class="token punctuation">[</span>REDIS_CLUSTER_CLOSTS<span class="token operator">/</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token comment">// 如果发送者是一个从节点，那么这里记录的是发送者正在复制的主节点的名字</span>
  <span class="token comment">// 如果发送者是一个主节点，那么这里记录的是REDIS_NODE_NULL_NAME</span>
  <span class="token comment">// (一个40字节长，值全为0的字节数组)</span>
  <span class="token keyword">char</span> slaveof<span class="token punctuation">[</span>REDIS_CLUSTER_NAMELEN<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token comment">// 发送者的端口号</span>
  <span class="token keyword">uint16_t</span> port<span class="token punctuation">;</span>
  <span class="token comment">// 发送者的标识值</span>
  <span class="token keyword">uint16_t</span> flags<span class="token punctuation">;</span>
  <span class="token comment">// 发送者所处集群的状态</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">char</span> state<span class="token punctuation">;</span>
  <span class="token comment">// 消息的正文</span>
  <span class="token keyword">union</span> clusterMsgData data<span class="token punctuation">;</span>
<span class="token punctuation">}</span> clusterMsg<span class="token punctuation">;</span>
</code></pre></div><p>clusterMsg.data属性指向联合cluster.h/clusterMsgData，这个联合就是消息的正文：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">union</span> clusterMsgData <span class="token punctuation">{</span>
  <span class="token comment">// MEET, PING, PONG消息的正文</span>
  <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    <span class="token comment">// 每条MEET, PING, PONG消息都包含两个</span>
    <span class="token comment">// clusterMsgDataGossip结构</span>
    clusterMsgDataGossip gossip<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> ping<span class="token punctuation">;</span>
  <span class="token comment">// FAIL消息的正文</span>
  <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    clusterMsgDataFail about<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> fail<span class="token punctuation">;</span>
  <span class="token comment">// PUBLISH消息的正文</span>
  <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    clusterMsgDataPublish msg<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> publish<span class="token punctuation">;</span>
  <span class="token comment">// 其他消息的正文...</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><ol start="2"><li>MEET, PING, PONG 消息的实现</li></ol> <p>REDIS集群中的各个节点通过Gossip协议来交换各自关于不同节点的状态信息，其中Gossip协议由MEET,PING,PONG三种消息实现，这三种消息的正文都由两个cluster.h/clusterMsgDataGossip结构组成：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">union</span> clusterMsgData <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  <span class="token comment">// MEET, PING和PONG消息的正文</span>
  <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    <span class="token comment">// 每条MEET， PING, PONG消息都包含两个</span>
    <span class="token comment">// clusterMsgDataGossip结构</span>
    clusterMsgDataGossip gossip<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>ping<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>因为MEET, PING, PONG三种消息都使用相同的消息正文，所以节点通过消息头的type属性来判断一条消息是MEET消息，PING消息还是PONG消息。</p> <p>每次发送MEET, PING, PONG消息时，发送者都从自己的已知节点列表中随机选出两个节点(可以是主节点或者从节点)，并将这两个被选中节点的信息分别保存到两个clusterMsgDataGossip结构里面。</p> <p>clusterMsgDataGossip结构记录了被选中节点的名字；发送者与被选中节点最后一次发送和接收PING消息和PONG消息的时间戳，被选中节点的IP地址和端口号，以及被选中节点的标识值：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>
  <span class="token comment">// 节点的名字</span>
  <span class="token keyword">char</span> nodename<span class="token punctuation">[</span>REDIS_CLUSTER_NAMELEN<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token comment">// 最后一次向节点发送PINGX消息的时间戳</span>
  <span class="token keyword">uint32_t</span> ping_sent<span class="token punctuation">;</span>
  <span class="token comment">// 最后一次从该节点接收到PONG消息的时间戳</span>
  <span class="token keyword">uint32_t</span> pong_received<span class="token punctuation">;</span>
  <span class="token comment">// 节点的IP地址</span>
  <span class="token keyword">char</span> ip<span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token comment">// 节点的端口号</span>
  <span class="token keyword">uint16_t</span> port<span class="token punctuation">;</span>
  <span class="token comment">// 节点的标识值</span>
  <span class="token keyword">uint16_t</span> flags<span class="token punctuation">;</span>
<span class="token punctuation">}</span> clusterMsgDataGossip<span class="token punctuation">;</span>
</code></pre></div><p>当接收者收到MEET, PING, PONG消息时，接收者会访问消息正文中的两个clusterMsgDataGossip结构，并根据自己是否认识clusterMsgDataGossoip结构中记录的被选中节点来选择进行哪种操作：</p> <p>a). 如果被选中节点不存在接收者的已知节点列表，那么说明接收者是第一次接触到被选中节点，接收者将根据结构中记录的IP地址和端口号信息，与被选中节点进行握手。</p> <p>b). 如果被选中节点已经存在于接收者的已知节点列表，那么说明接收者之前已经被选中节点进行过接触，接收者将根据clusterMsgDataGossip结构记录的信息，对被选中节点所对应的clusterNode结构进行更新。</p> <ol start="3"><li>FAIL消息的实现</li></ol> <p>当集群里的主节点A将主节点B标记为已下线(FAIL)时，主节点A将向集群广播一条关于主节点B的FAIL消息，所有接收到这条FAIL消息的节点都会将主节点B标记为已下线。</p> <p>FAIL消息的正文由cluster.h/clusterMsgDataFail结构表示，这个结构只包含一个nodename属性，该属性记录了已下线节点的名字：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>
  <span class="token keyword">char</span> nodename<span class="token punctuation">[</span>REDIS_CLUSTER_NAMELEN<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> clusterMsgDataFail<span class="token punctuation">;</span>
</code></pre></div><ol start="4"><li>PUBLISH消息的实现</li></ol> <p>当客户端向集群中的某个节点发送命令：</p> <div class="language- extra-class"><pre class="language-text"><code>PUBLISH &lt;channel&gt; &lt;message&gt;
</code></pre></div><p>的时候，接收到PUBLISH命令的节点不仅会向channel频道发送消息message，它还会向集群广播一条PUBLISH消息，所有接收到这条PUBLISH消息的节点都会向channel频道发送message消息。</p> <p>换句话说，向集群中的某个节点发送命令：</p> <div class="language- extra-class"><pre class="language-text"><code>PUBLISH &lt;channel&gt; &lt;message&gt;
</code></pre></div><p>将导致集群中的所有节点都向channel频道发送message消息。</p> <p>PUBLISH消息的正文由cluster.h/clusterMsgDataPublish结构表示：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>
  <span class="token keyword">uint32_t</span> channel_len<span class="token punctuation">;</span>
  <span class="token keyword">uint32_t</span> message_len<span class="token punctuation">;</span>
  <span class="token comment">// 定义为8字节只是为了对其其他消息结构</span>
  <span class="token comment">// 实际的长度由保存的内容决定</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">char</span> bulk_data<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> clusterMsgDataPublish<span class="token punctuation">;</span>
</code></pre></div><p>clusterMsgDataPublish结构的bulk_data属性时一个字节数组，这个字节数组保存了客户端通过PUBLISH命令发送给节点的channel参数和message参数，而结构的channel_len和message_len则分别保存了channel参数的长度和message参数的长度：</p> <p>a). 其中bulk_data的0字节至channel_len-1字节保存的是channel参数。</p> <p>b). 而bulk_data的channel_len字节至channel_len + message_len - 1 字节保存的则是message参数。</p> <p>为什么不直接向节点广播PUBLISH命令</p> <p>实际上，要让集群的所有节点都执行相同的PUBLISH命令，最简单的方法就是向所有节点广播相同的PUBLISH命令，这也是redis再复制PUBLISH命令时所使用的方法，不过因为这种做法并不符合redis集群的&quot;各个节点通过发送和接收消息来进行通信&quot;这一规则，所以节点没有采取广播PUBLISH命令的做法。</p> <h3 id="重点回顾-6"><a href="#重点回顾-6" class="header-anchor">#</a> 重点回顾</h3> <p>a). 节点通过握手来将其他节点添加到自己所处的集群当中。</p> <p>b). 集群中的16384个槽可以分别指派给集群中的各个节点，每个节点都会记录哪些槽指派给了自己，而那些槽又被指派给了其他节点。</p> <p>c). 节点再接到了一个命令请求时，会先检查这个命令请求要处理的键所在的槽是否由自己负责，如果不是的话，节点将向客户端返回一个MOVED错误，MOVED错误携带的信息可以指引客户端转向至正在负责相关槽的节点。</p> <p>d). 对Redis集群的重新分片工作是由redis-trib负责执行的，重新分片的关键是将属于某个槽的所有键值对从一个节点转移至另一个节点。</p> <p>e). 如果节点A正在迁移槽i至节点B，那么当节点A没能在自己的数据库中找到命令指定的数据库键时，节点A会向客户端返回一个ASK错误，指引客户端到节点B继续查找指定的数据库键。</p> <p>f). MOVED错误表示槽的负责权已经从一个节点转移到了另一个节点，而ASK错误只是两个节点在迁移槽的过程中使用的一种临时措施。</p> <p>g). 集群里的从节点用于复制主节点，并在主节点下线时，代替主节点继续处理命令请求。</p> <p>h). 集群中的节点通过发送和接收消息来进行通信，常见的消息包括MEET, PING, PONG, PUBLISH, FAIL五种。</p> <h2 id="发布与订阅"><a href="#发布与订阅" class="header-anchor">#</a> 发布与订阅</h2> <p>Redis的发布与订阅功能由PUBLISH, SUBSCRIBE, PSUBSCRIBE等命令组成。</p> <p>通过执行SUBSRIBE命令，客户端可以订阅一个或多个频道，从而成为这些频道的订阅者(subscriber): 每当有其他客户端向被订阅的频道发送消息(message)时，频道的所有订阅者都会收到这条消息。</p> <p>订阅：</p> <div class="language- extra-class"><pre class="language-text"><code>SUBSCRIBE &quot;news.it&quot;
</code></pre></div><p>向订阅发送命令</p> <div class="language- extra-class"><pre class="language-text"><code>PUBLISH &quot;news.it&quot; &quot;hello&quot;
</code></pre></div><p>那么订阅&quot;news.it&quot;的客户端都会收到hello</p> <p>除了订阅频道之外，客户端还可以通过执行PSUBSCRIBE命令订阅一个或多个模式，从而成为这些模式的订阅者：每当有其他客户端向某个频道发送消息时，消息不仅会被发送给这个频道的所有订阅者，他还会被发送给所有与这个频道相匹配的模式的订阅者。</p> <h3 id="频道的订阅与退订"><a href="#频道的订阅与退订" class="header-anchor">#</a> 频道的订阅与退订</h3> <p>当一个客户端执行SUBSCRIBE命令订阅某个或某些频道的时候，这个客户端与被订阅频道之间就建立起了一种订阅关系。</p> <p>Redis将所有频道的订阅关系都保存在服务器状态的pubsub_channels字典里面，这个字典的键是某个被订阅的频道，而键的值则是一个链表，链表里面记录了所有订阅这个频道的客户端：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">redisServer</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  <span class="token comment">// 保存所有频道的订阅关系</span>
  dict <span class="token operator">*</span>pubsub_channels<span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><ol><li>订阅频道</li></ol> <p>每当客户端执行SUBSCRIBE命令订阅某个或某些频道的时候，服务器都会将客户端与订阅的频道在pubsub_channnels字典中进行关联。</p> <p>根据频道是否已经有其他订阅者，关联操作分为两种情况执行：</p> <p>a). 如果频道已经有其他订阅者，那么它在pubsub_channels字典中必然有相应的订阅者链表，程序唯一要做的就是将客户端添加到订阅者链表的末尾。</p> <p>b). 如果频道还未有任何订阅者，那么它必然不存在于pubsub_channels字典，程序首先要在pubsub_channels字典中为频道创建一个键，并将这个键的值设置为空链表，然后再将客户端添加到链表，成为链表的第一个元素。</p> <p>SUBSCRIBE命令的实现可以用以下伪代码来描述</p> <div class="language-py extra-class"><pre class="language-py"><code><span class="token keyword">def</span> <span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token operator">*</span>all_input_channels<span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token comment"># 遍历输入的所有频道</span>
  <span class="token keyword">for</span> channel <span class="token keyword">in</span> all_input_channels<span class="token punctuation">:</span>
    <span class="token comment"># 如果channel不存在于pubsub_channels字典(没有任何订阅者)</span>
    <span class="token comment"># 那么在字典中添加channel键，并设置它的值伪空链表</span>
    <span class="token keyword">if</span> channel <span class="token keyword">not</span> <span class="token keyword">in</span> server<span class="token punctuation">.</span>pubsub_channels<span class="token punctuation">:</span>
      server<span class="token punctuation">.</span>pubsub_channels<span class="token punctuation">[</span>channel<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    server<span class="token punctuation">.</span>pubsub_channels<span class="token punctuation">[</span>channel<span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>client<span class="token punctuation">)</span>
</code></pre></div><ol start="2"><li>退订频道</li></ol> <p>UNSUBSCRIBE命令的行为和SUBSCRIBE命令的行为正好相反，当一个客户端退订某个或某些频道的时候，服务器将从pubsub_channels中解除客户端与被退订频道之间的关联：</p> <p>a). 程序会根据被退订频道的名字，在pubsub_channels字典中找到频道对应的订阅者链表，然后从订阅者链表中删除退订客户端的信息。</p> <p>b). 如果删除退订客户端之后，频道的订阅者链表变成了空链表，那么说明这个频道已经没有任何订阅者了，程序将从pubsub_channels字典中删除频道对应的键。</p> <p>UNSUBSCRIBE命令的实现：</p> <div class="language-py extra-class"><pre class="language-py"><code><span class="token keyword">def</span> <span class="token function">unsubscribe</span><span class="token punctuation">(</span><span class="token operator">*</span>all_input_channels<span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token comment"># 遍历要退订的所有频道</span>
  <span class="token keyword">for</span> channel <span class="token keyword">in</span> all_input_channels<span class="token punctuation">:</span>
    <span class="token comment"># 在订阅者链表中删除退订的客户端</span>
    server<span class="token punctuation">.</span>pubsub_channels<span class="token punctuation">[</span>channel<span class="token punctuation">]</span><span class="token punctuation">.</span>remove<span class="token punctuation">(</span>client<span class="token punctuation">)</span>
    <span class="token comment"># 如果频道已经没有任何订阅者 (订阅者链表为空)</span>
    <span class="token comment"># 那么将频道从字典中删除</span>
    <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>pubsub_channels<span class="token punctuation">[</span>channel<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>
      server<span class="token punctuation">.</span>pubsub_channels<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>channel<span class="token punctuation">)</span>
</code></pre></div><h3 id="模式的订阅与退订"><a href="#模式的订阅与退订" class="header-anchor">#</a> 模式的订阅与退订</h3> <p>前面说过，服务器将所有频道的订阅关系都保存在服务器状态的pubsub_channels属性里面，与此类似，服务器也将所有模式的订阅关系都保存在服务器状态的pubsub_patterns属性里面：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">redisServer</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  <span class="token comment">// 保存所有模式订阅关系</span>
  list <span class="token operator">*</span>pubsub_patterns<span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>pubsub_patterns属性是一个链表，链表中的每个节点都包含这一个pubsub Pattern结构，这个结构的pattern属性记录了被订阅的模式，而client属性则记录了订阅模式的客户端：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">pubsubPattern</span> <span class="token punctuation">{</span>
  <span class="token comment">// 订阅模式的客户端</span>
  redisClient <span class="token operator">*</span>client<span class="token punctuation">;</span>
  <span class="token comment">// 被订阅的模式</span>
  robj <span class="token operator">*</span>pattern<span class="token punctuation">;</span>
<span class="token punctuation">}</span> pubsubPattern<span class="token punctuation">;</span>
</code></pre></div><ol><li>订阅模式</li></ol> <p>每当客户端执行PSUBSCRIBE命令订阅某个或某些模式的时候，服务器会对每个被订阅的模式执行以下两个操作：</p> <p>a). 新建一个pubsubPattern结构，将结构的pattern属性设置伪被订阅的模式，client属性设置伪订阅模式的客户端。</p> <p>b). 将pubsubPattern结构添加到pubsub_patterns链表的表尾。</p> <p>PSUBSCRIBE命令的实现原理可以用以下伪代码：</p> <div class="language-py extra-class"><pre class="language-py"><code><span class="token keyword">def</span> <span class="token function">psubscribe</span><span class="token punctuation">(</span><span class="token operator">*</span>all_input_patterns<span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token comment"># 遍历输入的所有模式</span>
  <span class="token keyword">for</span> pattern <span class="token keyword">in</span> all_input_patterns<span class="token punctuation">:</span>
    <span class="token comment"># 创建新的pubsubPattern结构</span>
    <span class="token comment"># 记录被订阅的模式，以及订阅模式的客户端</span>
    pubsubPattern <span class="token operator">=</span> create_new_pubsubPattern<span class="token punctuation">(</span><span class="token punctuation">)</span>
    pubsubPattern<span class="token punctuation">.</span>client <span class="token operator">=</span> client
    pubsubPattern<span class="token punctuation">.</span>pattern <span class="token operator">=</span> pattern
    <span class="token comment"># 将新的pubsubPattern追加到pubsub_patterns链表末尾</span>
    server<span class="token punctuation">.</span>pubsub_patterns<span class="token punctuation">.</span>append<span class="token punctuation">(</span>pubsubPattern<span class="token punctuation">)</span>
</code></pre></div><ol start="2"><li>退订模式</li></ol> <p>模式的退订模式命令PUNSUBSCRIBE是PSUBSCRIBE命令的反操作：当一个客户端退订某个或某些模式的时候，服务器将在pubsub_patterns链表中查找并删除那些pattern属性为被退订模式，并且client属性为执行退订命令的客户端的pubsubPattern结构。</p> <div class="language-py extra-class"><pre class="language-py"><code><span class="token keyword">def</span> <span class="token function">punsubscribe</span><span class="token punctuation">(</span><span class="token operator">*</span>all_input_patterns<span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token comment"># 遍历所有要退订的模式</span>
  <span class="token keyword">for</span> pattern <span class="token keyword">in</span> all_input_patterns<span class="token punctuation">:</span>
    <span class="token comment"># 遍历pubsub_patterns链表中的所有pubsubPattern结构</span>
    <span class="token keyword">for</span> pubsubPattern <span class="token keyword">in</span> server<span class="token punctuation">.</span>pubsub_patterns<span class="token punctuation">:</span>
      <span class="token comment"># 如果当前客户端和pubsubPattern记录的客户端相同</span>
      <span class="token comment"># 并且要退订的模式也和pubsubPattern记录的模式相同</span>
      <span class="token keyword">if</span> client <span class="token operator">==</span> pubsubPattern<span class="token punctuation">.</span>client <span class="token keyword">and</span> pattern <span class="token operator">==</span> pubsubPattern<span class="token punctuation">.</span>pattern<span class="token punctuation">:</span>
        <span class="token comment"># 将这个pubsubPattern从链表中删除</span>
        server<span class="token punctuation">.</span>pubsub_patterns<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>pubsubPattern<span class="token punctuation">)</span>
</code></pre></div><h3 id="发送消息"><a href="#发送消息" class="header-anchor">#</a> 发送消息</h3> <p>当一个Redis客户端执行PUBLISH <channel><message> 命令将消息message发送给频道channel的时候，服务器需要执行以下两个动作：</message></channel></p> <p>a). 将消息message发送给channel频道的所有订阅者。</p> <p>b). 如果有一个或多个模式pattern与频道channel相匹配，那么将消息message发送给pattern模式的订阅者。</p> <ol><li>将消息发送给频道订阅者</li></ol> <p>因为服务器状态中的pubsub_channels字典记录了所有频道的订阅关系，所以为了将消息发送给channel频道的所有订阅者，PUBLISH命令要做的就是在pubsub_channels字典里找到频道channel的订阅者名单(一个链表)，然后将消息发送给名单上的所有客户端。</p> <p>PUBLISH命令将消息发送给频道订阅者的方法可以用以下伪代码：</p> <div class="language-py extra-class"><pre class="language-py"><code><span class="token keyword">def</span> <span class="token function">channel_publish</span><span class="token punctuation">(</span>channel<span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token comment"># 如果channel键不存在于pubsub_channels字典中</span>
  <span class="token comment"># 那么说明channel频道没有任何订阅者</span>
  <span class="token comment"># 程序不做发送动作，直接返回</span>
  <span class="token keyword">if</span> channel <span class="token keyword">not</span> <span class="token keyword">in</span> server<span class="token punctuation">.</span>pubsub_channels<span class="token punctuation">:</span>
    <span class="token keyword">return</span>
  <span class="token comment"># 运行到这里，说明channel频道至少有一个订阅者</span>
  <span class="token comment"># 程序遍历channel频道的订阅者链表</span>
  <span class="token comment"># 将消息发送给所有订阅者</span>
  <span class="token keyword">for</span> subscriber <span class="token keyword">in</span> server<span class="token punctuation">.</span>pubsub_channels<span class="token punctuation">[</span>channel<span class="token punctuation">]</span><span class="token punctuation">:</span>
    send_message<span class="token punctuation">(</span>subscriber<span class="token punctuation">,</span> message<span class="token punctuation">)</span>
</code></pre></div><ol start="2"><li>将消息发送给模式订阅者</li></ol> <p>因为服务器状态中的pubsub_patterns链表记录了所有模式的订阅关系，所以为了将消息发送给所有与channel频道相匹配的模式的订阅者，PUBLISH命令要做的就是遍历整个pubsub_patterns链表，查找那些与channel频道相匹配的模式，并将消息发送给订阅了这些模式的客户端。</p> <p>PUBLISH命令将消息发送给模式订阅者的方法可以用以下伪代码：</p> <div class="language-py extra-class"><pre class="language-py"><code><span class="token keyword">def</span> <span class="token function">pattern_publish</span><span class="token punctuation">(</span>channel<span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token comment">#遍历所有模式订阅消息</span>
  <span class="token keyword">for</span> pubsubPattern <span class="token keyword">in</span> server<span class="token punctuation">.</span>pubsub_patterns<span class="token punctuation">:</span>
    <span class="token comment"># 如果频道和模式相匹配</span>
    <span class="token keyword">if</span> match<span class="token punctuation">(</span>channel<span class="token punctuation">,</span> pubsubPattern<span class="token punctuation">.</span>pattern<span class="token punctuation">)</span><span class="token punctuation">:</span>
      <span class="token comment"># 那么将消息发送给订阅该模式的客户端</span>
      send_message<span class="token punctuation">(</span>pubsubPattern<span class="token punctuation">.</span>clien<span class="token punctuation">,</span> message<span class="token punctuation">)</span>
</code></pre></div><p>所以PUBLISH命令的实现可以用以下伪代码：</p> <div class="language-py extra-class"><pre class="language-py"><code><span class="token keyword">def</span> <span class="token function">publish</span><span class="token punctuation">(</span>channel<span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token comment"># 将消息发送给channel频道的所有订阅者</span>
  channel_publish<span class="token punctuation">(</span>channel<span class="token punctuation">,</span> message<span class="token punctuation">)</span>
  <span class="token comment"># 将消息发送给所有和channel频道相匹配的模式的订阅者</span>
  pattern_publish<span class="token punctuation">(</span>channel<span class="token punctuation">,</span> message<span class="token punctuation">)</span>
</code></pre></div><h3 id="查看订阅信息"><a href="#查看订阅信息" class="header-anchor">#</a> 查看订阅信息</h3> <p>客户端可以通过这个命令来查看频道或者模式的相关信息，比如某个频道目前有多少订阅者，又或者某个模式目前有多少订阅者。</p> <ol><li>PUBSUB CHANNELS</li></ol> <p>PUBSUB CHANNELS[pattern]子命令用于返回服务器当前被订阅的频道，其中pattern参数是可选的：</p> <p>a). 如果不给定pattern参数，那么命令返回服务器当前被订阅的所有频道。</p> <p>b). 如果给定pattern参数，那么命令返回服务器当前被订阅的频道中那些与pattern模式相匹配的频道。</p> <p>这个子命令是通过遍历服务器pubsub_channels字典的所有键(每个键都是一个被订阅的频道)，然后记录并返回所有符合条件的频道来实现的。</p> <div class="language-py extra-class"><pre class="language-py"><code><span class="token keyword">def</span> <span class="token function">pubsub_channles</span><span class="token punctuation">(</span>pattern<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token comment"># 一个列表，用于记录所有符合条件的频道</span>
  channel_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token comment"># 遍历服务器中的所有频道</span>
  <span class="token comment"># (也即是pubsub_channels字典的所有键)</span>
  <span class="token keyword">for</span> channel <span class="token keyword">in</span> server<span class="token punctuation">.</span>pubsub_channels<span class="token punctuation">:</span>
    <span class="token comment"># 当以下两个条件的任意一个满足时，将频道添加到链表里面：</span>
    <span class="token comment"># 1. 用户没有指定pattern参数</span>
    <span class="token comment"># 2. 用户指定了pattern参数，并且channel和pattern匹配</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>pattern <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">)</span> <span class="token keyword">or</span> match<span class="token punctuation">(</span>channel<span class="token punctuation">,</span> pattern<span class="token punctuation">)</span><span class="token punctuation">:</span>
      channel_list_append<span class="token punctuation">(</span>channel<span class="token punctuation">)</span>
  <span class="token comment"># 相客户端返回频道列表</span>
  <span class="token keyword">return</span> channel_list
</code></pre></div><ol start="2"><li>PUBSUB NUMSUB</li></ol> <p>PUBSUB NUMSUB[channel-1 channel-2...channel-n]子命令接受任意多个频道作为输入参数，并返回这些频道的订阅者数量。</p> <p>这个子命令是通过在pubsub_channels字典中找到频道对应的订阅者链表，然后返回订阅者链表的长度来实现的(订阅者链表的长度就是频道订阅者的数量)。</p> <div class="language-py extra-class"><pre class="language-py"><code><span class="token keyword">def</span> <span class="token function">pubsub_numsub</span><span class="token punctuation">(</span><span class="token operator">*</span>all_input_channels<span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token comment"># 遍历输入的所有频道</span>
  <span class="token keyword">for</span> channel <span class="token keyword">in</span> all_input_channels<span class="token punctuation">:</span>
    <span class="token comment"># 如果pubsub_channles字典中没有channel这个键</span>
    <span class="token comment"># 那么说明channel频道没有任何订阅者</span>
    <span class="token keyword">if</span> channel <span class="token keyword">not</span> <span class="token keyword">in</span> server<span class="token punctuation">.</span>pubsub_channels<span class="token punctuation">:</span>
      <span class="token comment"># 返回频道名</span>
      reply_channel_name<span class="token punctuation">(</span>channel<span class="token punctuation">)</span>
      <span class="token comment"># 订阅者数量为0</span>
      reply_subscribe_count<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token comment"># 如果pubsub_channels字典中存在channel键</span>
    <span class="token comment"># 那么说明channel频道至少有一个订阅者</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
      <span class="token comment"># 返回频道名</span>
      reply_channel_name<span class="token punctuation">(</span>channel<span class="token punctuation">)</span>
      <span class="token comment"># 订阅者链表的长度就是订阅者数量</span>
      reply_subscribe_count<span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>pubsub_channels<span class="token punctuation">[</span>channel<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><ol start="3"><li>PUBSUB NUMPAT</li></ol> <p>PUBSUB NUMPAT子命令用于返回服务器当前被订阅模式的数量。</p> <p>这个子命令是通过返回pubsub_patterns链表的长度来实现的，因为这个链表的长度就是服务器被订阅模式的数量，这个过程可以用以下伪代码：</p> <div class="language-py extra-class"><pre class="language-py"><code><span class="token keyword">def</span> <span class="token function">pubsub_numpat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token comment"># pubsub_patterns链表的长度就是被订阅模式的数量</span>
  reply_pattern_count<span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>pubsub_patterns<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="重点回顾-7"><a href="#重点回顾-7" class="header-anchor">#</a> 重点回顾</h3> <p>a). 服务器状态在pubsub_channels字典保存了所有频道的订阅关系：SUBSCRIBE命令复制将客户端和被订阅的频道关联到这个字典里面，而UNSUBSCRIBE命令则负责解除客户端和被退订频道之间的关联。</p> <p>b). 服务器状态在pubsub_patterns链表保存了所有模式的订阅关系：PSUBSCRIBE命令负责将客户端和被订阅的模式记录到这个链表中，而PUNSUBSCRIBE命令则负责移除客户端和被退订模式在链表中的记录。</p> <p>c). PUBLISH命令通过访问pubsub_channels字典来向频道的所有订阅者发送消息，通过访问pubsub_patterns链表来向所有匹配频道的模式的订阅者发送消息。</p> <p>d). PUBSUB命令的三个子命令都是通过读取pubsub_channels字典和pubsub_patterns链表中的信息来实现的。</p> <h2 id="事务"><a href="#事务" class="header-anchor">#</a> 事务</h2> <p>Redis通过MULTI, EXEC, WATCH等命令来实现事务(transaction)功能。事务提供了一种将多个命令的机制，并且在事务执行期间，服务器不会中断事务而改去执行其他客户端的命令请求，它会将事务中的所有命令都执行完毕，然后才会去处理其他客户端的命令请求。</p> <p>以下是一个事务执行的过程，该事务首先以一个MULTI命令为开始，接着将多个命令放入事务当中，最后由EXEC命令将这个事务提交(commit)给服务器执行.</p> <div class="language-sh extra-class"><pre class="language-sh"><code>redis<span class="token operator">&gt;</span> MULI
OK
redis<span class="token operator">&gt;</span> SET <span class="token string">&quot;name&quot;</span> <span class="token string">&quot;Practical Common Lisp&quot;</span>
QUEUED
redis<span class="token operator">&gt;</span> GET <span class="token string">&quot;name&quot;</span>
QUEUED
redis<span class="token operator">&gt;</span> SET <span class="token string">&quot;author&quot;</span> <span class="token string">&quot;Prter Seibel&quot;</span>
QUEUED
redis<span class="token operator">&gt;</span> GET <span class="token string">&quot;author&quot;</span>
QUEUED
redis<span class="token operator">&gt;</span> EXEC
<span class="token number">1</span><span class="token punctuation">)</span> OK
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;Practical Common Lisp&quot;</span>
<span class="token number">3</span><span class="token punctuation">)</span> OK
<span class="token number">4</span><span class="token punctuation">)</span> <span class="token string">&quot;Prter Seibel&quot;</span>
</code></pre></div><h3 id="事务的实现"><a href="#事务的实现" class="header-anchor">#</a> 事务的实现</h3> <p>一个事务从开始到结束通常会经历以下三个阶段：</p> <ol><li><p>事务开始</p></li> <li><p>命令入队</p></li> <li><p>事务执行</p></li></ol> <ol><li>事务开始</li></ol> <p>MULTI命令的执行标志着事务的开始。</p> <p>MULTI命令可以将执行该命令的客户端从非事务状态切换至事务状态，这一切换是通过在客户端状态的flags属性中打开REDIS_MULTI标识来完成的，MULTI命令的实现可以用以下伪代码来表示：</p> <div class="language-py extra-class"><pre class="language-py"><code><span class="token keyword">def</span> <span class="token function">MULTI</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token comment"># 打开事务标识</span>
  client<span class="token punctuation">.</span>flag <span class="token operator">|</span><span class="token operator">=</span> REDIS_MULTI
  <span class="token comment"># 返回OK回复</span>
  replyOK<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><ol start="2"><li>命令入队</li></ol> <p>当一个客户端处于非事务状态时，这个客户端发送的命令会立即被服务器执行，与此不同的是，当一个客户端切换到事务状态之后，服务器会根据这个客户端发来的不同命令执行不同的操作：</p> <p>a). 如果客户端发送的命令为EXEC，DISCARD, WATCH, MULTI四个命令的其中一个，那么服务器立即执行这个命令。</p> <p>b). 与此相反，如果客户端发送的命令是EXEC, DISCARD, WATCH, MULTI四个命令以外的其他命令，那么服务器并不立即执行这个命令，而是将这个命令放入一个事务队列里面，然后向客户端返回QUEUED回复。</p> <ol start="3"><li>事务队列</li></ol> <p>每个Redis客户端都有自己的事务状态，这个事务状态保存在客户端状态的mstate属性里面：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">redisClient</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  <span class="token comment">// 事务状态</span>
  multiState mstate<span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span> redisClient<span class="token punctuation">;</span>
</code></pre></div><p>事务状态包含一个事务队列，以及一个已入队命令的计数器：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">multiState</span> <span class="token punctuation">{</span>
  <span class="token comment">// 事务队列，FIFO顺序</span>
  multiCmd <span class="token operator">*</span>commands<span class="token punctuation">;</span>
  <span class="token comment">// 已入队命令计数</span>
  <span class="token keyword">int</span> count<span class="token punctuation">;</span>
<span class="token punctuation">}</span> multiState<span class="token punctuation">;</span>
</code></pre></div><p>事务队列是一个multiCmd类型的数组，数组中的每个multiCmd结构都保存了一个已入队命令的相关信息，包含指向命令实现函数的指针，命令的参数，以及参数的数量：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">multiCmd</span> <span class="token punctuation">{</span>
  <span class="token comment">// 参数</span>
  robj <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">;</span>
  <span class="token comment">// 参数数量</span>
  <span class="token keyword">int</span> argc<span class="token punctuation">;</span>
  <span class="token comment">// 命令指针</span>
  <span class="token keyword">struct</span> <span class="token class-name">redisCommand</span> <span class="token operator">*</span>cmd<span class="token punctuation">;</span>
<span class="token punctuation">}</span> multiCmd<span class="token punctuation">;</span>
</code></pre></div><p>事务队列以先进先出(FIFO)的方式保存入队的命令，较先入队的命令会被放到数组的前面，而较后入队的命令则会被放到数组的后面。</p> <ol start="4"><li>执行事务</li></ol> <p>当一个处于事务状态的客户端向服务器发送EXEC命令时，这个EXEC命令将立即被服务器执行。服务器会遍历这个客户端的事务队列，执行队列中保存的所有命令，最后将执行命令所得到的结果全部返回给客户端。</p> <p>EXEX命令实现原理：</p> <div class="language-py extra-class"><pre class="language-py"><code><span class="token keyword">def</span> <span class="token function">EXEC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token comment"># 创建空白的回复队列</span>
  reply_queue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token comment"># 遍历事务队列中的每个项</span>
  <span class="token comment"># 读取命令的参数，参数的个数，以及要执行的命令</span>
  <span class="token keyword">for</span> argv<span class="token punctuation">,</span> argc<span class="token punctuation">,</span> cmd <span class="token keyword">in</span> client<span class="token punctuation">.</span>mstate<span class="token punctuation">.</span>commands<span class="token punctuation">:</span>
    <span class="token comment"># 执行命令，并取得命令的返回值</span>
    reply <span class="token operator">=</span> execute_command<span class="token punctuation">(</span>cmd<span class="token punctuation">,</span> argv<span class="token punctuation">,</span> argc<span class="token punctuation">)</span>
    <span class="token comment"># 将返回值追加到回复队列末尾</span>
    reply_queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>reply<span class="token punctuation">)</span>
  <span class="token comment"># 移除REDIS_MULTI标识，让客户端回到非事务状态</span>
  client<span class="token punctuation">.</span>flags <span class="token operator">&amp;</span><span class="token operator">=</span> <span class="token operator">~</span>REDIS_MULTI
  <span class="token comment"># 清空客户端的事务状态，包括：</span>
  <span class="token comment"># 1) 清零入队命令计数器</span>
  <span class="token comment"># 2) 释放事务队列</span>
  client<span class="token punctuation">.</span>mstate<span class="token punctuation">.</span>count <span class="token operator">=</span> <span class="token number">0</span>
  relese_transaction_queue<span class="token punctuation">(</span>client<span class="token punctuation">.</span>mstate<span class="token punctuation">.</span>commands<span class="token punctuation">)</span>
  <span class="token comment"># 将事务的执行结果返回给客户端</span>
  send_reply_to_client<span class="token punctuation">(</span>client<span class="token punctuation">,</span> reply_queue<span class="token punctuation">)</span>
</code></pre></div><h3 id="watch命令的实现"><a href="#watch命令的实现" class="header-anchor">#</a> WATCH命令的实现</h3> <p>WATCH命令是一个乐观锁(optimisticlocking), 它可以在EXEC命令执行之前，监视任意数量的数据库键，并在EXEC命令执行时，检查被监视的键是否至少有一个已经被修改过了，如果是的话，服务器将拒绝执行事务，并向客户端返回代表事务执行失败的空回复。</p> <ol><li>使用WATCH命令监视数据库键</li></ol> <p>每个Redis数据库都保存着一个warched_keys字典，这个字典的键是某个被WATCH命令监视的数据库键，而字典的值则是一个链表，链表中记录了所有监视相应数据库键的客户端。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">redisDb</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  <span class="token comment">// 正在被WATCH命令监视的键</span>
  dict <span class="token operator">*</span>watched_keys<span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span> redisDb<span class="token punctuation">;</span>
</code></pre></div><p>通过watched_keys字典，服务器可以清楚地知道哪些数据库键正在被监视，以及哪些客户端正在监视这些数据库键。</p> <ol start="2"><li>监视机制的触发</li></ol> <p>所有对数据库进行修改的命令，比如SET, LPUSH, SADD, ZREM, DEL, FLUSHDB等等，在执行之后都会调用multi.c/touchWatchKey函数对watched_keys字典进行检查，查看是否有客户端正在监视刚刚被命令修改过的数据库键，如果有的话，那么touchWatchKey函数会将监视被修改键的客户端的REDIS_DIRTY_CAS标识打开，表示该客户端的事务安全性已经被破坏。</p> <p>touchWatchKey函数伪代码：</p> <div class="language-py extra-class"><pre class="language-py"><code><span class="token keyword">def</span> <span class="token function">touchWatchKey</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token comment"># 如果键key存在于数据库的watched_keys字典中</span>
  <span class="token comment"># 那么说明至少有一个客户端在监视这个key</span>
  <span class="token keyword">if</span> key <span class="token keyword">in</span> db<span class="token punctuation">.</span>watched_keys<span class="token punctuation">:</span>
    <span class="token comment"># 遍历所有监视键key的客户端</span>
    <span class="token keyword">for</span> client <span class="token keyword">in</span> db<span class="token punctuation">.</span>watched_keys<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">:</span>
      <span class="token comment"># 打开标识</span>
      client<span class="token punctuation">.</span>flags <span class="token operator">|</span><span class="token operator">=</span> REDIS_DIRTY_CAS
</code></pre></div><ol start="3"><li>判断事务是否安全</li></ol> <p>当服务器接收到一个客户端发来的EXEC命令时，服务器会根据这个客户端是否打开了REDIS_DIRTY_CAS标识来决定是否执行事务：</p> <p>a). 如果客户端的REDIS_DIRTY_CAS标识已经被打开，那么说明客户端所监视的键当中，至少有一个键已经被修改过了，在这种情况下，客户端提交的事务已经不再安全，所有服务器会拒绝执行客户端提交的事务。</p> <p>b). 如果客户端的REDIS_DIRTY_CAS标识没有被打开，那么说明客户端监视的所有键都没有被修改过(或者客户端没有监视任何键)，事务仍然是安全的，服务器将执行客户端提交的这个事务。</p> <ol start="4"><li>一个完整的WATCH事务执行过程</li></ol> <p>为了进一步熟悉WATCH命令的运作方式，WATCH的事务从开始到失败的整个过程。</p> <table><thead><tr><th style="text-align:center;">事务A</th> <th style="text-align:center;">事务B</th></tr></thead> <tbody><tr><td style="text-align:center;">WATCH &quot;name&quot;</td> <td style="text-align:center;"></td></tr> <tr><td style="text-align:center;">MULTI</td> <td style="text-align:center;"></td></tr> <tr><td style="text-align:center;">SET &quot;name&quot; &quot;peter&quot;</td> <td style="text-align:center;"></td></tr> <tr><td style="text-align:center;"></td> <td style="text-align:center;">SET &quot;name&quot; &quot;john&quot;</td></tr> <tr><td style="text-align:center;">EXEC</td> <td style="text-align:center;"></td></tr></tbody></table> <p>执行EXEC会被服务器拒绝</p> <h2 id="事务的acid性质"><a href="#事务的acid性质" class="header-anchor">#</a> 事务的ACID性质</h2> <p>事务总是具有原子性(Atomicity), 一致性(Consistency) 和 隔离性(Isolation), 并且当redis运行在某种特定的持久化模式下时，事务也具有耐久性(Durability)</p> <ol><li>原子性</li></ol> <p>事务具有原子性指的是，数据库将事务中的多个操作当作一个整体来执行，服务器要么就执行事务中的所有操作，要么就一个操作也不执行。</p> <p>对于Redis的事务功能来说，事务队列中的命令要么全部执行，要么一个都不执行。</p> <p>Redis的事务和传统的关系型数据库事务的最大区别在于，Redis不支持事务回滚机制(rollback),即使事务队列中的某个命令在执行期间出现了错误，整个事务也会继续执行下去，直到将事务队列中的所有命令都执行完毕为止。</p> <ol start="2"><li>一致性</li></ol> <p>事务具有一致性指的是，如果数据库在执行事务之前是一致的，那么在事务执行之后，无论事务是否执行成功，数据库也应该仍然是一致的。</p> <p>&quot;一致&quot;指的是数据符合数据库本身的定义和要求，没有包含非法或者无效的错误数据。</p> <p>redis通常谨慎的错误检测和简单的设置来保证事务的一致性。</p> <p>a). 入队错误</p> <p>b). 执行错误</p> <p>c). 服务器停机</p> <ol start="3"><li>隔离性</li></ol> <p>事务的隔离性指的是，即使数据库中有多个事务并发地执行，各个事务之间也不会互相影响，并且在并发状态下执行地事务和串行执行地事务产生地结果完全相同。</p> <p>因为redis使用单线程地方式来执行事务，并且服务器保证，在执行事务期间不会对事务进行中断，所以，redis地事务总是以串行的方式运行的，并且事务也总是具有隔离性的。</p> <ol start="4"><li>耐久性</li></ol> <p>当一个事务执行完毕时，执行这个事务所得的结果已经被保存到永久性存储介质(比如硬盘)里面了，即使服务器在事务执行完毕之后停机。执行事务所得的结果也不会丢失。</p> <p>主要得看有没有开启RDB，AOF,没有则耐久性较差。</p> <h3 id="重点回顾-8"><a href="#重点回顾-8" class="header-anchor">#</a> 重点回顾</h3> <p>a). 事务提供了一种将多个命令打包，然后一次性，有序地执行地机制。</p> <p>b). 多个命令会被入队到事务队列中，然后按先进先出(FIFO)的顺序执行。</p> <p>c). 事务在执行过程中不会被中断，当事务队列中的所有命令都被执行完毕之后，事务才会结束。</p> <p>d). 带有WATCH命令的事务会将客户端和被监视的键在数据库的watched_keys字典中进行关联，当键被修改时，程序会将所有监视被修改键的客户端的REDIS_DIRTY_CAS标志打开。</p> <p>e). 只要在客户端的REDIS_DIRTY_CAS标志未被打开时，服务器才会执行客户端提交的事务，否则的话，服务器将拒绝执行客户端提交的事务。</p> <p>f). Redis的事务总是具有ACID中的原子性，一致性和隔离性，当服务器运行在AOF持久化模式下，并且appendfsync选项的值为always时，事务也具有耐久性。</p> <h2 id="lua脚本"><a href="#lua脚本" class="header-anchor">#</a> Lua脚本</h2> <p>redis从2.6版本开始引入对Lua脚本的支持，通过在服务器中嵌入Lua环境，Redis客户端可以使用Lua脚本，直接在服务器端原子地执行多个Redis命令。</p> <p>其中，使用EVAL命令可以直接对输入地脚本进行求值：</p> <div class="language- extra-class"><pre class="language-text"><code>redis&gt; EVAL &quot;return 'hello world'&quot; 0
&quot;hello world&quot;
</code></pre></div><p>而使用EVALSHA命令则可以根据脚本地SHA1校验和来对脚本进行求值，但这个命令要求校验和对应地脚本必须至少被EVAL命令执行过一次。</p> <h3 id="创建并修改lua环境"><a href="#创建并修改lua环境" class="header-anchor">#</a> 创建并修改Lua环境</h3> <p>为了在Redis服务器中执行Lua脚本，Redis在服务器内嵌了一个Lua环境(environment), 并对这个Lua环境进行了一系列修改，从而确保这个Lua环境可以满足Redis服务器地需要。</p> <p>Redis服务器创建并修改Lua环境地整个过程由以下步骤组成：</p> <p>a). 创建一个基础地Lua环境，之后的所有修改都是针对这个环境进行的。</p> <p>b). 载入多个函数库到Lua环境里面，让Lua脚本可以使用这个函数库来进行数据操作。</p> <p>c). 创建全局表格redis，这个表格包含了对Redis进行操作的函数，比如用于在Lua脚本中执行Redis命令的redis.cal函数。</p> <p>d). 使用Redis自制的随机函数来替换Lua原有的带有副作用的随机函数，从而避免在脚本中引入副作用。</p> <p>e). 创建排序辅助函数，Lua环境使用这个辅佐函数来对一部分Redis命令的结果进行排序，从而消除这些命令的不确定性。</p> <p>f). 创建redis.pcall函数的错误报告辅助函数，这个函数可以提供更详细的出错信息。</p> <p>g). 对Lua环境中全局环境进行保护，防止用户在执行Lua脚本的过程中，将额外的全局变量添加到Lua环境中。</p> <p>h). 将完成修改的Lua环境保存到服务器状态的lua属性中，等待执行服务器传来的Lua脚本。</p> <ol><li>创建Lua环境</li></ol> <p>服务器首先调用Lua的CAPI函数lua_open, 创建一个新的Lua环境。</p> <p>因为lua_open函数创建的只是一个基本的Lua环境，为了让这个Lua环境可以满足Redis的操作要求，接下来服务器将这个Lua环境进行一系列修改。</p> <ol start="2"><li>载入函数库</li></ol> <p>Redis修改Lua环境的第一步，就是将以下函数库载入到Lua环境里面：</p> <p>a). 基础库(base library): 这个库包含Lua的核心(core) 函数，比如assert, error, pairs, tostring, pcall等。另外，为了防止用户从外部文件中引入不安全的代码，库中的loadfile函数会被删除。</p> <p>b). 表格库(table library): 这个库包含用于处理表格的通用函数，比如table.concat, table.insert, table.remove, table.sort等。</p> <p>c). 字符串库(string library): 这个库包含用于处理字符串的通用函数，比如用于对字符串进行查找的string.find函数，对字符串进行格式化的string.format函数，查看字符串长度的string.len函数，对字符串进行翻转的string.reverse函数等。</p> <p>d). 数学库(math library): 这个库是标准C语言数据库的接口。</p> <p>e). 调试库(debug library): 这个库提供了对程序进行调试所需的函数。</p> <p>f). Lua CJSON 库: 这个库用于处理UTF-8编码的JSON格式，其中cjson.decode函数将一个JSON格式的字符串转换为一个Lua值，而cjson.encode函数将一个Lua值序列化为JSON格式的字符串。</p> <p>g). Struct 库： 这个库用于在Lua值和C结构(struct)之间进行转换，函数struct.pack将多个Lua值打包成一个类结构(struct-like)字符串，而函数struct.unpack则从一个类结构字符串中解包出多个Lua值。</p> <p>h). Lua cmsgpack 库: 这个库用于处理MessagePack格式的数据，其中cmsgpack.pack函数将Lua值转换为MessagePack数据，而cmsgpack.unpack函数则将MessagePack数据转换为Lua值。</p> <p>通过这些库，Lua脚本可以直接对执行Redis命令获得的数据进行复杂的操作。</p> <ol start="3"><li>创建redis全局表格</li></ol> <p>在Lua环境中创建一个redis表格(table), 并将它设为全局变量，这个redis表格包含以下函数：</p> <p>a). 用于执行Redis命令的redis.call 和 redis.pcall函数。</p> <p>b). 用于记录Redis日志的redis.log函数，以及相应的日志级别(level)常量：redis.LOG_DEBUG, redis.LOG_VERBOSE, redis.LOG_NOTICE, 以及 redis.LOG_WARNING.</p> <p>c). 用于计算SHA1校验和的redis.sha1hex函数。</p> <p>d). 用于返回错误信息的redis.error_reply函数和redis.status_reply函数。</p> <p>在这些函数里面，最常用也是最重要的为 redis.call 函数和 redis.pcall 函数。用户可以直接在Lua脚本中执行Redis命令：</p> <div class="language- extra-class"><pre class="language-text"><code>redis&gt; EVAL &quot;return redis.call('PING')&quot; 0
PONG
</code></pre></div><ol start="4"><li>使用Redis自制的随机函数来替换Lua原有的随机函数</li></ol> <p>为了保证相同的脚本可以在不同的机器上产生相同的结果，redis要求所有传入服务器的Lua脚本，以及Lua环境中的所有函数，都必须是无副作用(side effect)的纯函数(pure function).</p> <p>redis使用自制的函数替换math库中原有的math.random函数和math.randomseed函数，替换之后的两个函数有以下特征：</p> <p>a). 对于相同的seed来说，math.random总产生相同的随机数序列，这个函数是一个纯函数。</p> <p>b). 除非在脚本中使用math.randomseed显式地修改seed, 否则每次运行脚本时，Lua环境都使用固定的math.randomseed(0)语句来初始化seed。</p> <ol start="5"><li>创建排序辅助函数</li></ol> <p>SMEMBERS命令的输出会产生不同的结果。</p> <p>redis将SMEMBERS这种在相同数据集上可能会产生不同输出的命令称为&quot;带有不确定性的命令&quot;, 这些命令包括：</p> <p>a). SINTER</p> <p>b). SUNION</p> <p>c). SDIFF</p> <p>d). SMEMBERS</p> <p>e). HKEYS</p> <p>f). HVALS</p> <p>g). KEYS</p> <p>为了消除这些命令带来的不确定性，服务器会为Lua环境创建一个排序辅助函数 __redis__compare_helper, 当Lua脚本执行完一个带有不确定性的命令之后，程序会使用__redis__compare_helper作为对比函数，自动调用table.sort函数对命令的返回值做一次排序，以此来保证相同的数据集总是产生相同的输出。</p> <ol start="6"><li>创建redis.pcall函数的错误报告辅助函数</li></ol> <p>为Lua环境创建一个名为__redis__err__handler的错误处理函数，当脚本调用redis.pcall函数执行Redis命令，并且被执行的命令出现错误时，__redis__err__handler就会打印出错代码的来源和发生错误的行数，为程序的调试提供方便。</p> <ol start="7"><li>保护Lua的全局环境</li></ol> <p>服务器将对Lua环境中的全局环境进行保护，确保传入服务器的脚本不会因为忘记使用local关键字而将额外的全局变量添加到Lua环境里面。</p> <ol start="8"><li>将Lua环境保存到服务器状态的lua属性里面</li></ol> <p>经过以上的一系列修改，redis服务器对Lua环境的修改工作到此结束，最后，服务器会将Lua环境和服务器状态的lua属性关联起来。</p> <p>因为Redis使用串行化的方式来执行Redis命令，所以在任何特定时间里，最多都只会有一个脚本能够被放进Lua环境里面运行，因此，整个redis服务器只需要创建一个Lua环境即可。</p> <h3 id="lua环境协作组件"><a href="#lua环境协作组件" class="header-anchor">#</a> Lua环境协作组件</h3> <p>除了创建并修改Lua环境之外，Redis服务器还创建了两个用于与Lua环境进行协作的组件，它们分别是负责执行Lua脚本中的Redis命令的伪客户端，以及用于保存Lua脚本的lua_scripts字典</p> <ol><li>伪客户端</li></ol> <p>因为执行Redis命令必须有相应的客户端状态，所以为了执行Lua脚本中包含的Redis命令，Redis服务器专门为Lua环境创建了一个伪客户端，并由这个伪客户端负责处理Lua脚本包含的所有Redis命令。</p> <p>Lua脚本使用redis.call函数或者redis.pcall函数执行一个Redis命令，需要完成以下步骤：</p> <p>a). Lua环境将redis.call函数或者redis.pcall函数想要执行的命令传给伪客户端。</p> <p>b). 伪客户端将脚本想要执行的命令传给命令执行器</p> <p>c). 命令执行器执行伪客户端传给它的命令，并将命令的执行结果返回给伪客户端。</p> <p>d). 伪客户端接收命令执行器返回的命令结果，并将这个命令结果返回给Lua环境，</p> <p>e). Lua环境在接收到命令结果之后，将该结果返回给redis.call函数或者redis.pcall函数。</p> <p>f). 接收到结果的redis.call函数或者redis.pcall函数将命令结果作为函数返回值返回给脚本中的调用者。</p> <ol start="2"><li>lua_scripts字典</li></ol> <p>除了伪客户端之外，Redis服务器为Lua环境创建的另一个协作组件是lua_scripts字典，这个字典的键为某个lua脚本的SHA1校验和(checksum), 而字典的值则是SHA1校验和对应的Lua脚本。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">redisServer</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  dict <span class="token operator">*</span>lua_scripts<span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>redis服务器会将所有被EVAL命令执行过的Lua脚本，以及所有被SCRIPT LOAD命令载入过的Lua脚本都保存到lua_scripts字典里面。</p> <p>lua_scripts字典有两个作用，一个实现SCRIPT EXISTS命令，另一个实现脚本复制功能。</p> <h3 id="eval命令的实现"><a href="#eval命令的实现" class="header-anchor">#</a> EVAL命令的实现</h3> <p>EVAL命令的执行过程可以分为以下三个步骤：</p> <p>a). 根据客户端给定的Lua脚本，在Lua环境中定义一个Lua函数。</p> <p>b). j将客户端给定的脚本保存到lua_scripts字典，等待将来进一步使用。</p> <p>c). 执行刚刚在Lua环境中定义的函数，以此来执行客户端给定的Lua脚本。</p> <ol><li>定义脚本函数</li></ol> <p>当客户端向服务器发送EVAL命令，要求执行某个Lua脚本的时候，服务器首先要做的就是在Lua环境中，为传入的脚本定义一个与这个脚本相对应的Lua函数，其中Lua函数的名字由f_前缀加上脚本的SHA1校验和(四十个字符长)组成，而函数的体(body)则是脚本本身。</p> <p>例如：</p> <div class="language- extra-class"><pre class="language-text"><code>EVAL &quot;return 'hello world'&quot; 0
</code></pre></div><p>来说，服务器将在Lua环境中定义以下函数：</p> <div class="language-lua extra-class"><pre class="language-lua"><code><span class="token keyword">function</span> <span class="token function">f_5332031c6b470dc5a0dd9b4bf2030dea6d65de91</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> <span class="token string">'hello world'</span>
<span class="token keyword">end</span>
</code></pre></div><p>使用函数来保存客户端传入的脚本有以下好处：</p> <p>a). 执行脚本的步骤非常简单，只要调用与脚本相对应的函数即可。</p> <p>b). 通过函数的局部性来让Lua环境保持清洁，减少了垃圾回收的工作量，并且避免了使用全局变量。</p> <p>c). 如果某个脚本所对应的函数在Lua环境中被定义过至少以此，那么只要记得这个脚本的SHA1校验和，服务器就可以在不知道脚本本身的情况下，直接通过调用Lua函数来执行脚本，这是EVALSHA命令的实现原理。</p> <ol start="2"><li>将脚本保存到lua_scripts字典</li></ol> <p>EVAL命令要做的第二件事是将客户端传入的脚本保存到服务器的lua_scripts字典里面。举个例子，对于命令：</p> <div class="language- extra-class"><pre class="language-text"><code>EVAL &quot;return 'hello world'&quot; 0
</code></pre></div><p>来说，服务器将在lua_scripts字典中新添加一个键值对，其中键为Lua脚本的SHA1校验和：</p> <div class="language- extra-class"><pre class="language-text"><code>5332031c6b470dc5a0dd9b4bf2030dea6d65de91
</code></pre></div><p>则值为Lua脚本本身：</p> <div class="language- extra-class"><pre class="language-text"><code>return 'hello world'
</code></pre></div><ol start="3"><li>执行脚本函数</li></ol> <p>在为脚本定义函数，并且将脚本保存到lua_scripts字典之后，服务器还需要进行一些设置钩子，传入参数之类的准备动作，才能正式开始执行脚本。</p> <p>整个准备和执行脚本的过程如下：</p> <p>a). 将EVAL命令中传入的键名(key name)参数和脚本参数分别保存到KEYS数组和ARGV数组，然后将这两个数组作为全局变量传入到Lua环境里面。</p> <p>b). 为Lua环境装载超时处理钩子(hook), 这个钩子可以在脚本出现超过运行情况时，让客户端通过SCRIPT KILL命令停止脚本，或者通过SHUTDOWN命令直接关闭服务器。</p> <p>c). 执行脚本函数</p> <p>d). 移除之前装载的超时钩子</p> <p>e). 将执行脚本函数所得的结果保存到客户端状态的输出缓冲区里面，等待服务器将结果返回给客户端</p> <p>f). 对Lua环境执行垃圾回收操作。</p> <ol start="4"><li>EVALSHA命令的实现</li></ol> <p>只要脚本对应的函数曾在Lua环境里面定义过，那么即使不知道脚本的内容本身，客户端也可以根据脚本的SHA1校验和来调用脚本对应的函数，从而达到执行脚本的目的，这就是EVALSHA命令的实现原理。</p> <p>伪代码：</p> <div class="language-py extra-class"><pre class="language-py"><code><span class="token keyword">def</span> <span class="token function">EVALSHA</span><span class="token punctuation">(</span>sha1<span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token comment"># 拼接出函数的名字</span>
  <span class="token comment"># 例如：f_5332031c6b470dc5a0dd9b4bf2030dea6d65de91</span>
  func_name <span class="token operator">=</span> <span class="token string">&quot;f_&quot;</span> <span class="token operator">+</span> sha1
  <span class="token comment"># 查看这个函数在Lua环境中是否存在</span>
  <span class="token keyword">if</span> function_exists_in_lua_env<span class="token punctuation">(</span>func_name<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment"># 如果函数存在，那么执行它</span>
    execute_lua_function<span class="token punctuation">(</span>func_name<span class="token punctuation">)</span>
  <span class="token keyword">else</span><span class="token punctuation">:</span>
    <span class="token comment"># 如果函数不存在，那么返回一个错误</span>
    send_script_error<span class="token punctuation">(</span><span class="token string">&quot;SCRIPT NOT FOUND&quot;</span><span class="token punctuation">)</span>
</code></pre></div><ol start="5"><li>脚本管理命令的实现</li></ol> <p>除了EVAL命令和EVALSHA命令之外，Redis中与Lua脚本有关的命令还有四个，它们分别是SCRIPT FLUSH命令，SCRIPT EXISTS命令，SCRIPT LOAD命令，以及SCRIPT KILL 命令。</p> <p>a). SCRIPT FLUSH</p> <p>SCRIPT FLUSH命令用于清楚服务器中所有和Lua脚本有关的信息，这个命令会释放并重建lua_scripts字典，关闭现有的Lua环境并重新创建一个新的Lua环境。</p> <p>伪代码：</p> <div class="language-py extra-class"><pre class="language-py"><code><span class="token keyword">def</span> <span class="token function">SCRIPT_FLUSH</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token comment"># 释放脚本字典</span>
  dictRelease<span class="token punctuation">(</span>server<span class="token punctuation">.</span>lua_scripts<span class="token punctuation">)</span>
  <span class="token comment"># 重建脚本字典</span>
  server<span class="token punctuation">.</span>lua_scripts <span class="token operator">=</span> dictCreate<span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>
  <span class="token comment"># 关闭Lua环境</span>
  lua_close<span class="token punctuation">(</span>server<span class="token punctuation">.</span>lua<span class="token punctuation">)</span>
  <span class="token comment"># 初始化一个新的Lua环境</span>
  server<span class="token punctuation">.</span>lua <span class="token operator">=</span> init_lua_env<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>b). SCRIPT EXISTS</p> <p>SCRIPT EXISTS命令根据输入的SHA1校验和，检查校验和对应的脚本是否存在于服务器中。</p> <p>SCRIPT EXISTS命令是通过检查给定的检验和是否存在lua_scripts字典来实现的，伪代码：</p> <div class="language-py extra-class"><pre class="language-py"><code><span class="token keyword">def</span> <span class="token function">SCRIPT_EXISTS</span><span class="token punctuation">(</span><span class="token operator">*</span>sha1_list<span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token comment"># 结果列表</span>
  result_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token comment"># 遍历输入的所有SHA1检验和</span>
  <span class="token keyword">for</span> sha1 <span class="token keyword">in</span> sha1_list<span class="token punctuation">:</span>
    <span class="token comment"># 检查校验和是否为lua_scripts字典的键</span>
    <span class="token comment"># 如果是的话，那么表示检验和对应的脚本存在</span>
    <span class="token comment"># 否则的话，脚本就不存在</span>
    <span class="token keyword">if</span> sha1 <span class="token keyword">in</span> server<span class="token punctuation">.</span>lua_scripts<span class="token punctuation">:</span>
      <span class="token comment"># 存在用1表示</span>
      result_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
      <span class="token comment"># 不存在用0表示</span>
      result_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
  <span class="token comment"># 向客户端返回结果列表</span>
  send_list_reply<span class="token punctuation">(</span>result_list<span class="token punctuation">)</span>
</code></pre></div><p>SCRIPT_EXISTS命令允许一次传入多个SHA1检验和。</p> <p>实现SCRIPT_EXISTS实际上并不需要lua_scripts字典的值。如果lua_scripts字典只用于实现SCRIPT EXISTS命令的话，那么字典只需要保存lua脚本的SHA1校验和就可以了，并不需要保存Lua脚本本身。lua_scripts字典既保存脚本的SHA1校验和，又保存脚本本身的原因是为了实现脚本复制功能。</p> <p>c). SCRIPT LOAD</p> <p>SCRIPT LOAD命令所做的事情和EVAL命令执行脚本时所做的前两步完全一样：命令首先在Lua环境中为脚本创建相对应的函数，然后再将脚本保存到lua_scripts字典里面。</p> <p>后续，客户端就可以使用EVALSHA命令来执行前面被SCRIPT LOAD命令载入脚本了。</p> <p>d). SCRIPT KILL</p> <p>如果服务器设置了lua-time-limit配置选项，那么再每次执行Lua脚本之前，服务器都会再Lua环境里面设置一个超时处理钩子(hook).</p> <p>超时处理钩子再脚本运行期间，会定期检查脚本已经运行了多长时间，一旦钩子发现脚本的运行时间已经超过了lua-time-limit选项设置的时长，钩子将定期再脚本运行的间隙中，查看是否有SCRIPT KILL 命令或者SHUTDOWN命令到达服务器。</p> <p>如果超时运行的脚本未执行过任何写入操作，那么客户端可以通过SCRIPT KILL命令来指示服务器停止执行这个脚本，并向执行该脚本的客户端发送一个错误回复。处理完SCRIPT KILL命令之后，服务器可以继续运行。</p> <p>另一方面，如果脚本已经执行过写入操作，那么客户端只能用SHUTDOWN nosave命令来停止服务器，从而防止不合法的数据被写入数据库中。</p> <h3 id="脚本复制"><a href="#脚本复制" class="header-anchor">#</a> 脚本复制</h3> <p>与其他普通redis命令一样，当服务器运行再复制模式之下时，具有写性质的脚本命令也会被复制到从服务器，这些命令包括EVAL命令，EVALSHA命令，SCRIPT FLUSH命令，以及SCRIPT LOAD命令。</p> <ol><li>复制EVAL命令，SCRIPT FLUSH命令和SCRIPT LOAD命令</li></ol> <p>Redis复制EVAL, SCRIPT FLUSH, SCRIPT LOAD三个命令的方法和复制其他普通redis命令的方法一样，当主服务器执行完以上三个命令的其中一个时，主服务器会直接将被执行的命令传播(propagate)给所有从服务器</p> <p>a). EVAL</p> <p>在胡服务器执行的Lua脚本同样会在所有从服务器中执行。</p> <p>b). SCRIPT FLUSH</p> <p>如果客户端向主服务器发送SCRIPT FLUSH命令，那么主服务器也会向所有从服务器传播SCRIPT FLUSH命令。</p> <p>最终的结果是，主从服务器双方都会重置自己的Lua环境，并清空自己的脚本字典。</p> <p>c). SCRIPT LOAD</p> <p>如果客户端使用SCRIPT LOAD命令，向主服务载入一个Lua脚本，那么主服务器将向所有从服务器传播相同的SCRIPT LOAD命令，使得所有从服务器也会载入相同的Lua脚本。</p> <ol start="2"><li>复制EVALSHA命令</li></ol> <p>EVALSHA命令是所有与Lua脚本有关的命令中，复制操作最复杂的一个，因为主服务器与从服务器载入Lua脚本的情况可能有所不同，所以主服务器不能像复制EVAL命令，SCRIPT LOAD命令或者SCRIPT FLUSH命令那样，直接将EVALSHA命令传播给从服务器。对于一个在主服务器被成功执行的EVALSHA命令来说，相同的EVALSHA命令在从服务器执行时却可能会出现脚本未找到(not found)错误。</p> <h3 id="重点回顾-9"><a href="#重点回顾-9" class="header-anchor">#</a> 重点回顾</h3> <p>a). Redis服务器在启动时，会对内嵌的Lua环境执行一系列修改操作，从而确保内嵌的Lua环境可以满足Redis在功能性，安全性等方面的需要。</p> <p>b). Redis服务器专门使用一个伪客户端来执行Lua脚本中包含的Redis命令</p> <p>c). Redis使用脚本字典来保存所有被EVAL命令执行过，或者被SCRIPT LOAD命令载入过的Lua脚本，这些脚本可以用于实现SCRIPT EXISTS命令，以及实现脚本复制功能。</p> <p>d). EVAL命令为客户端输入的脚本在Lua环境中定义一个函数，并通过调用这个函数来执行脚本。</p> <p>e). EVALSHA命令通过直接调用Lua环境中已定义的函数来执行脚本。</p> <p>f). SCRIPT FLUSH 命令会清空服务器lua_scripts字典中保存的脚本，并重置Lua环境。</p> <p>g). SCRIPT EXISTS命令接受一个或多个SHA1校验和为参数，并通过检查lua_scripts字典来确认校验和对应的脚本是否存在。</p> <p>h). SCRIPT LOAD命令接受一个Lua脚本为参数，为该脚本在Lua环境中创建函数，并将脚本保存到lua_scripts字典中。</p> <p>i). 服务器在执行脚本之前，会为Lua环境设置一个超时处理钩子，当脚本出现超时运行情况时，客户端可以通过向服务器发送SCRIPT KILL命令来让钩子停止正在执行的脚本，或者发送SHUTDOWN nosave命令来让钩子关闭整个服务器。</p> <p>j). 主服务器复制EVAL, SCRIPT FLUSH, SCRIPT LOAD三个命令的方法和复制普通Redis命令一样，只要将相同的命令传播给从服务器就可以了。</p> <p>k). 主服务器在复制EVALSHA命令时，必须确保所有从服务器都已经载入了EVALSHA命令指定的SHA1校验和所对应的Lua脚本，如果不能确保这一点的话，主服务器会将EVALSHA命令转换成等效的EVAL命令，并通过传播EVAL命令来获得相同的脚本执行效果。</p> <h2 id="排序"><a href="#排序" class="header-anchor">#</a> 排序</h2> <p>Redis的SORT命令可以对列表键，集合键或者有序集合键的值进行排序。</p> <h3 id="sort-命令的实现"><a href="#sort-命令的实现" class="header-anchor">#</a> SORT <key> 命令的实现</key></h3> <p>SORT命令的最简单执行行为为：</p> <div class="language- extra-class"><pre class="language-text"><code>SORT &lt;key&gt;
</code></pre></div><p>这个命令可以对一个包含数字值的键key进行排序。</p> <p>具体步骤为：</p> <p>a). 创建一个和numbers列表长度相同的数组，该数组的每个项都是一个redis.h/redisSortObject结构</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">// 用于保存被排序值及其权重的结构</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">_redisSortObject</span> <span class="token punctuation">{</span>

    <span class="token comment">// 被排序键的值</span>
    robj <span class="token operator">*</span>obj<span class="token punctuation">;</span>

    <span class="token comment">// 权重</span>
    <span class="token keyword">union</span> <span class="token punctuation">{</span>

        <span class="token comment">// 排序数字值时使用</span>
        <span class="token keyword">double</span> score<span class="token punctuation">;</span>

        <span class="token comment">// 排序字符串时使用</span>
        robj <span class="token operator">*</span>cmpobj<span class="token punctuation">;</span>

    <span class="token punctuation">}</span> u<span class="token punctuation">;</span>

<span class="token punctuation">}</span> redisSortObject<span class="token punctuation">;</span>
</code></pre></div><p>b). 遍历数组，将各个数组项的obj指针分别指向numbers列表的各个项，构成obj指针和列表项之间的一对一关系。</p> <p>c). 遍历数组，将各个obj指针所指向的列表项转换成一个double类型的浮点数，并将这个浮点数保存在相应数组项的u.score属性里面。</p> <p>d). 根据数组项u.score属性的值，对数组进行数字值排序，排序后的数组项按u.score属性的值从小到大排序。</p> <p>e). 遍历数组，将各个数组项的obj指针所指向的列表项作为排序结果返回给客户端。</p> <p>SORT命令为每个被排序的键都创建一个与键长度相同的数组，数组的每个项都是一个redisSortObject结构，根据SORT命令使用的选项不同，程序使用redisSortObject结构的方式也不同。</p> <h3 id="alpha选项的实现"><a href="#alpha选项的实现" class="header-anchor">#</a> ALPHA选项的实现</h3> <p>通过使用ALPHA选项，SORT命令可以对包含字符串值的键进行排序：</p> <div class="language- extra-class"><pre class="language-text"><code>SORT &lt;key&gt; ALPHA
</code></pre></div><p>a). 创建一个redisSortObject结构数组，数组的长度等于fruits集合的大小。</p> <p>b). 遍历数组，将各个数组项的obj指针分别指向fruits集合的各个元素。</p> <p>c). 根据obj所指向的集合元素，对数组进行字符串排序，排序后的数组项按集合元素的字符串值从小到大排序。</p> <p>d). 遍历数组，依次将数组项的obj指针所指向的元素返回给客户端。</p> <h3 id="asc选项和desc选项的实现"><a href="#asc选项和desc选项的实现" class="header-anchor">#</a> ASC选项和DESC选项的实现</h3> <p>在默认情况下，SORT命令执行升序排序，排序后的结果按值的大小从小到大排列。</p> <p>使用DESC选项，可以让命令执行降序排序。</p> <p>升序排序和降序排序都由相同的快速排序算法执行，区别在于：</p> <p>a). 在执行升序排序时，排序算法使用的对比函数产生升序对比结果。</p> <p>b). 在执行降序排序时，排序算法所使用的对比函数产生降序对比结果。</p> <h3 id="by选项的实现"><a href="#by选项的实现" class="header-anchor">#</a> BY选项的实现</h3> <p>在默认情况下，SORT使用被排序包含的元素作为排序的权重，元素本身决定了元素在排序之后所处的位置。</p> <p>通过BY选项，SORT命令可以指定某些字符串键，或者某个哈希键包含的某些域(field)来作为元素的权重，对一个键进行排序。</p> <p>服务器执行SORT fruits BY*-price命令的详细步骤如下：</p> <p>a). 创建一个redisSortObject结果数组，数组的长度等于fruits集合的大小。</p> <p>b). 遍历数组，将各个数组项的obj指针分别指向fruits集合的各个元素。</p> <p>c). 遍历数组，根据各个数组项的obj指针所指向的集合元素，以及BY选项所给定的模式 *-price, 查找相应的权重键。</p> <p>d). 将各个权重键的值转换成一个double类型的浮点数，然后保存在相应数组项的u.score属性里面。</p> <p>e). 以数组项u.score属性的值为权重，对数组进行排序，得到一个按u.score属性的值从小到大排序的数组。</p> <p>f). 遍历数组，依次将数组项的obj指针所指向的集合元素返回给客户端。</p> <h3 id="带有alpha选项的by选项的实现"><a href="#带有alpha选项的by选项的实现" class="header-anchor">#</a> 带有ALPHA选项的BY选项的实现</h3> <p>BY选项默认假设权重键保存的值为数字值，如果权重键保存的是字符串值的话，那么就需要在使用BY选项的同时，配合使用ALPHA选项。</p> <div class="language- extra-class"><pre class="language-text"><code>SORT fruit BY *-id ALPHA
</code></pre></div><p>a). 创建一个redisSortObject结构数组，数组的长度等于fruits集合的大小。</p> <p>b). 遍历数组，将各个数组项的obj指针分别指向fruits集合的各个元素。</p> <p>c). 遍历数组，根据各个数组项的obj指针所指向的集合元素，以及BY选项所给定的模式*-id，查找相应的权重键。</p> <p>d). 将各个数组项的u.cmpobj指针分别指向相应的权重键。</p> <p>e). 以各个数组项的权重键的值为权重，对数组执行字符串排序。</p> <p>f). 遍历数组，依次将数组项的obj指针所指向的集合元素返回客户端。</p> <h3 id="limit选项的实现"><a href="#limit选项的实现" class="header-anchor">#</a> LIMIT选项的实现</h3> <p>默认情况下，SORT命令总会将排序后的所有元素返回给客户端。</p> <p>通过LIMIT选项，我们可以让SORT命令只返回其中一部分已排序的元素</p> <div class="language- extra-class"><pre class="language-text"><code>LIMIT &lt;offset&gt; &lt;count&gt;
</code></pre></div><p>offset参数表示要跳过的已排序元素数量。</p> <p>count参数表示跳过给定数量的已排序元素之后，要返回的已排序元素数量。</p> <h3 id="get选项的实现"><a href="#get选项的实现" class="header-anchor">#</a> GET选项的实现</h3> <p>在默认情况下，SORT命令在对键进行排序之后，总是返回被排序键本身所包含的元素。</p> <p>GET选项，我们可以让SORT命令在对键进行排序之后，根据被排序的元素，以及GET选项所指定的模式，查找并返回某些键的值。</p> <p>服务器执行 SORT student ALPHA GET*-name命令的详细步骤如下：</p> <p>a). 创建一个redisSortObject结构数组，数组的长度等于students集合的大小。</p> <p>b). 遍历数组，将各个数组项的obj指针分别指向students集合的各个元素。</p> <p>c). 根据obj指针所指向的集合元素，对数组进行字符串排序。</p> <p>d). 遍历数组，根据数组项obj指针所指向的集合元素，以及GET选项所给定的*-name模式。</p> <p>e). 遍历查找程序返回的三个键，并向客户端返回它们的值。</p> <p>因为一个SORT命令可以带有多个GET选项，所以随着GET选项的增多，命令要执行的查找操作也会增多。</p> <h3 id="store选项的实现"><a href="#store选项的实现" class="header-anchor">#</a> STORE选项的实现</h3> <p>在默认情况下，SORT命令指向客户端返回排序结果，而不保存排序结果。</p> <p>但是，通过使用STORE选项，我们可以将排序结果保存在指定的键里面，并在有需要时重用这个排序结果。</p> <p>服务器执行 SORT students ALPHA STORE sorted_students 命令的步骤：</p> <p>a). 创建一个redisSortObject结构数组，数组的长度等于students集合的大小。</p> <p>b). 遍历数组，将各个数组项的obj指针分别指向students集合的各个元素。</p> <p>c). 根据obj指针所指向的集合元素，对数组进行字符串排序。</p> <p>d). 检查sorted_students键是否存在，如果存在的话，那么删除该键。</p> <p>e). 设置sorted_students为空白的列表键。</p> <p>f). 遍历数组，将排序后的元素依次推入sorted_students列表的末尾，相当于执行命令 RPUSH命令。</p> <p>g). 遍历数组，向客户端返回结果。</p> <h3 id="多个选项的执行顺序"><a href="#多个选项的执行顺序" class="header-anchor">#</a> 多个选项的执行顺序</h3> <ol><li>选项的执行顺序</li></ol> <p>a). 排序: ALPHA, ASC 或 DESC, BY这几个选项。</p> <p>b). 限制排序结果集长度： LIMIT。</p> <p>c). 获取外部键： 命令会使用GET选项，根据排序结果集中的元素，以及GET选项指定的模式，查找并获取指定键的值，并用这些值来作为新的排序结果集。</p> <p>d). 保存排序结果集：使用STORE选项，将排序结果集保存到指定的键上面。</p> <p>e). 向客户端返回排序结果集。</p> <ol start="2"><li>选项的摆放顺序</li></ol> <p>另外要提醒的一点是，调用SORT命令时，除了GET选项时，改变选项的摆放顺序并不会影响SORT命令执行这些选项的顺序。</p> <p>如果命令包含了多个GET选项，那么在调整选项的位置时，必须保证多个GET选项的摆放顺序不变，这才可以让排序结果集保持不变。</p> <h3 id="重点回顾-10"><a href="#重点回顾-10" class="header-anchor">#</a> 重点回顾</h3> <p>a). SORT 命令通过将被排序键包含的元素载入到数组里面，然后对数组进行排序来完成对键进行排序的工作。</p> <p>b). 默认情况下，SORT命令假设被排序键包含的都是数字值，并且以数字值的方式来进行排序。</p> <p>c). 如果SORT命令使用了ALPHA选项，那么SORT命令假设被排序键包含的都是字符串值，并且以字符串的方式来进行排序。</p> <p>d). SORT命令的排序操作由快速排序算法实现</p> <p>e). SORT命令会根据用户是否使用DESC选项来决定是是使用升序对比还是降序对比来比较被排序的元素。</p> <p>f). 当SORT命令使用了BY选项时，命令使用其他键的值作为权重来进行排序操作。</p> <p>g). 当SORT命令使用了LIMIT选项时，命令只保留排序结果集中LIMIT选项指定的元素。</p> <p>h). 当SORT命令使用了GET选项时，命令会根据排序结果集中的元素，以及GET选项给定的模式，查找并返回其他键的值，而不是返回被排序的元素。</p> <p>i). 当SORT命令使用了STORE选项时，命令会将排序结果集保存在指定的键里面。</p> <p>j). 当SORT命令同时使用多个选项时，命令先执行排序操作，然后执行LIMIT选项，之后执行GET选项，再之后执行STORE选项，最后才将排序结果集返回给客户端。</p> <p>k). 除了GET选项之外，调整选项的摆放位置不会影响SORT命令的排序结果。</p> <h2 id="二进制位数组"><a href="#二进制位数组" class="header-anchor">#</a> 二进制位数组</h2> <p>Redis 提供了 SETBIT, GETBIT, BITCOUNT, BITOP 四个命令用于处理二进制位数组(bit array, 又称&quot;位数组&quot;)</p> <p>其中，SETBIT 命令用于为位数组指定偏移量上的二进制位设置值，位数组的偏移量从0开始计数，从二进制位的值可以是0或者1.</p> <div class="language- extra-class"><pre class="language-text"><code>SETBIT bit &lt;位&gt; &lt;值&gt;
</code></pre></div><p>而GETBIT命令则用于获取位数组指定偏移量上的二进制位的值</p> <div class="language- extra-class"><pre class="language-text"><code>GETBIT bit &lt;位&gt;
</code></pre></div><p>BITCOUNT命令用于统计位数组里面，值为1的二进制位的数量。</p> <div class="language- extra-class"><pre class="language-text"><code>BITCOUNT bit
</code></pre></div><p>BITOP命令既可以对多个位数组进行按位与(and), 按位或(or), 按位异或(xor) 运算 和 取反操作</p> <div class="language- extra-class"><pre class="language-text"><code>BITOP AND &lt;result&gt; &lt;key&gt; &lt;key1&gt;....

BITOP OR &lt;result&gt; &lt;key&gt; &lt;key1&gt;....

BITOP XOR &lt;result&gt; &lt;key&gt; &lt;key1&gt;....

BITOP NOT &lt;reuslt&gt; &lt;bitKey&gt;
</code></pre></div><h3 id="位数组的表示"><a href="#位数组的表示" class="header-anchor">#</a> 位数组的表示</h3> <p>Redis使用字符串对象来表示位数组，因为字符串对象使用的SDS数据结构是二进制安全的，所以程序可以直接使用SDS结构来保存位数组，并使用SDS结构的操作函数来处理位数组。</p> <p>一字节长的位数组：</p> <p>a). redisObject.type的值为REDIS_STRING, 表示这是一个字符串对象。</p> <p>b). sdshdr.len的值为1，表示这个SDS保存了一个一字节长的位数组。</p> <p>c). buf数组中的buf[0]字节保存了一字节的位数组。</p> <p>d). buf数组中的buf[1]字节保存了SDS程序自动追加到值的末尾的空字符'\0'</p> <h3 id="getbit命令的实现"><a href="#getbit命令的实现" class="header-anchor">#</a> GETBIT命令的实现</h3> <p>GETBIT命令用于返回位数组bitarray在offset偏移量上的二进制位的值：</p> <div class="language- extra-class"><pre class="language-text"><code>GETBIT &lt;bitarray&gt; &lt;offset&gt;
</code></pre></div><p>GETBIT命令的执行过程如下：</p> <p>a). 计算byte=offset/8, byte值记录了offset偏移量指定的二进制位保存在位数组的哪个字节。</p> <p>b). 计算bit = (offset mod 8) + 1, bit 值记录了offset偏移量指定的二进制位是byte字节的第几个二进制位。</p> <p>c). 根据byte值和bit值，在位数组bitarray中定位offset偏移量指定的二进制位，并返回这个位的值。</p> <p>因为GETBIT命令执行的所有操作都可以在常熟时间内完成，所以该命令的算法复杂度为O(1).</p> <h3 id="setbit命令的实现"><a href="#setbit命令的实现" class="header-anchor">#</a> SETBIT命令的实现</h3> <p>SETBIT用于将位数组bitarray在offset偏移量上的二进制位的值设置为value, 并向客户端返回二进制位被设置之前的旧值：</p> <div class="language- extra-class"><pre class="language-text"><code>SETBIT &lt;bitarray&gt; &lt;offset&gt; &lt;value&gt;
</code></pre></div><p>执行过程</p> <p>a). 计算len = offset / 8 + 1, len值记录了保存offset偏移量指定的二进制位至少需要多少字节。</p> <p>b). 检查bitarray键保存的位数组(也即是SDS)的长度是否小于len，如果是的话，将SDS的长度扩展为len字节，并将所有新扩展空间的二进制位的值设置为0.</p> <p>c). 计算byte = offset / 8, byte值记录了offset偏移量指定的二进制位保存在位数组的哪个字节。</p> <p>d). 计算bit = (offset mod 8) + 1, bit 值记录了offset偏移量指定的二进制位是byte字节的第几个二进制位。</p> <p>e). 根据byte值和bit值，在bitarray键保存的位数组中定位offset偏移量指定的二进制位，首先将指定二进制位现在值保存在oldvalue变量，然后将新值value设置为这个二进制位的值。</p> <p>f). 向客户端返回oldvalue变量的值。</p> <p>因为SETBIT命令执行的所有操作都可以在常数时间内完成，所以该命令的时间复杂度为 O(1)</p> <h3 id="bitcount命令的实现"><a href="#bitcount命令的实现" class="header-anchor">#</a> BITCOUNT命令的实现</h3> <p>BITCOUNT命令用于统计给定位数组中，值为1的二进制位的数量。</p> <ol><li>二进制位统计算法：遍历算法</li></ol> <p>实现BITCOUNT命令最简单直接的方法，就是遍历位数组中的每个二进制位，并在遇到值为1的二进制位时，将计数器的值增一。</p> <ol start="2"><li>二进制位统计算法：查表算法</li></ol> <p>优化检查操作的一个办法是使用查表法：</p> <p>a. 对于一个有限集合来说，集合元素的排列方法是有限的。</p> <p>b. 而对于一个有限长度的位数组来说，它能表示的二进制位排列也是有限的。</p> <p>我们可以创建一个表，表的键为某种排列的位数组，而表的值则是相应位数组中，值为1的二进制位的数量。</p> <p>创建了这种表之后，我们就可以根据输入的位数组进行查表，在无须对位数组的每个位进行检查的情况下，直接知道这个位数组包含了多少个值为1的二进制位。</p> <p>空间换时间的方法。</p> <p>a). 查表法是典型的空间换时间策略，算法在计算方法节约的时间是通过花费额外的内存换取而来的，节约的时间越多，花费的内存就越大。在实际中，服务器只可能接受数百个字节或者数百KB的内存消耗。</p> <p>b). 除了内存大小的问题之外，查表法的效果还会受到CPU缓存的限制：对于固定大小的CPU缓存来说，创建的表格越大，CPU缓存所能保存的内容相比整个表格的比例就越少，查表时出现缓存不命中的情况就会越高，缓存的换入和换出操作就会越频繁，最终影响查表法的实际效率。</p> <ol start="3"><li>二进制位统计算法(3): variable-precision SWAR算法</li></ol> <p>BITCOUNT命令要解决的问题————统计一个位数组中非0二进制位的数量，在数学上被称为&quot;计算汉明重量&quot;</p> <p>以下为处理32位长度位数组的variable-precision SWAR算法的实现：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">uint32_t</span> <span class="token function">swar</span><span class="token punctuation">(</span><span class="token keyword">uint32_t</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 步骤1</span>
  i <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token operator">&amp;</span> <span class="token number">0x55555555</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>i <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0x55555555</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 步骤2</span>
  i <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token operator">&amp;</span> <span class="token number">0x33333333</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>i <span class="token operator">&gt;&gt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0x33333333</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 步骤3</span>
  i <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token operator">&amp;</span> <span class="token number">0x0F0F0F0F</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>I <span class="token operator">&gt;&gt;</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0x0F0F0F0F</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 步骤4</span>
  i <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">0x01010101</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token number">24</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> i<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>一个循环中执行多个swar调用这种优化方式有极限的：一旦循环中处理的位数组的大小超过了缓存的大小，这种优化的效果会降低并最终消失。</p> <ol start="4"><li>二进制位统计算法(4): Redis的实现</li></ol> <p>BITCOUNT命令的实现用到了查表和variable-precisionSWAR两种算法。</p> <p>a). 查表算法使用键长为8位的表，表中记录了从0000 0000到 1111 1111在内的所有二进制位的汉明重量。</p> <p>b). SWAR算法方面，BITCOUNT命令在每次循环中载入128个二进制位，然后调用四次32位variable-precision SWAR算法来计算这128个二进制位的汉明重量。</p> <p>在执行BITCOUNT命令时，程序会根据未处理的二进制位的数量来决定使用那种算法：</p> <p>a). 如果未处理的二进制位的数量大于等于128位，那么程序使用 SWAR算法来计算二进制位的汉明重量。</p> <p>b). 如果未处理的二进制位的数量小于128位时，使用查表法。</p> <p>伪代码如下：</p> <div class="language-py extra-class"><pre class="language-py"><code><span class="token comment"># 一个表，记录了所有八位长位数组的汉明重量</span>
<span class="token comment"># 程序将8位长的位数组转换成无符号整数，并在表中进行索引</span>

weight_in_byte <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">]</span>
<span class="token keyword">def</span> <span class="token function">BITCOUNT</span><span class="token punctuation">(</span>bits<span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token comment"># 计算位数组包含了多少个二进制位</span>
  count <span class="token operator">=</span> count_bit<span class="token punctuation">(</span>bits<span class="token punctuation">)</span>
  <span class="token comment"># 初始化汉明重量为零</span>
  weight <span class="token operator">=</span> <span class="token number">0</span>
  <span class="token comment"># 如果未处理的二进制位大于等于128位</span>
  <span class="token comment"># 那么使用variable-precision SWAR算法来处理</span>
  <span class="token keyword">while</span> count <span class="token operator">&gt;=</span> <span class="token number">128</span><span class="token punctuation">:</span>
    <span class="token comment"># 四个swar调用，每个调用计算32个二进制位的汉明重量</span>
    weight <span class="token operator">+=</span> swar<span class="token punctuation">(</span>bits<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">32</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    weight <span class="token operator">+=</span> swar<span class="token punctuation">(</span>bits<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">:</span><span class="token number">64</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    weight <span class="token operator">+=</span> swar<span class="token punctuation">(</span>bits<span class="token punctuation">[</span><span class="token number">64</span><span class="token punctuation">:</span><span class="token number">96</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    weight <span class="token operator">+=</span> swar<span class="token punctuation">(</span>bits<span class="token punctuation">[</span><span class="token number">96</span><span class="token punctuation">:</span><span class="token number">128</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token comment"># 移动指针，略过已处理的位，指向未处理的位</span>
    bits <span class="token operator">=</span> bits<span class="token punctuation">[</span><span class="token number">128</span><span class="token punctuation">:</span><span class="token punctuation">]</span>
    <span class="token comment"># 减少未处理位的长度</span>
    count <span class="token operator">-=</span> <span class="token number">128</span>
  <span class="token comment"># 如果执行到这里，说明未处理的位数量不足128位</span>
  <span class="token comment"># 那么使用查表法来计算汉明重量</span>
  <span class="token keyword">while</span> count<span class="token punctuation">:</span>
    <span class="token comment"># 将8个位转换成无符号整数，作为查表的索引键</span>
    index <span class="token operator">=</span> bits_to_unsigned_int<span class="token punctuation">(</span>bits<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    weight <span class="token operator">+=</span> weight_in_byte<span class="token punctuation">[</span>index<span class="token punctuation">]</span>
    <span class="token comment"># 移动指针，略过已处理的位，指向未处理的位</span>
    bits <span class="token operator">=</span> bit<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">:</span><span class="token punctuation">]</span>
    <span class="token comment"># 减少未处理的长度</span>
    count <span class="token operator">-=</span> <span class="token number">8</span>
  <span class="token keyword">return</span> weight
</code></pre></div><p>这个BITCOUNT实现的算法复杂度为O(n), n为二进制位的数量。</p> <h3 id="bitop命令的实现"><a href="#bitop命令的实现" class="header-anchor">#</a> BITOP命令的实现</h3> <p>因为C语言直接支持对字节执行逻辑与(&amp;), 逻辑或(|), 逻辑异或(^) 和 逻辑非(~)操作。所以BITOP命令的AND，OR,XOR和NOT四个操作都是直接基于这些逻辑操作实现的：</p> <p>a). 在执行BITOP AND命令时，程序用&amp;操作计算出所有输入二进制位的逻辑与结果，然后保存在指定的键上面。</p> <p>b). 在执行BITOP OR命令时，程序用|操作计算出所有输入二进制位的逻辑或结果，然后保存在指定的键上面。</p> <p>c). 在执行BITOP XOR命令时，程序用^ 操作计算出所有输入二进制位的逻辑异或结果，然后保存在指定的键上面。</p> <p>d). 在执行BITOP NOT命令时，程序用~操作计算出输入二进制位的逻辑非结果，然后保存在指定的键上面。</p> <p>AND, OR, XOR三个命令可以接受多个位数组作为输入，程序需要遍历输入的每个位数组的每个字节来进行计算，复杂度为O(n^2); NOT命令只接受一个位数组输入，复杂度为O(n)</p> <h3 id="重点回顾-11"><a href="#重点回顾-11" class="header-anchor">#</a> 重点回顾</h3> <p>a). redis使用SDS来保存位数组</p> <p>b). SDS使用逆序来保存位数组，这种保存顺序简化了SETBIT命令的实现，使得SETBIT命令可以在不移动现有二进制位的情况下，对位数组进行空间扩展。</p> <p>c). BITCOUNT命令使用了查表算法和 variable-precision SWAR算法来优化命令来执行效率</p> <p>d). BITOP命令的所有操作都使用C语言内置的位操作来实现。</p> <h2 id="慢查询日志"><a href="#慢查询日志" class="header-anchor">#</a> 慢查询日志</h2> <p>Redis的慢查询日志功能用于记录执行时间超过给定时长的命令请求，用户可以通过这个功能产生的日志来监视和优化查询速度。</p> <p>服务器配置两个和慢查询日志相关的选项：</p> <p>a). slowlog-log-slower-than选项指定执行时间超过多少微妙的命令请求会被记录到日志上。</p> <p>b). slowlog-max-len选项指定服务器最多保存多少条慢查询日志。</p> <h3 id="慢查询记录的保存"><a href="#慢查询记录的保存" class="header-anchor">#</a> 慢查询记录的保存</h3> <p>服务器状态中包含了几个和慢查询日志功能有关的属性：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">redisServer</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  <span class="token comment">// 下一条慢查询日志的ID</span>
  <span class="token keyword">long</span> <span class="token keyword">long</span> slowlog_entry_id<span class="token punctuation">;</span>
  <span class="token comment">// 保存了所有慢查询日志的链表</span>
  list <span class="token operator">*</span>slowlog<span class="token punctuation">;</span>
  <span class="token comment">// 服务器配置slowlog-log-slower-than选项的值</span>
  <span class="token keyword">long</span> <span class="token keyword">long</span> slowlog_log_slower_than<span class="token punctuation">;</span>
  <span class="token comment">// 服务器配置slowlog-max-len选项的值</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> slowlog_max_len<span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>slowlog_entry_id属性的初始值为0，每当创建一条新的慢查询日志时，这个属性的值就会用作新日志的id值，之后程序会对这个属性的值增一。</p> <p>slowlog链表保存了服务器中的所有慢查询日志，链表中的每个节点都保存了一个slowlogEntry结构，每个slowlogEntry结构代表一条慢查询日志：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">slowlogEntry</span> <span class="token punctuation">{</span>
  <span class="token comment">// 唯一标识符</span>
  <span class="token keyword">long</span> <span class="token keyword">long</span> id<span class="token punctuation">;</span>
  <span class="token comment">// 命令执行时的时间，格式为UNIX时间戳</span>
  time_t time<span class="token punctuation">;</span>
  <span class="token comment">// 执行命令消耗的时间，以微妙为单位</span>
  <span class="token keyword">long</span> <span class="token keyword">long</span> duration<span class="token punctuation">;</span>
  <span class="token comment">// 命令与命令参数</span>
  robj <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">;</span>
  <span class="token comment">// 命令与命令参数的数量</span>
  <span class="token keyword">int</span> argc<span class="token punctuation">;</span>
<span class="token punctuation">}</span> slowlogEntry<span class="token punctuation">;</span>
</code></pre></div><h3 id="慢查询日志的阅览和删除"><a href="#慢查询日志的阅览和删除" class="header-anchor">#</a> 慢查询日志的阅览和删除</h3> <p>SLOWLOG GET命令伪代码：</p> <div class="language-py extra-class"><pre class="language-py"><code><span class="token keyword">def</span> <span class="token function">SLOWLOG_GET</span><span class="token punctuation">(</span>number<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token comment"># 用户没有给定number参数</span>
  <span class="token comment"># 那么打印服务器包含的全部慢查询日志</span>
  <span class="token keyword">if</span> number <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
    number <span class="token operator">=</span> SLOWLOG_LEN<span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token comment"># 遍历服务器中的慢查询日志</span>
  <span class="token keyword">for</span> log <span class="token keyword">in</span> redisServer<span class="token punctuation">.</span>slowlog<span class="token punctuation">:</span>
    <span class="token keyword">if</span> number <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">:</span>
      <span class="token comment"># 打印的日志数量已经足够，跳出循环</span>
      <span class="token keyword">break</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
      <span class="token comment"># 继续打印，将计数器的值减一</span>
      number <span class="token operator">-=</span> <span class="token number">1</span>
      <span class="token comment"># 打印日志</span>
      printLog<span class="token punctuation">(</span>log<span class="token punctuation">)</span>
</code></pre></div><p>查看日志数量的SLOWLOG LEN命令可以用以下伪代码来定义：</p> <div class="language-py extra-class"><pre class="language-py"><code><span class="token keyword">def</span> <span class="token function">SLOWLOG_LEN</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token comment"># slowlog链表的长度就是慢查询日志的条目数量</span>
  <span class="token keyword">return</span> <span class="token builtin">len</span><span class="token punctuation">(</span>redisServer<span class="token punctuation">.</span>slowlog<span class="token punctuation">)</span>
</code></pre></div><p>另外，用于清除所有慢查询日志的SLOWLOG RESET命令可以用以下伪代码来定义：</p> <div class="language-py extra-class"><pre class="language-py"><code><span class="token keyword">def</span> <span class="token function">SLOWLOG_RESET</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token comment"># 遍历服务器中的所有慢查询日志</span>
  <span class="token keyword">for</span> log <span class="token keyword">in</span> redisServer<span class="token punctuation">.</span>slowlog<span class="token punctuation">:</span>
    <span class="token comment"># 删除日志</span>
    deleteLog<span class="token punctuation">(</span>log<span class="token punctuation">)</span>
</code></pre></div><h3 id="添加新日志"><a href="#添加新日志" class="header-anchor">#</a> 添加新日志</h3> <p>在每次执行命令的之前和之后，程序都会记录微秒格式的当前UNIX时间戳，这两个时间戳之间的差就是服务器执行命令所耗费的时长，服务器会将这个时长作为参数之一传给slowlogPushEntryIfNeeded函数，而slowlogPushEntryIfNeeded函数则负责检查是否需要为这次执行的命令创建慢查询日志。</p> <div class="language-py extra-class"><pre class="language-py"><code><span class="token comment"># 记录执行命令前的时间</span>
before <span class="token operator">=</span> unixtime_now_in_us<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment"># 执行命令</span>
execute_command<span class="token punctuation">(</span>argv<span class="token punctuation">,</span> argc<span class="token punctuation">,</span> client<span class="token punctuation">)</span>
<span class="token comment"># 记录执行命令后的时间</span>
after <span class="token operator">=</span> unixtime_now_in_us<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment"># 检查是否需要创建新的慢查询日志</span>
slowlogPushEntryIfNeeded<span class="token punctuation">(</span>argv<span class="token punctuation">,</span> argc<span class="token punctuation">,</span> before<span class="token operator">-</span>after<span class="token punctuation">)</span>
</code></pre></div><p>slowlogPushEntryIfNeeded 函数的作用有两个：</p> <p>a). 检查命令的执行时长是否超过slowlog-log-slower-than选项所设置的时间，如果是的话，就为命令创建一个新的日志，并将新日志添加到slowlog链表的表头</p> <p>b). 检查慢查询日志的长度是否超过slowlog-max-len选项所设置的长度，如果是的话，那么将多出来的日志从slowlog链表中删除掉</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">slowlogPushEntryIfNeeded</span><span class="token punctuation">(</span>robj <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">,</span> <span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">long</span> <span class="token keyword">long</span> duration<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 慢查询功能未开启，直接返回</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>slowlog_log_slower_than <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 如果执行时间超过服务器设置的上限，那么将命令添加到慢查询日志</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>duration <span class="token operator">&gt;=</span> server<span class="token punctuation">.</span>slowlog_log_slower_than<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">listAddNodeHead</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>slowlog<span class="token punctuation">,</span> <span class="token function">slowlogCreateEntry</span><span class="token punctuation">(</span>argv<span class="token punctuation">,</span> argc<span class="token punctuation">,</span> duration<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">listLength</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>slowlog<span class="token punctuation">)</span> <span class="token operator">&gt;</span> server<span class="token punctuation">.</span>slowlog_max_len<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">listDelNode</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>slowlog<span class="token punctuation">,</span> <span class="token function">listLast</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>slowlog<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>slowlogCreateEntry函数：该函数根据传入的参数，创建一个新的慢查询日志，并将redisServer.slowlog_entry_id的增1.</p> <h3 id="重点回顾-12"><a href="#重点回顾-12" class="header-anchor">#</a> 重点回顾</h3> <p>a). redis的慢查询日志功能用于记录执行时间超过指定时长的命令</p> <p>b). redis服务器将所有的慢查询日志保存在服务器状态的slowlog链表中，每个链表节点都包含一个slowlogEntry结构，每个slowlogEntry结构代表一条慢查询日志</p> <p>c). 打印和删除慢查询日志可以通过遍历slowlog链表来完成</p> <p>d). slowlog链表的长度就是服务器所保存慢查询日志的数量</p> <p>e). 新的慢查询日志会被添加到slowlog链表的表头，如果日志的数量超过slowlog-max-len选项的值，那么多出来的日志会被删除。</p> <h2 id="监视器"><a href="#监视器" class="header-anchor">#</a> 监视器</h2> <p>通过执行MONITOR命令，客户端可以将自己变为一个监视器，实时的接收并打印出服务器当前处理的命令请求的相关信息。</p> <p>每当一个客户端向服务器发送一条命令请求时，服务器除了会处理这条命令请求之外，还会将这条请求的信息发送给所有监视器。</p> <h3 id="成为监视器"><a href="#成为监视器" class="header-anchor">#</a> 成为监视器</h3> <p>发送MONITOR命令可以让一个普通客户端变为一个监视器。</p> <div class="language-py extra-class"><pre class="language-py"><code><span class="token keyword">def</span> <span class="token function">MONITOR</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token comment"># 打开客户端的监视器标志</span>
  client<span class="token punctuation">.</span>flags <span class="token operator">|</span><span class="token operator">=</span> REDIS_MONITOR
  <span class="token comment"># 将客户端添加到服务器状态的monitors链表的末尾</span>
  server<span class="token punctuation">.</span>monitors<span class="token punctuation">.</span>append<span class="token punctuation">(</span>client<span class="token punctuation">)</span>
  <span class="token comment"># 向客户端返回OK</span>
  send_reply<span class="token punctuation">(</span><span class="token string">&quot;OK&quot;</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="向监视器发送命令信息"><a href="#向监视器发送命令信息" class="header-anchor">#</a> 向监视器发送命令信息</h3> <p>服务器在每次处理命令请求之前，都会调用 replicationFeedMonitors 函数，由这个函数将被处理的命令请求的相关信息发送给各个监视器。</p> <p>replicationFeedMonitors 函数的伪代码定义，函数首先根据传入的参数创建信息，然后将信息发送给所有监视器：</p> <div class="language-py extra-class"><pre class="language-py"><code><span class="token keyword">def</span> <span class="token function">replicationFeedMonitors</span><span class="token punctuation">(</span>client<span class="token punctuation">,</span> monitors<span class="token punctuation">,</span> dbid<span class="token punctuation">,</span> argv<span class="token punctuation">,</span> argc<span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token comment"># 根据执行命令的客户端，当前数据库的号码，命令参数，命令参数个数等参数</span>
  <span class="token comment"># 创建要发送给各个监视器的信息</span>
  msg <span class="token operator">=</span> create_message<span class="token punctuation">(</span>client<span class="token punctuation">,</span> dbid<span class="token punctuation">,</span> argv<span class="token punctuation">,</span> argc<span class="token punctuation">)</span>
  <span class="token comment"># 遍历所有监视器</span>
  <span class="token keyword">for</span> monitor <span class="token keyword">in</span> monitors<span class="token punctuation">:</span>
    <span class="token comment"># 将信息发送给监视器</span>
    send_message<span class="token punctuation">(</span>monitor<span class="token punctuation">,</span> msg<span class="token punctuation">)</span>
</code></pre></div><h3 id="重点回顾-13"><a href="#重点回顾-13" class="header-anchor">#</a> 重点回顾</h3> <p>a). 客户端可以通过执行MONITOR命令，将客户端转换成监视器，接收并打印服务器处理的每个命令请求的相关信息。</p> <p>b). 当一个客户端从普通客户端变成监视器时，该客户端的REDIS_MONITOR标识会被打开。</p> <p>c). 服务器将所有监视器都记录在monitors链表中。</p> <p>d). 每次处理命令请求时，服务器都会遍历monitors链表，将相关信息发送给监视器。</p></div> <footer class="page-edit" style="display:none;"><!----> <div class="last-updated"><span class="prefix">Last Updated: </span> <span class="time">2021-08-13 23:19:12</span></div></footer> <!----> <!----> <!----></main> <!----></div></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div></div></div>
    <script src="/assets/js/app.e5db9849.js" defer></script><script src="/assets/js/3.ed8c06e7.js" defer></script><script src="/assets/js/1.9e75a2be.js" defer></script><script src="/assets/js/41.1b147abb.js" defer></script>
  </body>
</html>
